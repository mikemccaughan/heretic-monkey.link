{"version":3,"file":"index.cjs","sources":["../lib/assert.ts","../lib/bigintmath.ts","../lib/slots.ts","../lib/intrinsicclass.ts","../lib/math.ts","../lib/timeduration.ts","../lib/regex.ts","../lib/ecmascript.ts","../lib/calendar.ts","../lib/intl.ts","../lib/instant.ts","../lib/plaindate.ts","../lib/plaindatetime.ts","../lib/duration.ts","../lib/plainmonthday.ts","../lib/now.ts","../lib/plaintime.ts","../lib/plainyearmonth.ts","../lib/zoneddatetime.ts","../lib/legacydate.ts","../lib/index.ts"],"sourcesContent":["export function assert(condition: boolean, message: string): asserts condition {\r\n  if (!condition) throw new Error(`assertion failure: ${message}`);\r\n}\r\n\r\nexport function assertNotReached(message?: string): never {\r\n  const reason = message ? ` because ${message}` : '';\r\n  throw new Error(`assertion failure: code should not be reached${reason}`);\r\n}\r\n","import JSBI from 'jsbi';\r\n\r\nexport const ZERO = JSBI.BigInt(0);\r\nexport const ONE = JSBI.BigInt(1);\r\nexport const TWO = JSBI.BigInt(2);\r\nexport const TEN = JSBI.BigInt(10);\r\nconst TWENTY_FOUR = JSBI.BigInt(24);\r\nconst SIXTY = JSBI.BigInt(60);\r\nexport const THOUSAND = JSBI.BigInt(1e3);\r\nexport const MILLION = JSBI.BigInt(1e6);\r\nexport const BILLION = JSBI.BigInt(1e9);\r\nconst HOUR_SECONDS = 3600;\r\nexport const HOUR_NANOS = JSBI.multiply(JSBI.BigInt(HOUR_SECONDS), BILLION);\r\nexport const MINUTE_NANOS_JSBI = JSBI.multiply(SIXTY, BILLION);\r\nexport const DAY_NANOS_JSBI = JSBI.multiply(HOUR_NANOS, TWENTY_FOUR);\r\n\r\n/** Handle a JSBI or native BigInt. For user input, use ES.ToBigInt instead */\r\nexport function ensureJSBI(value: JSBI | bigint) {\r\n  return typeof value === 'bigint' ? JSBI.BigInt(value.toString(10)) : value;\r\n}\r\n\r\nexport function isEven(value: JSBI): boolean {\r\n  return JSBI.equal(JSBI.remainder(value, TWO), ZERO);\r\n}\r\n\r\nexport function abs(x: JSBI): JSBI {\r\n  if (JSBI.lessThan(x, ZERO)) return JSBI.unaryMinus(x);\r\n  return x;\r\n}\r\n\r\nexport function compare(x: JSBI, y: JSBI): -1 | 0 | 1 {\r\n  return JSBI.lessThan(x, y) ? -1 : JSBI.greaterThan(x, y) ? 1 : 0;\r\n}\r\n\r\nexport function divmod(x: JSBI, y: JSBI): { quotient: JSBI; remainder: JSBI } {\r\n  const quotient = JSBI.divide(x, y);\r\n  const remainder = JSBI.remainder(x, y);\r\n  return { quotient, remainder };\r\n}\r\n","import type JSBI from 'jsbi';\r\nimport type { Temporal } from '..';\r\nimport type {\r\n  BuiltinCalendarId,\r\n  AnySlottedType,\r\n  FormatterOrAmender,\r\n  ISODate,\r\n  ISODateTime,\r\n  TimeRecord\r\n} from './internaltypes';\r\nimport type { DateTimeFormatImpl } from './intl';\r\n\r\n// Instant\r\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\r\n\r\n// DateTime, Date, Time, YearMonth, MonthDay\r\nexport const ISO_DATE = 'slot-iso-date';\r\nexport const ISO_DATE_TIME = 'slot-iso-date-time';\r\nexport const TIME = 'slot-time';\r\nexport const CALENDAR = 'slot-calendar';\r\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\r\nexport const DATE_BRAND = 'slot-date-brand';\r\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\r\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\r\n\r\n// ZonedDateTime\r\nexport const TIME_ZONE = 'slot-time-zone';\r\n\r\n// Duration\r\nexport const YEARS = 'slot-years';\r\nexport const MONTHS = 'slot-months';\r\nexport const WEEKS = 'slot-weeks';\r\nexport const DAYS = 'slot-days';\r\nexport const HOURS = 'slot-hours';\r\nexport const MINUTES = 'slot-minutes';\r\nexport const SECONDS = 'slot-seconds';\r\nexport const MILLISECONDS = 'slot-milliseconds';\r\nexport const MICROSECONDS = 'slot-microseconds';\r\nexport const NANOSECONDS = 'slot-nanoseconds';\r\n\r\n// DateTimeFormatImpl\r\nexport const DATE = 'date';\r\nexport const YM = 'ym';\r\nexport const MD = 'md';\r\nexport const TIME_FMT = 'time';\r\nexport const DATETIME = 'datetime';\r\nexport const INST = 'instant';\r\nexport const ORIGINAL = 'original';\r\nexport const TZ_CANONICAL = 'timezone-canonical';\r\nexport const TZ_ORIGINAL = 'timezone-original';\r\nexport const CAL_ID = 'calendar-id';\r\nexport const LOCALE = 'locale';\r\nexport const OPTIONS = 'options';\r\n\r\ninterface SlotInfo<ValueType, UsedByType extends AnySlottedType> {\r\n  value: ValueType;\r\n  usedBy: UsedByType;\r\n}\r\n\r\ninterface SlotInfoRecord {\r\n  [k: string]: SlotInfo<unknown, AnySlottedType>;\r\n}\r\n\r\ninterface Slots extends SlotInfoRecord {\r\n  // Instant\r\n  [EPOCHNANOSECONDS]: SlotInfo<JSBI, Temporal.Instant | Temporal.ZonedDateTime>; // number? JSBI?\r\n\r\n  // DateTime, Date, Time, YearMonth, MonthDay\r\n  [ISO_DATE]: SlotInfo<ISODate, Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth>;\r\n  [ISO_DATE_TIME]: SlotInfo<ISODateTime, Temporal.PlainDateTime>;\r\n  [TIME]: SlotInfo<TimeRecord, Temporal.PlainTime>;\r\n  [CALENDAR]: SlotInfo<BuiltinCalendarId, TypesWithCalendarUnits>;\r\n\r\n  // Date, YearMonth, MonthDay common slots\r\n  [DATE_BRAND]: SlotInfo<true, Temporal.PlainDate>;\r\n  [YEAR_MONTH_BRAND]: SlotInfo<true, Temporal.PlainYearMonth>;\r\n  [MONTH_DAY_BRAND]: SlotInfo<true, Temporal.PlainMonthDay>;\r\n\r\n  // ZonedDateTime\r\n  [TIME_ZONE]: SlotInfo<string, Temporal.ZonedDateTime>;\r\n\r\n  // Duration\r\n  [YEARS]: SlotInfo<number, Temporal.Duration>;\r\n  [MONTHS]: SlotInfo<number, Temporal.Duration>;\r\n  [WEEKS]: SlotInfo<number, Temporal.Duration>;\r\n  [DAYS]: SlotInfo<number, Temporal.Duration>;\r\n  [HOURS]: SlotInfo<number, Temporal.Duration>;\r\n  [MINUTES]: SlotInfo<number, Temporal.Duration>;\r\n  [SECONDS]: SlotInfo<number, Temporal.Duration>;\r\n  [MILLISECONDS]: SlotInfo<number, Temporal.Duration>;\r\n  [MICROSECONDS]: SlotInfo<number, Temporal.Duration>;\r\n  [NANOSECONDS]: SlotInfo<number, Temporal.Duration>;\r\n\r\n  // DateTimeFormatImpl\r\n  [DATE]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [YM]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [MD]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [TIME_FMT]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [DATETIME]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [INST]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [ORIGINAL]: SlotInfo<globalThis.Intl.DateTimeFormat, DateTimeFormatImpl>;\r\n  [TZ_CANONICAL]: SlotInfo<string, DateTimeFormatImpl>;\r\n  [TZ_ORIGINAL]: SlotInfo<string, DateTimeFormatImpl>;\r\n  [CAL_ID]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['calendar'], DateTimeFormatImpl>;\r\n  [LOCALE]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['locale'], DateTimeFormatImpl>;\r\n  [OPTIONS]: SlotInfo<Intl.DateTimeFormatOptions, DateTimeFormatImpl>;\r\n}\r\n\r\ntype TypesWithCalendarUnits =\r\n  | Temporal.PlainDateTime\r\n  | Temporal.PlainDate\r\n  | Temporal.PlainYearMonth\r\n  | Temporal.PlainMonthDay\r\n  | Temporal.ZonedDateTime;\r\n\r\ninterface SlotsToTypes {\r\n  // Instant\r\n  [EPOCHNANOSECONDS]: Temporal.Instant;\r\n\r\n  // DateTime, Date, Time, YearMonth, MonthDay\r\n  [ISO_DATE]: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay;\r\n  [ISO_DATE_TIME]: Temporal.PlainDateTime;\r\n  [TIME]: Temporal.PlainTime;\r\n  [CALENDAR]: TypesWithCalendarUnits;\r\n\r\n  // Date, YearMonth, MonthDay common slots\r\n  [DATE_BRAND]: Temporal.PlainDate;\r\n  [YEAR_MONTH_BRAND]: Temporal.PlainYearMonth;\r\n  [MONTH_DAY_BRAND]: Temporal.PlainMonthDay;\r\n\r\n  // ZonedDateTime\r\n  [TIME_ZONE]: Temporal.ZonedDateTime;\r\n\r\n  // Duration\r\n  [YEARS]: Temporal.Duration;\r\n  [MONTHS]: Temporal.Duration;\r\n  [WEEKS]: Temporal.Duration;\r\n  [DAYS]: Temporal.Duration;\r\n  [HOURS]: Temporal.Duration;\r\n  [MINUTES]: Temporal.Duration;\r\n  [SECONDS]: Temporal.Duration;\r\n  [MILLISECONDS]: Temporal.Duration;\r\n  [MICROSECONDS]: Temporal.Duration;\r\n  [NANOSECONDS]: Temporal.Duration;\r\n\r\n  // DateTimeFormatImpl\r\n  [DATE]: DateTimeFormatImpl;\r\n  [YM]: DateTimeFormatImpl;\r\n  [MD]: DateTimeFormatImpl;\r\n  [TIME_FMT]: DateTimeFormatImpl;\r\n  [DATETIME]: DateTimeFormatImpl;\r\n  [INST]: DateTimeFormatImpl;\r\n  [ORIGINAL]: DateTimeFormatImpl;\r\n  [TZ_CANONICAL]: DateTimeFormatImpl;\r\n  [TZ_ORIGINAL]: DateTimeFormatImpl;\r\n  [CAL_ID]: DateTimeFormatImpl;\r\n  [LOCALE]: DateTimeFormatImpl;\r\n  [OPTIONS]: DateTimeFormatImpl;\r\n}\r\n\r\ntype SlotKey = keyof SlotsToTypes;\r\n\r\nconst globalSlots = new WeakMap<Slots[keyof Slots]['usedBy'], Record<keyof Slots, Slots[keyof Slots]['value']>>();\r\n\r\nfunction _GetSlots(container: Slots[keyof Slots]['usedBy']) {\r\n  return globalSlots.get(container);\r\n}\r\n\r\nconst GetSlotsSymbol = Symbol.for('@@Temporal__GetSlots');\r\n\r\n// expose GetSlots to avoid dual package hazards\r\n(globalThis as any)[GetSlotsSymbol] ||= _GetSlots;\r\n\r\nconst GetSlots = (globalThis as any)[GetSlotsSymbol] as typeof _GetSlots;\r\n\r\nfunction _CreateSlots(container: Slots[keyof Slots]['usedBy']): void {\r\n  globalSlots.set(container, Object.create(null));\r\n}\r\n\r\nconst CreateSlotsSymbol = Symbol.for('@@Temporal__CreateSlots');\r\n\r\n// expose CreateSlots to avoid dual package hazards\r\n(globalThis as any)[CreateSlotsSymbol] ||= _CreateSlots;\r\n\r\nexport const CreateSlots = (globalThis as any)[CreateSlotsSymbol] as typeof _CreateSlots;\r\n\r\n// TODO: is there a better way than 9 overloads to make HasSlot into a type\r\n// guard that takes a variable number of parameters?\r\nexport function HasSlot<ID1 extends SlotKey>(container: unknown, id1: ID1): container is Slots[ID1]['usedBy'];\r\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2\r\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'];\r\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3\r\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'] | Slots[ID3]['usedBy'];\r\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey, ID4 extends SlotKey>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4\r\n): container is Slots[ID1 | ID2 | ID3 | ID4]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey,\r\n  ID7 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6,\r\n  id7: ID7\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey,\r\n  ID7 extends SlotKey,\r\n  ID8 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6,\r\n  id7: ID7,\r\n  id8: ID8\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey,\r\n  ID7 extends SlotKey,\r\n  ID8 extends SlotKey,\r\n  ID9 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6,\r\n  id7: ID7,\r\n  id8: ID8,\r\n  id9: ID9\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8 | ID9]['usedBy'];\r\nexport function HasSlot(container: unknown, ...ids: (keyof Slots)[]): boolean {\r\n  if (!container || 'object' !== typeof container) return false;\r\n  const myslots = GetSlots(container as AnySlottedType);\r\n  return !!myslots && ids.every((id) => id in myslots);\r\n}\r\nexport function GetSlot<KeyT extends keyof Slots>(\r\n  container: Slots[typeof id]['usedBy'],\r\n  id: KeyT\r\n): Slots[KeyT]['value'] {\r\n  const value = GetSlots(container)?.[id];\r\n  if (value === undefined) throw new TypeError(`Missing internal slot ${id}`);\r\n  return value;\r\n}\r\nexport function SetSlot<KeyT extends SlotKey>(\r\n  container: Slots[KeyT]['usedBy'],\r\n  id: KeyT,\r\n  value: Slots[KeyT]['value']\r\n): void {\r\n  const slots = GetSlots(container);\r\n\r\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\r\n\r\n  const existingSlot = slots[id];\r\n\r\n  if (existingSlot) throw new TypeError(`${id} already has set`);\r\n\r\n  slots[id] = value;\r\n}\r\n\r\nexport function ResetSlot<KeyT extends SlotKey>(\r\n  container: DateTimeFormatImpl,\r\n  id: KeyT,\r\n  value: Slots[KeyT]['value']\r\n): void {\r\n  const slots = GetSlots(container);\r\n\r\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\r\n\r\n  const existingSlot = slots[id];\r\n\r\n  if (existingSlot === undefined) throw new TypeError(`tried to reset ${id} which was not set`);\r\n\r\n  slots[id] = value;\r\n}\r\n","import type JSBI from 'jsbi';\r\nimport type { Temporal } from '..';\r\nimport type { CalendarImpl } from './calendar';\r\nimport type { BuiltinCalendarId } from './internaltypes';\r\nimport type { DateTimeFormatImpl } from './intl';\r\n\r\nimport { DEBUG } from './debug';\r\nimport { GetSlot, ORIGINAL } from './slots';\r\n\r\ntype OmitConstructor<T> = { [P in keyof T as T[P] extends new (...args: any[]) => any ? P : never]: T[P] };\r\n\r\ntype TemporalIntrinsics = {\r\n  ['Intl.DateTimeFormat']: typeof globalThis.Intl.DateTimeFormat;\r\n  ['Temporal.Duration']: typeof Temporal.Duration;\r\n  ['Temporal.Instant']: OmitConstructor<Temporal.Instant> &\r\n    (new (epochNanoseconds: JSBI) => Temporal.Instant) & { prototype: typeof Temporal.Instant.prototype };\r\n  ['Temporal.PlainDate']: typeof Temporal.PlainDate;\r\n  ['Temporal.PlainDateTime']: typeof Temporal.PlainDateTime;\r\n  ['Temporal.PlainMonthDay']: typeof Temporal.PlainMonthDay;\r\n  ['Temporal.PlainTime']: typeof Temporal.PlainTime;\r\n  ['Temporal.PlainYearMonth']: typeof Temporal.PlainYearMonth;\r\n  ['Temporal.ZonedDateTime']: OmitConstructor<Temporal.ZonedDateTime> &\r\n    (new (epochNanoseconds: JSBI, timeZone: string, calendar?: string) => Temporal.ZonedDateTime) & {\r\n      prototype: typeof Temporal.ZonedDateTime.prototype;\r\n      from: typeof Temporal.ZonedDateTime.from;\r\n      compare: typeof Temporal.ZonedDateTime.compare;\r\n    };\r\n};\r\ntype TemporalIntrinsicRegistrations = {\r\n  [key in keyof TemporalIntrinsics]: TemporalIntrinsics[key];\r\n};\r\ntype TemporalIntrinsicPrototypeRegistrations = {\r\n  [key in keyof TemporalIntrinsics as `${key}.prototype`]: TemporalIntrinsics[key]['prototype'];\r\n};\r\ntype TemporalIntrinsicRegisteredKeys = {\r\n  [key in keyof TemporalIntrinsicRegistrations as `%${key}%`]: TemporalIntrinsicRegistrations[key];\r\n};\r\ntype TemporalIntrinsicPrototypeRegisteredKeys = {\r\n  [key in keyof TemporalIntrinsicPrototypeRegistrations as `%${key}%`]: TemporalIntrinsicPrototypeRegistrations[key];\r\n};\r\n\r\ntype OtherIntrinsics = {\r\n  calendarImpl: (id: BuiltinCalendarId) => CalendarImpl;\r\n};\r\ntype OtherIntrinsicKeys = { [key in keyof OtherIntrinsics as `%${key}%`]: OtherIntrinsics[key] };\r\n\r\nconst INTRINSICS = {} as TemporalIntrinsicRegisteredKeys &\r\n  TemporalIntrinsicPrototypeRegisteredKeys &\r\n  OtherIntrinsicKeys;\r\n\r\ntype StylizeOption = (value: unknown, type: 'number' | 'special') => string;\r\n\r\ntype customFormatFunction<T> = (\r\n  this: T & { _repr_: string }, // _repr_ is present if DEBUG\r\n  depth: number,\r\n  options: { stylize: StylizeOption },\r\n  inspect: (object: T, options?: { depth: number; stylize: StylizeOption }) => string\r\n) => string;\r\nconst customUtilInspectFormatters: Partial<{\r\n  [key in keyof TemporalIntrinsicRegistrations]: customFormatFunction<\r\n    InstanceType<TemporalIntrinsicRegistrations[key]>\r\n  >;\r\n}> = {\r\n  ['Intl.DateTimeFormat'](depth, options, inspect) {\r\n    return inspect(GetSlot(this as DateTimeFormatImpl, ORIGINAL), { depth, ...options });\r\n  },\r\n  ['Temporal.Duration'](depth, options) {\r\n    const descr = options.stylize(this._repr_, 'special');\r\n    if (depth < 1) return descr;\r\n    const entries: string[] = [];\r\n    const props = [\r\n      'years',\r\n      'months',\r\n      'weeks',\r\n      'days',\r\n      'hours',\r\n      'minutes',\r\n      'seconds',\r\n      'milliseconds',\r\n      'microseconds',\r\n      'nanoseconds'\r\n    ] as const;\r\n    for (let i = 0; i < props.length; i++) {\r\n      const prop = props[i];\r\n      if (this[prop] !== 0) {\r\n        entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\r\n      }\r\n    }\r\n    return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\r\n  }\r\n};\r\n\r\ntype InspectFormatterOptions = { stylize: (str: string, styleType: string) => string };\r\nfunction defaultUtilInspectFormatter(this: any, depth: number, options: InspectFormatterOptions) {\r\n  return options.stylize(this._repr_, 'special');\r\n}\r\n\r\nexport function MakeIntrinsicClass(\r\n  Class: TemporalIntrinsicRegistrations[typeof name],\r\n  name: keyof TemporalIntrinsicRegistrations\r\n) {\r\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\r\n    value: name,\r\n    writable: false,\r\n    enumerable: false,\r\n    configurable: true\r\n  });\r\n  if (DEBUG) {\r\n    Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\r\n      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: true\r\n    });\r\n  }\r\n  const staticNames = Object.getOwnPropertyNames(Class);\r\n  for (let i = 0; i < staticNames.length; i++) {\r\n    const prop = staticNames[i];\r\n    // we know that `prop` is present, so the descriptor is never undefined\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    const desc = Object.getOwnPropertyDescriptor(Class, prop)!;\r\n    if (!desc.configurable || !desc.enumerable) continue;\r\n    desc.enumerable = false;\r\n    Object.defineProperty(Class, prop, desc);\r\n  }\r\n  const protoNames = Object.getOwnPropertyNames(Class.prototype);\r\n  for (let i = 0; i < protoNames.length; i++) {\r\n    const prop = protoNames[i];\r\n    // we know that `prop` is present, so the descriptor is never undefined\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop)!;\r\n    if (!desc.configurable || !desc.enumerable) continue;\r\n    desc.enumerable = false;\r\n    Object.defineProperty(Class.prototype, prop, desc);\r\n  }\r\n\r\n  DefineIntrinsic(name, Class);\r\n  DefineIntrinsic(`${name}.prototype`, Class.prototype);\r\n}\r\n\r\ntype IntrinsicDefinitionKeys =\r\n  | keyof TemporalIntrinsicRegistrations\r\n  | keyof TemporalIntrinsicPrototypeRegistrations\r\n  | keyof OtherIntrinsics;\r\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicRegistrations>(\r\n  name: KeyT,\r\n  value: TemporalIntrinsicRegistrations[KeyT]\r\n): void;\r\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicPrototypeRegistrations>(\r\n  name: KeyT,\r\n  value: TemporalIntrinsicPrototypeRegistrations[KeyT]\r\n): void;\r\nexport function DefineIntrinsic<KeyT extends keyof OtherIntrinsics>(name: KeyT, value: OtherIntrinsics[KeyT]): void;\r\nexport function DefineIntrinsic<KeyT>(name: KeyT, value: never): void;\r\nexport function DefineIntrinsic<KeyT extends IntrinsicDefinitionKeys>(name: KeyT, value: unknown): void {\r\n  const key: `%${IntrinsicDefinitionKeys}%` = `%${name}%`;\r\n  if (INTRINSICS[key] !== undefined) throw new Error(`intrinsic ${name} already exists`);\r\n  INTRINSICS[key] = value;\r\n}\r\nexport function GetIntrinsic<KeyT extends keyof typeof INTRINSICS>(intrinsic: KeyT): (typeof INTRINSICS)[KeyT] {\r\n  return INTRINSICS[intrinsic];\r\n}\r\n","import type JSBI from 'jsbi';\r\nimport type { Temporal } from '..';\r\n\r\n// Computes trunc(x / 10**p) and x % 10**p, returning { div, mod }, with\r\n// precision loss only once in the quotient, by string manipulation. If the\r\n// quotient and remainder are safe integers, then they are exact. x must be an\r\n// integer. p must be a non-negative integer. Both div and mod have the sign of\r\n// x.\r\nexport function TruncatingDivModByPowerOf10(xParam: number, p: number) {\r\n  let x = xParam;\r\n  if (x === 0) return { div: x, mod: x }; // preserves signed zero\r\n\r\n  const sign = Math.sign(x);\r\n  x = Math.abs(x);\r\n\r\n  const xDigits = Math.trunc(1 + Math.log10(x));\r\n  if (p >= xDigits) return { div: sign * 0, mod: sign * x };\r\n  if (p === 0) return { div: sign * x, mod: sign * 0 };\r\n\r\n  // would perform nearest rounding if x was not an integer:\r\n  const xStr = x.toPrecision(xDigits);\r\n  const div = sign * Number.parseInt(xStr.slice(0, xDigits - p), 10);\r\n  const mod = sign * Number.parseInt(xStr.slice(xDigits - p), 10);\r\n\r\n  return { div, mod };\r\n}\r\n\r\n// Computes x * 10**p + z with precision loss only at the end, by string\r\n// manipulation. If the result is a safe integer, then it is exact. x must be\r\n// an integer. p must be a non-negative integer. z must have the same sign as\r\n// x and be less than 10**p.\r\nexport function FMAPowerOf10(xParam: number, p: number, zParam: number) {\r\n  let x = xParam;\r\n  let z = zParam;\r\n  if (x === 0) return z;\r\n\r\n  const sign = Math.sign(x) || Math.sign(z);\r\n  x = Math.abs(x);\r\n  z = Math.abs(z);\r\n\r\n  const xStr = x.toPrecision(Math.trunc(1 + Math.log10(x)));\r\n\r\n  if (z === 0) return sign * Number.parseInt(xStr + '0'.repeat(p), 10);\r\n\r\n  const zStr = z.toPrecision(Math.trunc(1 + Math.log10(z)));\r\n\r\n  const resStr = xStr + zStr.padStart(p, '0');\r\n  return sign * Number.parseInt(resStr, 10);\r\n}\r\n\r\ntype UnsignedRoundingMode = 'half-even' | 'half-infinity' | 'half-zero' | 'infinity' | 'zero';\r\n\r\nexport function GetUnsignedRoundingMode(\r\n  mode: Temporal.RoundingMode,\r\n  sign: 'positive' | 'negative'\r\n): UnsignedRoundingMode {\r\n  const isNegative = sign === 'negative';\r\n  switch (mode) {\r\n    case 'ceil':\r\n      return isNegative ? 'zero' : 'infinity';\r\n    case 'floor':\r\n      return isNegative ? 'infinity' : 'zero';\r\n    case 'expand':\r\n      return 'infinity';\r\n    case 'trunc':\r\n      return 'zero';\r\n    case 'halfCeil':\r\n      return isNegative ? 'half-zero' : 'half-infinity';\r\n    case 'halfFloor':\r\n      return isNegative ? 'half-infinity' : 'half-zero';\r\n    case 'halfExpand':\r\n      return 'half-infinity';\r\n    case 'halfTrunc':\r\n      return 'half-zero';\r\n    case 'halfEven':\r\n      return 'half-even';\r\n  }\r\n}\r\n\r\n// Omits first step from spec algorithm so that it can be used both for\r\n// RoundNumberToIncrement and RoundTimeDurationToIncrement\r\nexport function ApplyUnsignedRoundingMode<T extends number | JSBI>(\r\n  r1: T,\r\n  r2: T,\r\n  cmp: -1 | 0 | 1,\r\n  evenCardinality: boolean,\r\n  unsignedRoundingMode: UnsignedRoundingMode\r\n) {\r\n  if (unsignedRoundingMode === 'zero') return r1;\r\n  if (unsignedRoundingMode === 'infinity') return r2;\r\n  if (cmp < 0) return r1;\r\n  if (cmp > 0) return r2;\r\n  if (unsignedRoundingMode === 'half-zero') return r1;\r\n  if (unsignedRoundingMode === 'half-infinity') return r2;\r\n  return evenCardinality ? r1 : r2;\r\n}\r\n","import JSBI from 'jsbi';\r\n\r\nimport { assert } from './assert';\r\nimport {\r\n  abs,\r\n  BILLION,\r\n  compare,\r\n  DAY_NANOS_JSBI,\r\n  divmod,\r\n  ensureJSBI,\r\n  HOUR_NANOS,\r\n  isEven,\r\n  MILLION,\r\n  MINUTE_NANOS_JSBI,\r\n  ONE,\r\n  TEN,\r\n  THOUSAND,\r\n  TWO,\r\n  ZERO\r\n} from './bigintmath';\r\nimport { ApplyUnsignedRoundingMode, GetUnsignedRoundingMode } from './math';\r\nimport type { Temporal } from '..';\r\n\r\nexport class TimeDuration {\r\n  static MAX = JSBI.BigInt('9007199254740991999999999');\r\n  static ZERO = new TimeDuration(ZERO);\r\n\r\n  totalNs: JSBI;\r\n  sec: number;\r\n  subsec: number;\r\n\r\n  constructor(totalNs: bigint | JSBI) {\r\n    assert(typeof totalNs !== 'number', 'big integer required');\r\n    this.totalNs = ensureJSBI(totalNs);\r\n    assert(JSBI.lessThanOrEqual(abs(this.totalNs), TimeDuration.MAX), 'integer too big');\r\n\r\n    this.sec = JSBI.toNumber(JSBI.divide(this.totalNs, BILLION));\r\n    this.subsec = JSBI.toNumber(JSBI.remainder(this.totalNs, BILLION));\r\n    assert(Number.isSafeInteger(this.sec), 'seconds too big');\r\n    assert(Math.abs(this.subsec) <= 999_999_999, 'subseconds too big');\r\n  }\r\n\r\n  static validateNew(totalNs: JSBI, operation: string) {\r\n    if (JSBI.greaterThan(abs(totalNs), TimeDuration.MAX)) {\r\n      throw new RangeError(`${operation} of duration time units cannot exceed ${TimeDuration.MAX} s`);\r\n    }\r\n    return new TimeDuration(totalNs);\r\n  }\r\n\r\n  static fromEpochNsDiff(epochNs1: JSBI | bigint, epochNs2: JSBI | bigint) {\r\n    const diff = JSBI.subtract(ensureJSBI(epochNs1), ensureJSBI(epochNs2));\r\n    // No extra validate step. Should instead fail assertion if too big\r\n    return new TimeDuration(diff);\r\n  }\r\n\r\n  static fromComponents(h: number, min: number, s: number, ms: number, µs: number, ns: number) {\r\n    const totalNs = JSBI.add(\r\n      JSBI.add(\r\n        JSBI.add(\r\n          JSBI.add(\r\n            JSBI.add(JSBI.BigInt(ns), JSBI.multiply(JSBI.BigInt(µs), THOUSAND)),\r\n            JSBI.multiply(JSBI.BigInt(ms), MILLION)\r\n          ),\r\n          JSBI.multiply(JSBI.BigInt(s), BILLION)\r\n        ),\r\n        JSBI.multiply(JSBI.BigInt(min), MINUTE_NANOS_JSBI)\r\n      ),\r\n      JSBI.multiply(JSBI.BigInt(h), HOUR_NANOS)\r\n    );\r\n    return TimeDuration.validateNew(totalNs, 'total');\r\n  }\r\n\r\n  abs() {\r\n    return new TimeDuration(abs(this.totalNs));\r\n  }\r\n\r\n  add(other: TimeDuration) {\r\n    return TimeDuration.validateNew(JSBI.add(this.totalNs, other.totalNs), 'sum');\r\n  }\r\n\r\n  add24HourDays(days: number) {\r\n    assert(Number.isInteger(days), 'days must be an integer');\r\n    return TimeDuration.validateNew(JSBI.add(this.totalNs, JSBI.multiply(JSBI.BigInt(days), DAY_NANOS_JSBI)), 'sum');\r\n  }\r\n\r\n  addToEpochNs(epochNs: JSBI | bigint) {\r\n    return JSBI.add(ensureJSBI(epochNs), this.totalNs);\r\n  }\r\n\r\n  cmp(other: TimeDuration) {\r\n    return compare(this.totalNs, other.totalNs);\r\n  }\r\n\r\n  divmod(n: number) {\r\n    assert(n !== 0, 'division by zero');\r\n    const { quotient, remainder } = divmod(this.totalNs, JSBI.BigInt(n));\r\n    const q = JSBI.toNumber(quotient);\r\n    const r = new TimeDuration(remainder);\r\n    return { quotient: q, remainder: r };\r\n  }\r\n\r\n  fdiv(nParam: JSBI | bigint) {\r\n    const n = ensureJSBI(nParam);\r\n    assert(!JSBI.equal(n, ZERO), 'division by zero');\r\n    const nBigInt = JSBI.BigInt(n);\r\n    let { quotient, remainder } = divmod(this.totalNs, nBigInt);\r\n\r\n    // Perform long division to calculate the fractional part of the quotient\r\n    // remainder / n with more accuracy than 64-bit floating point division\r\n    const precision = 50;\r\n    const decimalDigits: number[] = [];\r\n    let digit;\r\n    const sign = (JSBI.lessThan(this.totalNs, ZERO) ? -1 : 1) * Math.sign(JSBI.toNumber(n));\r\n    while (!JSBI.equal(remainder, ZERO) && decimalDigits.length < precision) {\r\n      remainder = JSBI.multiply(remainder, TEN);\r\n      ({ quotient: digit, remainder } = divmod(remainder, nBigInt));\r\n      decimalDigits.push(Math.abs(JSBI.toNumber(digit)));\r\n    }\r\n    return sign * Number(abs(quotient).toString() + '.' + decimalDigits.join(''));\r\n  }\r\n\r\n  isZero() {\r\n    return JSBI.equal(this.totalNs, ZERO);\r\n  }\r\n\r\n  round(incrementParam: JSBI | bigint, mode: Temporal.RoundingMode) {\r\n    const increment = ensureJSBI(incrementParam);\r\n    if (JSBI.equal(increment, ONE)) return this;\r\n    const { quotient, remainder } = divmod(this.totalNs, increment);\r\n    const sign = JSBI.lessThan(this.totalNs, ZERO) ? 'negative' : 'positive';\r\n    const r1 = JSBI.multiply(abs(quotient), increment);\r\n    const r2 = JSBI.add(r1, increment);\r\n    const cmp = compare(abs(JSBI.multiply(remainder, TWO)), increment);\r\n    const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\r\n    const rounded = JSBI.equal(remainder, ZERO)\r\n      ? r1\r\n      : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(quotient), unsignedRoundingMode);\r\n    const result = sign === 'positive' ? rounded : JSBI.unaryMinus(rounded);\r\n    return TimeDuration.validateNew(result, 'rounding');\r\n  }\r\n\r\n  sign() {\r\n    return this.cmp(new TimeDuration(ZERO));\r\n  }\r\n\r\n  subtract(other: TimeDuration) {\r\n    return TimeDuration.validateNew(JSBI.subtract(this.totalNs, other.totalNs), 'difference');\r\n  }\r\n}\r\n","const offsetIdentifierNoCapture = /(?:[+-](?:[01][0-9]|2[0-3])(?::?[0-5][0-9])?)/;\r\nconst tzComponent = /[A-Za-z._][A-Za-z._0-9+-]*/;\r\nexport const timeZoneID = new RegExp(\r\n  `(?:${offsetIdentifierNoCapture.source}|(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*)`\r\n);\r\n\r\nconst yearpart = /(?:[+-]\\d{6}|\\d{4})/;\r\nconst monthpart = /(?:0[1-9]|1[0-2])/;\r\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\r\nconst datesplit = new RegExp(\r\n  `(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`\r\n);\r\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\r\nexport const offsetWithParts = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\r\nexport const offset = /((?:[+-])(?:[01][0-9]|2[0-3])(?::?(?:[0-5][0-9])(?::?(?:[0-5][0-9])(?:[.,](?:\\d{1,9}))?)?)?)/;\r\nconst offsetpart = new RegExp(`([zZ])|${offset.source}?`);\r\nexport const offsetIdentifier = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])?)?/;\r\nexport const annotation = /\\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\\]/g;\r\n\r\nexport const zoneddatetime = new RegExp(\r\n  [\r\n    `^${datesplit.source}`,\r\n    `(?:(?:[tT]|\\\\s+)${timesplit.source}(?:${offsetpart.source})?)?`,\r\n    `(?:\\\\[!?(${timeZoneID.source})\\\\])?`,\r\n    `((?:${annotation.source})*)$`\r\n  ].join('')\r\n);\r\n\r\nexport const time = new RegExp(\r\n  [\r\n    `^[tT]?${timesplit.source}`,\r\n    `(?:${offsetpart.source})?`,\r\n    `(?:\\\\[!?${timeZoneID.source}\\\\])?`,\r\n    `((?:${annotation.source})*)$`\r\n  ].join('')\r\n);\r\n\r\n// The short forms of YearMonth and MonthDay are only for the ISO calendar, but\r\n// annotations are still allowed, and will throw if the calendar annotation is\r\n// not ISO.\r\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\r\n// with the reference fields.\r\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\r\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\r\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\r\n// UTC offsets are not allowed, because they are not allowed with any date-only\r\n// format; also, YYYY-MM-UU is ambiguous with YYYY-MM-DD\r\nexport const yearmonth = new RegExp(\r\n  `^(${yearpart.source})-?(${monthpart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\r\n);\r\nexport const monthday = new RegExp(\r\n  `^(?:--)?(${monthpart.source})-?(${daypart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\r\n);\r\n\r\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\r\n\r\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\r\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\r\nexport const duration = new RegExp(`^([+-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\r\n","import { DEBUG, ENABLE_ASSERTS } from './debug';\r\nimport JSBI from 'jsbi';\r\n\r\nimport type { Temporal } from '..';\r\nimport { assert, assertNotReached } from './assert';\r\nimport { abs, compare, DAY_NANOS_JSBI, divmod, ensureJSBI, isEven, MILLION, ONE, TWO, ZERO } from './bigintmath';\r\nimport type { CalendarImpl } from './calendar';\r\nimport type {\r\n  AnyTemporalLikeType,\r\n  UnitSmallerThanOrEqualTo,\r\n  InstantParams,\r\n  PlainMonthDayParams,\r\n  ZonedDateTimeParams,\r\n  PlainDateParams,\r\n  PlainTimeParams,\r\n  DurationParams,\r\n  PlainDateTimeParams,\r\n  PlainYearMonthParams,\r\n  BuiltinCalendarId,\r\n  Keys,\r\n  AnyTemporalKey,\r\n  FieldKey,\r\n  InternalDuration,\r\n  ISODateTime,\r\n  ISODate,\r\n  TimeRecord,\r\n  ISODateToFieldsType,\r\n  DateDuration,\r\n  CalendarFieldsRecord,\r\n  MonthDayFromFieldsObject,\r\n  Overflow,\r\n  Resolve,\r\n  AnySlottedType\r\n} from './internaltypes';\r\nimport { GetIntrinsic } from './intrinsicclass';\r\nimport { ApplyUnsignedRoundingMode, FMAPowerOf10, GetUnsignedRoundingMode, TruncatingDivModByPowerOf10 } from './math';\r\nimport { TimeDuration } from './timeduration';\r\nimport {\r\n  CreateSlots,\r\n  GetSlot,\r\n  HasSlot,\r\n  SetSlot,\r\n  EPOCHNANOSECONDS,\r\n  ISO_DATE,\r\n  ISO_DATE_TIME,\r\n  TIME,\r\n  DATE_BRAND,\r\n  YEAR_MONTH_BRAND,\r\n  MONTH_DAY_BRAND,\r\n  TIME_ZONE,\r\n  CALENDAR,\r\n  YEARS,\r\n  MONTHS,\r\n  WEEKS,\r\n  DAYS,\r\n  HOURS,\r\n  MINUTES,\r\n  SECONDS,\r\n  MILLISECONDS,\r\n  MICROSECONDS,\r\n  NANOSECONDS\r\n} from './slots';\r\n\r\nconst DAY_MS = 86400_000;\r\nexport const DAY_NANOS = DAY_MS * 1e6;\r\nconst MINUTE_NANOS = 60e9;\r\n// Instant range is 100 million days (inclusive) before or after epoch.\r\nconst MS_MAX = DAY_MS * 1e8;\r\nconst NS_MAX = epochMsToNs(MS_MAX);\r\nconst NS_MIN = JSBI.unaryMinus(NS_MAX);\r\n// PlainDateTime range is 24 hours wider (exclusive) than the Instant range on\r\n// both ends, to allow for valid Instant=>PlainDateTime conversion for all\r\n// built-in time zones (whose offsets must have a magnitude less than 24 hours).\r\nconst DATETIME_NS_MIN = JSBI.add(JSBI.subtract(NS_MIN, DAY_NANOS_JSBI), ONE);\r\nconst DATETIME_NS_MAX = JSBI.subtract(JSBI.add(NS_MAX, DAY_NANOS_JSBI), ONE);\r\n// The pattern of leap years in the ISO 8601 calendar repeats every 400 years.\r\n// The constant below is the number of nanoseconds in 400 years. It is used to\r\n// avoid overflows when dealing with values at the edge legacy Date's range.\r\nconst MS_IN_400_YEAR_CYCLE = (400 * 365 + 97) * DAY_MS;\r\nconst YEAR_MIN = -271821;\r\nconst YEAR_MAX = 275760;\r\nconst BEFORE_FIRST_DST = Date.UTC(1847, 0, 1); // 1847-01-01T00:00:00Z\r\n\r\nconst BUILTIN_CALENDAR_IDS = [\r\n  'iso8601',\r\n  'hebrew',\r\n  'islamic',\r\n  'islamic-umalqura',\r\n  'islamic-tbla',\r\n  'islamic-civil',\r\n  'islamic-rgsa',\r\n  'islamicc',\r\n  'persian',\r\n  'ethiopic',\r\n  'ethioaa',\r\n  'ethiopic-amete-alem',\r\n  'coptic',\r\n  'chinese',\r\n  'dangi',\r\n  'roc',\r\n  'indian',\r\n  'buddhist',\r\n  'japanese',\r\n  'gregory'\r\n];\r\n\r\nconst ICU_LEGACY_TIME_ZONE_IDS = new Set([\r\n  'ACT',\r\n  'AET',\r\n  'AGT',\r\n  'ART',\r\n  'AST',\r\n  'BET',\r\n  'BST',\r\n  'CAT',\r\n  'CNT',\r\n  'CST',\r\n  'CTT',\r\n  'EAT',\r\n  'ECT',\r\n  'IET',\r\n  'IST',\r\n  'JST',\r\n  'MIT',\r\n  'NET',\r\n  'NST',\r\n  'PLT',\r\n  'PNT',\r\n  'PRT',\r\n  'PST',\r\n  'SST',\r\n  'VST'\r\n]);\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */\r\n/**\r\n * uncheckedAssertNarrowedType forces TypeScript to change the type of the argument to the one given in\r\n * the type parameter. This should only be used to help TS understand when variables change types,\r\n * but TS can't or won't infer this automatically. They should be used sparingly, because\r\n * if used incorrectly can lead to difficult-to-diagnose problems.\r\n * */\r\nexport function uncheckedAssertNarrowedType<T = unknown>(\r\n  arg: unknown,\r\n  justification: string\r\n): asserts arg is T extends typeof arg ? T : never {}\r\n/* eslint-enable */\r\n\r\n/**\r\n * In debug builds, this function verifies that the given argument \"exists\" (is not\r\n * null or undefined). This function becomes a no-op in the final bundles distributed via NPM.\r\n * @param arg\r\n */\r\nexport function assertExists<A>(arg: A): asserts arg is NonNullable<A> {\r\n  if (ENABLE_ASSERTS) {\r\n    if (arg == null) {\r\n      throw new Error('Expected arg to be set.');\r\n    }\r\n  }\r\n}\r\n\r\n/** Similar to assertExists, but returns the argument. */\r\nfunction castExists<A>(arg: A): NonNullable<A> {\r\n  assertExists(arg);\r\n  return arg;\r\n}\r\n\r\n// For unknown values, this narrows the result to a Record. But for union types\r\n// like `Temporal.DurationLike | string`, it'll strip the primitive types while\r\n// leaving the object type(s) unchanged.\r\nexport function IsObject<T>(\r\n  value: T\r\n): value is Exclude<T, string | null | undefined | number | bigint | symbol | boolean>;\r\nexport function IsObject(value: unknown): value is Record<string | number | symbol, unknown> {\r\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\r\n}\r\n\r\nexport function ToNumber(value: unknown): number {\r\n  // ES 2022's es-abstract made minor changes to ToNumber, but polyfilling these\r\n  // changes adds zero benefit to Temporal and brings in a lot of extra code. So\r\n  // we'll leave ToNumber as-is.\r\n  // See https://github.com/ljharb/es-abstract/blob/main/2022/ToNumber.js\r\n  if (typeof value === 'bigint') throw new TypeError('Cannot convert BigInt to number');\r\n  return Number(value);\r\n}\r\n\r\nfunction IsIntegralNumber(argument: unknown) {\r\n  if (typeof argument !== 'number' || Number.isNaN(argument) || argument === Infinity || argument === -Infinity) {\r\n    return false;\r\n  }\r\n  const absValue = Math.abs(argument);\r\n  return Math.floor(absValue) === absValue;\r\n}\r\n\r\nexport function ToString(value: unknown): string {\r\n  if (typeof value === 'symbol') {\r\n    throw new TypeError('Cannot convert a Symbol value to a String');\r\n  }\r\n  return String(value);\r\n}\r\n\r\nexport function ToIntegerWithTruncation(value: unknown): number {\r\n  const number = ToNumber(value);\r\n  if (number === 0) return 0;\r\n  if (Number.isNaN(number) || number === Infinity || number === -Infinity) {\r\n    throw new RangeError('invalid number value');\r\n  }\r\n  const integer = Math.trunc(number);\r\n  if (integer === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\r\n  return integer;\r\n}\r\n\r\nfunction ToPositiveIntegerWithTruncation(valueParam: unknown, property?: string): number {\r\n  const integer = ToIntegerWithTruncation(valueParam);\r\n  if (integer <= 0) {\r\n    if (property !== undefined) {\r\n      throw new RangeError(`property '${property}' cannot be a a number less than one`);\r\n    }\r\n    throw new RangeError('Cannot convert a number less than one to a positive integer');\r\n  }\r\n  return integer;\r\n}\r\n\r\nexport function ToIntegerIfIntegral(valueParam: unknown): number {\r\n  const number = ToNumber(valueParam);\r\n  if (Number.isNaN(number)) throw new RangeError('not a number');\r\n  if (number === Infinity || number === -Infinity) throw new RangeError('infinity is out of range');\r\n  if (!IsIntegralNumber(number)) throw new RangeError(`unsupported fractional value ${valueParam}`);\r\n  if (number === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\r\n  return number;\r\n}\r\n\r\nfunction ToZeroPaddedDecimalString(n: number, minLength: number) {\r\n  if (DEBUG) {\r\n    if (!IsIntegralNumber(n) || n < 0) {\r\n      throw new RangeError('Assertion failed: `${n}` must be a non-negative integer');\r\n    }\r\n  }\r\n  const s = String(n);\r\n  return s.padStart(minLength, '0');\r\n}\r\n\r\n// This convenience function isn't in the spec, but is useful in the polyfill\r\n// for DRY and better error messages.\r\nexport function RequireString(value: unknown): string {\r\n  if (typeof value !== 'string') {\r\n    // Use String() to ensure that Symbols won't throw\r\n    throw new TypeError(`expected a string, not ${String(value)}`);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction ToSyntacticallyValidMonthCode(valueParam: unknown) {\r\n  const value = RequireString(ToPrimitive(valueParam, String));\r\n  if (\r\n    value.length < 3 ||\r\n    value.length > 4 ||\r\n    value[0] !== 'M' ||\r\n    '0123456789'.indexOf(value[1]) === -1 ||\r\n    '0123456789'.indexOf(value[2]) === -1 ||\r\n    (value[1] + value[2] === '00' && value[3] !== 'L') ||\r\n    (value[3] !== 'L' && value[3] !== undefined)\r\n  ) {\r\n    throw new RangeError(`bad month code ${value}; must match M01-M99 or M00L-M99L`);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction ToOffsetString(valueParam: unknown) {\r\n  const value = RequireString(ToPrimitive(valueParam, String));\r\n  ParseDateTimeUTCOffset(value);\r\n  return value;\r\n}\r\n\r\n// Limited implementation of ToPrimitive that only handles the string case,\r\n// because that's all that's used in this polyfill.\r\nfunction ToPrimitive(value: unknown, preferredType: typeof String): string | number {\r\n  assertExists(preferredType === String);\r\n  if (IsObject(value)) {\r\n    const result = value?.toString();\r\n    if (typeof result === 'string' || typeof result === 'number') return result;\r\n    throw new TypeError('Cannot convert object to primitive value');\r\n  }\r\n  return value;\r\n}\r\n\r\nconst CALENDAR_FIELD_KEYS: readonly FieldKey[] = [\r\n  'era',\r\n  'eraYear',\r\n  'year',\r\n  'month',\r\n  'monthCode',\r\n  'day',\r\n  'hour',\r\n  'minute',\r\n  'second',\r\n  'millisecond',\r\n  'microsecond',\r\n  'nanosecond',\r\n  'offset',\r\n  'timeZone'\r\n] as const;\r\n\r\ntype BuiltinCastFunction = (v: unknown) => string | number;\r\nconst BUILTIN_CASTS: Partial<Record<FieldKey, BuiltinCastFunction>> = {\r\n  era: ToString,\r\n  eraYear: ToIntegerWithTruncation,\r\n  year: ToIntegerWithTruncation,\r\n  month: ToPositiveIntegerWithTruncation,\r\n  monthCode: ToSyntacticallyValidMonthCode,\r\n  day: ToPositiveIntegerWithTruncation,\r\n  hour: ToIntegerWithTruncation,\r\n  minute: ToIntegerWithTruncation,\r\n  second: ToIntegerWithTruncation,\r\n  millisecond: ToIntegerWithTruncation,\r\n  microsecond: ToIntegerWithTruncation,\r\n  nanosecond: ToIntegerWithTruncation,\r\n  offset: ToOffsetString,\r\n  timeZone: ToTemporalTimeZoneIdentifier\r\n};\r\n\r\nconst BUILTIN_DEFAULTS: Partial<Record<FieldKey, number>> = {\r\n  hour: 0,\r\n  minute: 0,\r\n  second: 0,\r\n  millisecond: 0,\r\n  microsecond: 0,\r\n  nanosecond: 0\r\n};\r\n\r\n// each item is [plural, singular, category, (length in ns)]\r\nconst TEMPORAL_UNITS = [\r\n  ['years', 'year', 'date'],\r\n  ['months', 'month', 'date'],\r\n  ['weeks', 'week', 'date'],\r\n  ['days', 'day', 'date'],\r\n  ['hours', 'hour', 'time'],\r\n  ['minutes', 'minute', 'time'],\r\n  ['seconds', 'second', 'time'],\r\n  ['milliseconds', 'millisecond', 'time'],\r\n  ['microseconds', 'microsecond', 'time'],\r\n  ['nanoseconds', 'nanosecond', 'time']\r\n] as const;\r\nconst SINGULAR_FOR = Object.fromEntries(TEMPORAL_UNITS.map((e) => [e[0], e[1]] as const));\r\nconst PLURAL_FOR = Object.fromEntries(TEMPORAL_UNITS.map(([p, s]) => [s, p] as const));\r\nconst UNITS_DESCENDING = TEMPORAL_UNITS.map(([, s]) => s);\r\ntype TimeUnitOrDay = Temporal.TimeUnit | 'day';\r\nconst NS_PER_TIME_UNIT = {\r\n  day: DAY_NANOS,\r\n  hour: 3600e9,\r\n  minute: 60e9,\r\n  second: 1e9,\r\n  millisecond: 1e6,\r\n  microsecond: 1e3,\r\n  nanosecond: 1\r\n};\r\n\r\nconst DURATION_FIELDS = [\r\n  'days',\r\n  'hours',\r\n  'microseconds',\r\n  'milliseconds',\r\n  'minutes',\r\n  'months',\r\n  'nanoseconds',\r\n  'seconds',\r\n  'weeks',\r\n  'years'\r\n] as const;\r\n\r\nimport * as PARSE from './regex';\r\n\r\n// Save the original Intl.DateTimeFormat, it will likely be overwritten with the\r\n// one from this polyfill. Caching the formatter below may be reentrant, so we\r\n// need to use the original one\r\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\r\nconst IntlDateTimeFormatEnUsCache = new Map<string, Intl.DateTimeFormat>();\r\n\r\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier: string) {\r\n  const lowercaseIdentifier = ASCIILowercase(timeZoneIdentifier);\r\n  let instance = IntlDateTimeFormatEnUsCache.get(lowercaseIdentifier);\r\n  if (instance === undefined) {\r\n    instance = new OriginalIntlDateTimeFormat('en-us', {\r\n      timeZone: lowercaseIdentifier,\r\n      hour12: false,\r\n      era: 'short',\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n    IntlDateTimeFormatEnUsCache.set(lowercaseIdentifier, instance);\r\n  }\r\n  return instance;\r\n}\r\n\r\nexport function ToObject<T>(value: T): T extends Record<string, unknown> ? T : Record<PropertyKey, unknown> {\r\n  if (typeof value === 'undefined' || value === null) {\r\n    throw new TypeError(`Expected object not ${value}`);\r\n  }\r\n  return Object(value);\r\n}\r\n\r\n// Adapted from https://github.com/ljharb/es-abstract/blob/main/2022/CopyDataProperties.js\r\n// but simplified (e.g. removed assertions) for this polyfill to reduce bundle size.\r\nexport function CopyDataProperties<K extends PropertyKey, T extends Record<K, unknown>>(\r\n  target: T,\r\n  source: T | undefined,\r\n  excludedKeys: K[],\r\n  excludedValues?: unknown[]\r\n) {\r\n  if (typeof source === 'undefined' || source === null) return;\r\n\r\n  const keys = Reflect.ownKeys(source) as (keyof T)[];\r\n  for (let index = 0; index < keys.length; index++) {\r\n    const nextKey = keys[index];\r\n    if (excludedKeys.some((e) => Object.is(e, nextKey))) continue;\r\n    if (Object.prototype.propertyIsEnumerable.call(source, nextKey)) {\r\n      const propValue = source[nextKey];\r\n      if (excludedValues && excludedValues.some((e) => Object.is(e, propValue))) continue;\r\n\r\n      target[nextKey] = propValue;\r\n    }\r\n  }\r\n}\r\n\r\nexport function IsTemporalInstant(item: unknown): item is Temporal.Instant {\r\n  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\r\n}\r\n\r\nexport function IsTemporalDuration(item: unknown): item is Temporal.Duration {\r\n  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\r\n}\r\nexport function IsTemporalDate(item: unknown): item is Temporal.PlainDate {\r\n  return HasSlot(item, DATE_BRAND);\r\n}\r\n\r\nexport function IsTemporalTime(item: unknown): item is Temporal.PlainTime {\r\n  return HasSlot(item, TIME);\r\n}\r\n\r\nexport function IsTemporalDateTime(item: unknown): item is Temporal.PlainDateTime {\r\n  return HasSlot(item, ISO_DATE_TIME);\r\n}\r\n\r\nexport function IsTemporalYearMonth(item: unknown): item is Temporal.PlainYearMonth {\r\n  return HasSlot(item, YEAR_MONTH_BRAND);\r\n}\r\nexport function IsTemporalMonthDay(item: unknown): item is Temporal.PlainMonthDay {\r\n  return HasSlot(item, MONTH_DAY_BRAND);\r\n}\r\nexport function IsTemporalZonedDateTime(item: unknown): item is Temporal.ZonedDateTime {\r\n  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\r\n}\r\n\r\nexport function CheckReceiver<T extends AnySlottedType>(\r\n  item: unknown,\r\n  test: (item: unknown) => item is T\r\n): asserts item is T {\r\n  if (!test(item)) throw new TypeError('invalid receiver: method called with the wrong type of this-object');\r\n}\r\n\r\nexport function RejectTemporalLikeObject(item: AnyTemporalLikeType) {\r\n  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\r\n    throw new TypeError('with() does not support a calendar or timeZone property');\r\n  }\r\n  if (IsTemporalTime(item)) {\r\n    throw new TypeError('with() does not accept Temporal.PlainTime, use withPlainTime() instead');\r\n  }\r\n  if ((item as { calendar: unknown }).calendar !== undefined) {\r\n    throw new TypeError('with() does not support a calendar property');\r\n  }\r\n  if ((item as { timeZone: unknown }).timeZone !== undefined) {\r\n    throw new TypeError('with() does not support a timeZone property');\r\n  }\r\n}\r\n\r\nfunction FormatCalendarAnnotation(id: BuiltinCalendarId, showCalendar: Temporal.ShowCalendarOption['calendarName']) {\r\n  if (showCalendar === 'never') return '';\r\n  if (showCalendar === 'auto' && id === 'iso8601') return '';\r\n  const flag = showCalendar === 'critical' ? '!' : '';\r\n  return `[${flag}u-ca=${id}]`;\r\n}\r\n\r\n// Not a separate abstract operation in the spec, because it only occurs in one\r\n// place: ParseISODateTime. In the code it's more convenient to split up\r\n// ParseISODateTime for the YYYY-MM, MM-DD, and THH:MM:SS parse goals, so it's\r\n// repeated four times.\r\nfunction processAnnotations(annotations: string) {\r\n  let calendar;\r\n  let calendarWasCritical = false;\r\n  // Avoid the user code minefield of matchAll.\r\n  let match;\r\n  PARSE.annotation.lastIndex = 0;\r\n  while ((match = PARSE.annotation.exec(annotations))) {\r\n    const { 1: critical, 2: key, 3: value } = match;\r\n    if (key === 'u-ca') {\r\n      if (calendar === undefined) {\r\n        calendar = value;\r\n        calendarWasCritical = critical === '!';\r\n      } else if (critical === '!' || calendarWasCritical) {\r\n        throw new RangeError(`Invalid annotations in ${annotations}: more than one u-ca present with critical flag`);\r\n      }\r\n    } else if (critical === '!') {\r\n      throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\r\n    }\r\n  }\r\n  return calendar;\r\n}\r\n\r\nfunction ParseISODateTime(isoString: string) {\r\n  // ZDT is the superset of fields for every other Temporal type\r\n  const match = PARSE.zoneddatetime.exec(isoString);\r\n  if (!match) throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\r\n  const calendar = processAnnotations(match[16]);\r\n  let yearString = match[1];\r\n  if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\r\n  const year = +yearString;\r\n  const month = +(match[2] ?? match[4] ?? 1);\r\n  const day = +(match[3] ?? match[5] ?? 1);\r\n  const hasTime = match[6] !== undefined;\r\n  const hour = +(match[6] ?? 0);\r\n  const minute = +(match[7] ?? match[10] ?? 0);\r\n  let second = +(match[8] ?? match[11] ?? 0);\r\n  if (second === 60) second = 59;\r\n  const fraction = (match[9] ?? match[12] ?? '') + '000000000';\r\n  const millisecond = +fraction.slice(0, 3);\r\n  const microsecond = +fraction.slice(3, 6);\r\n  const nanosecond = +fraction.slice(6, 9);\r\n  let offset;\r\n  let z = false;\r\n  if (match[13]) {\r\n    offset = undefined;\r\n    z = true;\r\n  } else if (match[14]) {\r\n    offset = match[14];\r\n  }\r\n  const tzAnnotation = match[15];\r\n  RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\r\n  return {\r\n    year,\r\n    month,\r\n    day,\r\n    time: hasTime ? { hour, minute, second, millisecond, microsecond, nanosecond } : ('start-of-day' as const),\r\n    tzAnnotation,\r\n    offset,\r\n    z,\r\n    calendar\r\n  };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalInstantString(isoString: string) {\r\n  const result = ParseISODateTime(isoString);\r\n  if (!result.z && !result.offset) throw new RangeError('Temporal.Instant requires a time zone offset');\r\n  return result;\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalZonedDateTimeString(isoString: string) {\r\n  const result = ParseISODateTime(isoString);\r\n  if (!result.tzAnnotation) throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\r\n  return result;\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalDateTimeString(isoString: string) {\r\n  return ParseISODateTime(isoString);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalDateString(isoString: string) {\r\n  return ParseISODateTime(isoString);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalTimeString(isoString: string) {\r\n  const match = PARSE.time.exec(isoString);\r\n  let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\r\n  if (match) {\r\n    calendar = processAnnotations(match[10]);\r\n    hour = +(match[1] ?? 0);\r\n    minute = +(match[2] ?? match[5] ?? 0);\r\n    second = +(match[3] ?? match[6] ?? 0);\r\n    if (second === 60) second = 59;\r\n    const fraction = (match[4] ?? match[7] ?? '') + '000000000';\r\n    millisecond = +fraction.slice(0, 3);\r\n    microsecond = +fraction.slice(3, 6);\r\n    nanosecond = +fraction.slice(6, 9);\r\n    if (match[8]) throw new RangeError('Z designator not supported for PlainTime');\r\n  } else {\r\n    let time, z;\r\n    ({ time, z, calendar } = ParseISODateTime(isoString));\r\n    if (time === 'start-of-day') throw new RangeError(`time is missing in string: ${isoString}`);\r\n    if (z) throw new RangeError('Z designator not supported for PlainTime');\r\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = time);\r\n  }\r\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n  // if it's a date-time string, OK\r\n  if (/[tT ][0-9][0-9]/.test(isoString)) {\r\n    return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\r\n  }\r\n  try {\r\n    const { month, day } = ParseTemporalMonthDayString(isoString);\r\n    RejectISODate(1972, month, day);\r\n  } catch {\r\n    try {\r\n      const { year, month } = ParseTemporalYearMonthString(isoString);\r\n      RejectISODate(year, month, 1);\r\n    } catch {\r\n      return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\r\n    }\r\n  }\r\n  throw new RangeError(`invalid RFC 9557 time-only string ${isoString}; may need a T prefix`);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalYearMonthString(isoString: string) {\r\n  const match = PARSE.yearmonth.exec(isoString);\r\n  let year, month, calendar, referenceISODay;\r\n  if (match) {\r\n    calendar = processAnnotations(match[3]);\r\n    let yearString = match[1];\r\n    if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\r\n    year = +yearString;\r\n    month = +match[2];\r\n    referenceISODay = 1;\r\n    if (calendar !== undefined && calendar !== 'iso8601') {\r\n      throw new RangeError('YYYY-MM format is only valid with iso8601 calendar');\r\n    }\r\n  } else {\r\n    let z;\r\n    ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\r\n    if (z) throw new RangeError('Z designator not supported for PlainYearMonth');\r\n  }\r\n  return { year, month, calendar, referenceISODay };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalMonthDayString(isoString: string) {\r\n  const match = PARSE.monthday.exec(isoString);\r\n  let month, day, calendar, referenceISOYear;\r\n  if (match) {\r\n    calendar = processAnnotations(match[3]);\r\n    month = +match[1];\r\n    day = +match[2];\r\n    if (calendar !== undefined && calendar !== 'iso8601') {\r\n      throw new RangeError('MM-DD format is only valid with iso8601 calendar');\r\n    }\r\n  } else {\r\n    let z;\r\n    ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\r\n    if (z) throw new RangeError('Z designator not supported for PlainMonthDay');\r\n  }\r\n  return { month, day, calendar, referenceISOYear };\r\n}\r\n\r\nconst TIMEZONE_IDENTIFIER = new RegExp(`^${PARSE.timeZoneID.source}$`, 'i');\r\nconst OFFSET_IDENTIFIER = new RegExp(`^${PARSE.offsetIdentifier.source}$`);\r\n\r\nfunction throwBadTimeZoneStringError(timeZoneString: string): never {\r\n  // Offset identifiers only support minute precision, but offsets in ISO\r\n  // strings support nanosecond precision. If the identifier is invalid but\r\n  // it's a valid ISO offset, then it has sub-minute precision. Show a clearer\r\n  // error message in that case.\r\n  const msg = OFFSET.test(timeZoneString) ? 'Seconds not allowed in offset time zone' : 'Invalid time zone';\r\n  throw new RangeError(`${msg}: ${timeZoneString}`);\r\n}\r\n\r\nexport function ParseTimeZoneIdentifier(\r\n  identifier: string\r\n): { tzName: string; offsetMinutes?: undefined } | { tzName?: undefined; offsetMinutes: number } {\r\n  if (!TIMEZONE_IDENTIFIER.test(identifier)) {\r\n    throwBadTimeZoneStringError(identifier);\r\n  }\r\n  if (OFFSET_IDENTIFIER.test(identifier)) {\r\n    const offsetNanoseconds = ParseDateTimeUTCOffset(identifier);\r\n    // The regex limits the input to minutes precision, so we know that the\r\n    // division below will result in an integer.\r\n    return { offsetMinutes: offsetNanoseconds / 60e9 };\r\n  }\r\n  return { tzName: identifier };\r\n}\r\n\r\n// This operation doesn't exist in the spec, but in the polyfill it's split from\r\n// ParseTemporalTimeZoneString so that parsing can be tested separately from the\r\n// logic of converting parsed values into a named or offset identifier.\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalTimeZoneStringRaw(timeZoneString: string): {\r\n  tzAnnotation: string;\r\n  offset: string | undefined;\r\n  z: boolean;\r\n} {\r\n  if (TIMEZONE_IDENTIFIER.test(timeZoneString)) {\r\n    return { tzAnnotation: timeZoneString, offset: undefined, z: false };\r\n  }\r\n  try {\r\n    // Try parsing ISO string instead\r\n    const { tzAnnotation, offset, z } = ParseISODateTime(timeZoneString);\r\n    if (z || tzAnnotation || offset) {\r\n      return { tzAnnotation, offset, z };\r\n    }\r\n  } catch {\r\n    // fall through\r\n  }\r\n  throwBadTimeZoneStringError(timeZoneString);\r\n}\r\n\r\nfunction ParseTemporalTimeZoneString(stringIdent: string): ReturnType<typeof ParseTimeZoneIdentifier> {\r\n  const { tzAnnotation, offset, z } = ParseTemporalTimeZoneStringRaw(stringIdent);\r\n  if (tzAnnotation) return ParseTimeZoneIdentifier(tzAnnotation);\r\n  if (z) return ParseTimeZoneIdentifier('UTC');\r\n  if (offset) return ParseTimeZoneIdentifier(offset);\r\n  /* c8 ignore next */ assertNotReached();\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalDurationStringRaw(isoString: string) {\r\n  const match = PARSE.duration.exec(isoString);\r\n  if (!match) throw new RangeError(`invalid duration: ${isoString}`);\r\n  if (match.every((part, i) => i < 2 || part === undefined)) {\r\n    throw new RangeError(`invalid duration: ${isoString}`);\r\n  }\r\n  const sign = match[1] === '-' ? -1 : 1;\r\n  const years = match[2] === undefined ? 0 : ToIntegerWithTruncation(match[2]) * sign;\r\n  const months = match[3] === undefined ? 0 : ToIntegerWithTruncation(match[3]) * sign;\r\n  const weeks = match[4] === undefined ? 0 : ToIntegerWithTruncation(match[4]) * sign;\r\n  const days = match[5] === undefined ? 0 : ToIntegerWithTruncation(match[5]) * sign;\r\n  const hours = match[6] === undefined ? 0 : ToIntegerWithTruncation(match[6]) * sign;\r\n  const fHours = match[7];\r\n  const minutesStr = match[8];\r\n  const fMinutes = match[9];\r\n  const secondsStr = match[10];\r\n  const fSeconds = match[11];\r\n  let minutes = 0;\r\n  let seconds = 0;\r\n  // fractional hours, minutes, or seconds, expressed in whole nanoseconds:\r\n  let excessNanoseconds = 0;\r\n\r\n  if (fHours !== undefined) {\r\n    if (minutesStr ?? fMinutes ?? secondsStr ?? fSeconds ?? false) {\r\n      throw new RangeError('only the smallest unit can be fractional');\r\n    }\r\n    excessNanoseconds = ToIntegerWithTruncation((fHours + '000000000').slice(0, 9)) * 3600 * sign;\r\n  } else {\r\n    minutes = minutesStr === undefined ? 0 : ToIntegerWithTruncation(minutesStr) * sign;\r\n    if (fMinutes !== undefined) {\r\n      if (secondsStr ?? fSeconds ?? false) {\r\n        throw new RangeError('only the smallest unit can be fractional');\r\n      }\r\n      excessNanoseconds = ToIntegerWithTruncation((fMinutes + '000000000').slice(0, 9)) * 60 * sign;\r\n    } else {\r\n      seconds = secondsStr === undefined ? 0 : ToIntegerWithTruncation(secondsStr) * sign;\r\n      if (fSeconds !== undefined) {\r\n        excessNanoseconds = ToIntegerWithTruncation((fSeconds + '000000000').slice(0, 9)) * sign;\r\n      }\r\n    }\r\n  }\r\n\r\n  const nanoseconds = excessNanoseconds % 1000;\r\n  const microseconds = Math.trunc(excessNanoseconds / 1000) % 1000;\r\n  const milliseconds = Math.trunc(excessNanoseconds / 1e6) % 1000;\r\n  seconds += Math.trunc(excessNanoseconds / 1e9) % 60;\r\n  minutes += Math.trunc(excessNanoseconds / 60e9);\r\n\r\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\r\n}\r\n\r\nfunction ParseTemporalDurationString(isoString: string) {\r\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\r\n    ParseTemporalDurationStringRaw(isoString);\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  return new TemporalDuration(\r\n    years,\r\n    months,\r\n    weeks,\r\n    days,\r\n    hours,\r\n    minutes,\r\n    seconds,\r\n    milliseconds,\r\n    microseconds,\r\n    nanoseconds\r\n  );\r\n}\r\n\r\nexport function RegulateISODate(yearParam: number, monthParam: number, dayParam: number, overflow: Overflow) {\r\n  let year = yearParam;\r\n  let month = monthParam;\r\n  let day = dayParam;\r\n  switch (overflow) {\r\n    case 'reject':\r\n      RejectISODate(year, month, day);\r\n      break;\r\n    case 'constrain':\r\n      ({ year, month, day } = ConstrainISODate(year, month, day));\r\n      break;\r\n  }\r\n  return { year, month, day };\r\n}\r\n\r\nexport function RegulateTime(\r\n  hourParam: number,\r\n  minuteParam: number,\r\n  secondParam: number,\r\n  millisecondParam: number,\r\n  microsecondParam: number,\r\n  nanosecondParam: number,\r\n  overflow: Overflow\r\n) {\r\n  let hour = hourParam;\r\n  let minute = minuteParam;\r\n  let second = secondParam;\r\n  let millisecond = millisecondParam;\r\n  let microsecond = microsecondParam;\r\n  let nanosecond = nanosecondParam;\r\n\r\n  switch (overflow) {\r\n    case 'reject':\r\n      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n      break;\r\n    case 'constrain':\r\n      hour = ConstrainToRange(hour, 0, 23);\r\n      minute = ConstrainToRange(minute, 0, 59);\r\n      second = ConstrainToRange(second, 0, 59);\r\n      millisecond = ConstrainToRange(millisecond, 0, 999);\r\n      microsecond = ConstrainToRange(microsecond, 0, 999);\r\n      nanosecond = ConstrainToRange(nanosecond, 0, 999);\r\n      break;\r\n  }\r\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\r\n}\r\n\r\nexport function ToTemporalPartialDurationRecord(temporalDurationLike: Temporal.DurationLike | string) {\r\n  if (!IsObject(temporalDurationLike)) {\r\n    throw new TypeError('invalid duration-like');\r\n  }\r\n  const result: Record<(typeof DURATION_FIELDS)[number], number | undefined> = {\r\n    years: undefined,\r\n    months: undefined,\r\n    weeks: undefined,\r\n    days: undefined,\r\n    hours: undefined,\r\n    minutes: undefined,\r\n    seconds: undefined,\r\n    milliseconds: undefined,\r\n    microseconds: undefined,\r\n    nanoseconds: undefined\r\n  };\r\n  let any = false;\r\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\r\n    const property = DURATION_FIELDS[index];\r\n    const value = temporalDurationLike[property];\r\n    if (value !== undefined) {\r\n      any = true;\r\n      result[property] = ToIntegerIfIntegral(value);\r\n    }\r\n  }\r\n  if (!any) {\r\n    throw new TypeError('invalid duration-like');\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function AdjustDateDurationRecord(\r\n  { years, months, weeks, days }: DateDuration,\r\n  newDays: number,\r\n  newWeeks?: number,\r\n  newMonths?: number\r\n) {\r\n  return {\r\n    years,\r\n    months: newMonths ?? months,\r\n    weeks: newWeeks ?? weeks,\r\n    days: newDays ?? days\r\n  };\r\n}\r\n\r\nexport function ZeroDateDuration() {\r\n  return { years: 0, months: 0, weeks: 0, days: 0 };\r\n}\r\n\r\nexport function CombineISODateAndTimeRecord(isoDate: ISODate, time: TimeRecord) {\r\n  return { isoDate, time };\r\n}\r\n\r\nexport function MidnightTimeRecord() {\r\n  return { deltaDays: 0, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\r\n}\r\n\r\nexport function NoonTimeRecord() {\r\n  return { deltaDays: 0, hour: 12, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\r\n}\r\n\r\nexport function GetTemporalOverflowOption(options: Temporal.AssignmentOptions) {\r\n  return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\r\n}\r\n\r\nexport function GetTemporalDisambiguationOption(options: Temporal.ToInstantOptions) {\r\n  return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\r\n}\r\n\r\nexport function GetRoundingModeOption(\r\n  options: { roundingMode?: Temporal.RoundingMode },\r\n  fallback: Temporal.RoundingMode\r\n) {\r\n  return GetOption(\r\n    options,\r\n    'roundingMode',\r\n    ['ceil', 'floor', 'expand', 'trunc', 'halfCeil', 'halfFloor', 'halfExpand', 'halfTrunc', 'halfEven'],\r\n    fallback\r\n  );\r\n}\r\n\r\nfunction NegateRoundingMode(roundingMode: Temporal.RoundingMode) {\r\n  switch (roundingMode) {\r\n    case 'ceil':\r\n      return 'floor';\r\n    case 'floor':\r\n      return 'ceil';\r\n    case 'halfCeil':\r\n      return 'halfFloor';\r\n    case 'halfFloor':\r\n      return 'halfCeil';\r\n    default:\r\n      return roundingMode;\r\n  }\r\n}\r\n\r\nexport function GetTemporalOffsetOption(\r\n  options: Temporal.OffsetDisambiguationOptions,\r\n  fallback: Required<Temporal.OffsetDisambiguationOptions>['offset']\r\n) {\r\n  return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\r\n}\r\n\r\nexport function GetTemporalShowCalendarNameOption(options: Temporal.ShowCalendarOption) {\r\n  return GetOption(options, 'calendarName', ['auto', 'always', 'never', 'critical'], 'auto');\r\n}\r\n\r\nexport function GetTemporalShowTimeZoneNameOption(options: Temporal.ZonedDateTimeToStringOptions) {\r\n  return GetOption(options, 'timeZoneName', ['auto', 'never', 'critical'], 'auto');\r\n}\r\n\r\nexport function GetTemporalShowOffsetOption(options: Temporal.ZonedDateTimeToStringOptions) {\r\n  return GetOption(options, 'offset', ['auto', 'never'], 'auto');\r\n}\r\n\r\nexport function GetDirectionOption(options: { direction?: 'next' | 'previous' }) {\r\n  return GetOption(options, 'direction', ['next', 'previous'], REQUIRED);\r\n}\r\n\r\nexport function GetTemporalRoundingIncrementOption(options: { roundingIncrement?: number }) {\r\n  let increment = options.roundingIncrement;\r\n  if (increment === undefined) return 1;\r\n  const integerIncrement = ToIntegerWithTruncation(increment);\r\n  if (integerIncrement < 1 || integerIncrement > 1e9) {\r\n    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${increment}`);\r\n  }\r\n  return integerIncrement;\r\n}\r\nexport function ValidateTemporalRoundingIncrement(increment: number, dividend: number, inclusive: boolean) {\r\n  const maximum = inclusive ? dividend : dividend - 1;\r\n  if (increment > maximum) {\r\n    throw new RangeError(`roundingIncrement must be at least 1 and less than ${maximum}, not ${increment}`);\r\n  }\r\n  if (dividend % increment !== 0) {\r\n    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\r\n  }\r\n}\r\n\r\nexport function GetTemporalFractionalSecondDigitsOption(\r\n  normalizedOptions: Temporal.ToStringPrecisionOptions\r\n): Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] {\r\n  const digitsValue = normalizedOptions.fractionalSecondDigits;\r\n  if (digitsValue === undefined) return 'auto';\r\n  if (typeof digitsValue !== 'number') {\r\n    if (ToString(digitsValue) !== 'auto') {\r\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\r\n    }\r\n    return 'auto';\r\n  }\r\n  const digitCount = Math.floor(digitsValue);\r\n  if (!Number.isFinite(digitCount) || digitCount < 0 || digitCount > 9) {\r\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\r\n  }\r\n  return digitCount as Exclude<Temporal.ToStringPrecisionOptions['fractionalSecondDigits'], 'auto'>;\r\n}\r\n\r\ninterface SecondsStringPrecisionRecord {\r\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] | 'minute';\r\n  unit: UnitSmallerThanOrEqualTo<'minute'>;\r\n  increment: number;\r\n}\r\n\r\nexport function ToSecondsStringPrecisionRecord(\r\n  smallestUnit: Temporal.ToStringPrecisionOptions['smallestUnit'],\r\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits']\r\n): SecondsStringPrecisionRecord {\r\n  switch (smallestUnit) {\r\n    case 'minute':\r\n      return { precision: 'minute', unit: 'minute', increment: 1 };\r\n    case 'second':\r\n      return { precision: 0, unit: 'second', increment: 1 };\r\n    case 'millisecond':\r\n      return { precision: 3, unit: 'millisecond', increment: 1 };\r\n    case 'microsecond':\r\n      return { precision: 6, unit: 'microsecond', increment: 1 };\r\n    case 'nanosecond':\r\n      return { precision: 9, unit: 'nanosecond', increment: 1 };\r\n    default: // fall through if option not given\r\n  }\r\n  switch (precision) {\r\n    case 'auto':\r\n      return { precision, unit: 'nanosecond', increment: 1 };\r\n    case 0:\r\n      return { precision, unit: 'second', increment: 1 };\r\n    case 1:\r\n    case 2:\r\n    case 3:\r\n      return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\r\n    case 4:\r\n    case 5:\r\n    case 6:\r\n      return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\r\n    case 7:\r\n    case 8:\r\n    case 9:\r\n      return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\r\n    default:\r\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${precision}`);\r\n  }\r\n}\r\n\r\nexport const REQUIRED = Symbol('~required~');\r\n\r\ninterface TemporalUnitOptionsBag {\r\n  smallestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\r\n  largestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit | 'auto';\r\n  unit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\r\n}\r\ntype UnitTypeMapping = {\r\n  date: Temporal.DateUnit;\r\n  time: Temporal.TimeUnit;\r\n  datetime: Temporal.DateTimeUnit;\r\n};\r\n// This type specifies the allowed defaults for each unit key type.\r\ntype AllowedGetTemporalUnitDefaultValues = {\r\n  smallestUnit: undefined;\r\n  largestUnit: 'auto' | undefined;\r\n  unit: undefined;\r\n};\r\n\r\nexport function GetTemporalUnitValuedOption<\r\n  U extends keyof TemporalUnitOptionsBag,\r\n  T extends keyof UnitTypeMapping,\r\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\r\n  R extends Exclude<D, typeof REQUIRED> | UnitTypeMapping[T]\r\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D): R;\r\nexport function GetTemporalUnitValuedOption<\r\n  U extends keyof TemporalUnitOptionsBag,\r\n  T extends keyof UnitTypeMapping,\r\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\r\n  E extends 'auto' | Temporal.DateTimeUnit,\r\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\r\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D, extraValues: ReadonlyArray<E>): R;\r\n// This signature of the function is NOT used in type-checking, so restricting\r\n// the default value via generic binding like the other overloads isn't\r\n// necessary.\r\nexport function GetTemporalUnitValuedOption<\r\n  T extends keyof UnitTypeMapping,\r\n  D extends typeof REQUIRED | UnitTypeMapping[T] | 'auto' | undefined,\r\n  E extends 'auto' | Temporal.DateTimeUnit,\r\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\r\n>(\r\n  options: TemporalUnitOptionsBag,\r\n  key: keyof typeof options,\r\n  unitGroup: T,\r\n  requiredOrDefault: D,\r\n  extraValues: ReadonlyArray<E> | never[] = []\r\n): R {\r\n  let allowedSingular: Array<Temporal.DateTimeUnit | 'auto'> = [];\r\n  for (let index = 0; index < TEMPORAL_UNITS.length; index++) {\r\n    const unitInfo = TEMPORAL_UNITS[index];\r\n    const singular = unitInfo[1];\r\n    const category = unitInfo[2];\r\n    if (unitGroup === 'datetime' || unitGroup === category) {\r\n      allowedSingular.push(singular);\r\n    }\r\n  }\r\n  allowedSingular = allowedSingular.concat(extraValues);\r\n  let defaultVal: typeof REQUIRED | Temporal.DateTimeUnit | 'auto' | undefined = requiredOrDefault;\r\n  if (defaultVal === REQUIRED) {\r\n    defaultVal = undefined;\r\n  } else if (defaultVal !== undefined) {\r\n    allowedSingular.push(defaultVal);\r\n  }\r\n  let allowedValues: Array<Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit> | 'auto'> = [];\r\n  allowedValues = allowedValues.concat(allowedSingular);\r\n  for (let index = 0; index < allowedSingular.length; index++) {\r\n    const singular = allowedSingular[index];\r\n    const plural = PLURAL_FOR[singular];\r\n    if (plural !== undefined) allowedValues.push(plural);\r\n  }\r\n  let retval = GetOption(options, key, allowedValues, defaultVal);\r\n  if (retval === undefined && requiredOrDefault === REQUIRED) {\r\n    throw new RangeError(`${key} is required`);\r\n  }\r\n  // Coerce any plural units into their singular form\r\n  return (retval && retval in SINGULAR_FOR ? SINGULAR_FOR[retval] : retval) as R;\r\n}\r\n\r\nexport function GetTemporalRelativeToOption(options: {\r\n  relativeTo?:\r\n    | Temporal.ZonedDateTime\r\n    | Temporal.PlainDateTime\r\n    | Temporal.ZonedDateTimeLike\r\n    | Temporal.PlainDateTimeLike\r\n    | string\r\n    | undefined;\r\n}):\r\n  | { zonedRelativeTo?: Temporal.ZonedDateTime; plainRelativeTo?: never }\r\n  | { plainRelativeTo?: Temporal.PlainDate; zonedRelativeTo?: never } {\r\n  const relativeTo = options.relativeTo;\r\n  if (relativeTo === undefined) return {};\r\n\r\n  let offsetBehaviour: OffsetBehaviour = 'option';\r\n  let matchMinutes = false;\r\n  let isoDate, time, calendar, timeZone, offset;\r\n  if (IsObject(relativeTo)) {\r\n    if (IsTemporalZonedDateTime(relativeTo)) {\r\n      return { zonedRelativeTo: relativeTo };\r\n    }\r\n    if (IsTemporalDate(relativeTo)) return { plainRelativeTo: relativeTo };\r\n    if (IsTemporalDateTime(relativeTo)) {\r\n      return {\r\n        plainRelativeTo: CreateTemporalDate(GetSlot(relativeTo, ISO_DATE_TIME).isoDate, GetSlot(relativeTo, CALENDAR))\r\n      };\r\n    }\r\n    calendar = GetTemporalCalendarIdentifierWithISODefault(relativeTo);\r\n    const fields = PrepareCalendarFields(\r\n      calendar,\r\n      relativeTo,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\r\n      []\r\n    );\r\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, 'constrain'));\r\n    ({ offset, timeZone } = fields);\r\n    if (offset === undefined) offsetBehaviour = 'wall';\r\n  } else {\r\n    let tzAnnotation, z, year, month, day;\r\n    ({ year, month, day, time, calendar, tzAnnotation, offset, z } = ParseISODateTime(RequireString(relativeTo)));\r\n    if (tzAnnotation) {\r\n      timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\r\n      if (z) {\r\n        offsetBehaviour = 'exact';\r\n      } else if (!offset) {\r\n        offsetBehaviour = 'wall';\r\n      }\r\n      matchMinutes = true;\r\n    } else if (z) {\r\n      throw new RangeError(\r\n        'Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone'\r\n      );\r\n    }\r\n    if (!calendar) calendar = 'iso8601';\r\n    calendar = CanonicalizeCalendar(calendar);\r\n    isoDate = { year, month, day };\r\n  }\r\n  if (timeZone === undefined) {\r\n    return { plainRelativeTo: CreateTemporalDate(isoDate, calendar) };\r\n  }\r\n  const offsetNs = offsetBehaviour === 'option' ? ParseDateTimeUTCOffset(castExists(offset)) : 0;\r\n  const epochNanoseconds = InterpretISODateTimeOffset(\r\n    isoDate,\r\n    time,\r\n    offsetBehaviour,\r\n    offsetNs,\r\n    timeZone,\r\n    'compatible',\r\n    'reject',\r\n    matchMinutes\r\n  );\r\n  return { zonedRelativeTo: CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar) };\r\n}\r\n\r\nexport function DefaultTemporalLargestUnit(duration: Temporal.Duration) {\r\n  if (GetSlot(duration, YEARS) !== 0) return 'year';\r\n  if (GetSlot(duration, MONTHS) !== 0) return 'month';\r\n  if (GetSlot(duration, WEEKS) !== 0) return 'week';\r\n  if (GetSlot(duration, DAYS) !== 0) return 'day';\r\n  if (GetSlot(duration, HOURS) !== 0) return 'hour';\r\n  if (GetSlot(duration, MINUTES) !== 0) return 'minute';\r\n  if (GetSlot(duration, SECONDS) !== 0) return 'second';\r\n  if (GetSlot(duration, MILLISECONDS) !== 0) return 'millisecond';\r\n  if (GetSlot(duration, MICROSECONDS) !== 0) return 'microsecond';\r\n  return 'nanosecond';\r\n}\r\n\r\nexport function LargerOfTwoTemporalUnits<T1 extends Temporal.DateTimeUnit, T2 extends Temporal.DateTimeUnit>(\r\n  unit1: T1,\r\n  unit2: T2\r\n) {\r\n  const i1 = UNITS_DESCENDING.indexOf(unit1);\r\n  const i2 = UNITS_DESCENDING.indexOf(unit2);\r\n  if (i1 > i2) {\r\n    return unit2;\r\n  }\r\n  return unit1;\r\n}\r\n\r\nexport function IsCalendarUnit(unit: Temporal.DateTimeUnit): unit is Exclude<Temporal.DateUnit, 'day'> {\r\n  return unit === 'year' || unit === 'month' || unit === 'week';\r\n}\r\n\r\nexport function TemporalUnitCategory(unit: Temporal.DateTimeUnit) {\r\n  if (IsCalendarUnit(unit) || unit === 'day') return 'date';\r\n  return 'time';\r\n}\r\n\r\nfunction calendarImplForID(calendar: BuiltinCalendarId) {\r\n  return GetIntrinsic('%calendarImpl%')(calendar);\r\n}\r\n\r\nexport function calendarImplForObj(\r\n  temporalObj:\r\n    | Temporal.PlainDate\r\n    | Temporal.PlainDateTime\r\n    | Temporal.PlainMonthDay\r\n    | Temporal.PlainYearMonth\r\n    | Temporal.ZonedDateTime\r\n) {\r\n  return GetIntrinsic('%calendarImpl%')(GetSlot(temporalObj, CALENDAR));\r\n}\r\n\r\ntype ISODateToFieldsReturn<Type extends ISODateToFieldsType> = Resolve<{\r\n  year: Type extends 'date' | 'year-month' ? number : never;\r\n  monthCode: string;\r\n  day: Type extends 'date' | 'month-day' ? number : never;\r\n}>;\r\n\r\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate): ISODateToFieldsReturn<'date'>;\r\nexport function ISODateToFields<T extends ISODateToFieldsType>(\r\n  calendar: BuiltinCalendarId,\r\n  isoDate: ISODate,\r\n  type: T\r\n): ISODateToFieldsReturn<T>;\r\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate, type = 'date') {\r\n  const fields = Object.create(null);\r\n  const calendarImpl = calendarImplForID(calendar);\r\n  const calendarDate = calendarImpl.isoToDate(isoDate, { year: true, monthCode: true, day: true });\r\n\r\n  fields.monthCode = calendarDate.monthCode;\r\n  if (type === 'month-day' || type === 'date') {\r\n    fields.day = calendarDate.day;\r\n  }\r\n  if (type === 'year-month' || type === 'date') {\r\n    fields.year = calendarDate.year;\r\n  }\r\n  return fields;\r\n}\r\n\r\ntype Prop<T, K> = T extends unknown ? (K extends keyof T ? T[K] : undefined) : 'ThisShouldNeverHappen';\r\n\r\ntype FieldObjectWithRequired<FieldKeys extends FieldKey> = Resolve<\r\n  // The resulting object type contains:\r\n  // - All keys in FieldKeys, which are required properties and their values\r\n  //   don't include undefined.\r\n  // - All the other keys in CalendarFieldsRecord that aren't in FieldKeys,\r\n  //   which are optional properties and their value types explicitly include\r\n  //   undefined.\r\n  {\r\n    -readonly [k in FieldKeys]: Exclude<Prop<CalendarFieldsRecord, k>, undefined>;\r\n  } & {\r\n    -readonly [k in Exclude<Keys<CalendarFieldsRecord>, FieldKeys>]?: Prop<CalendarFieldsRecord, k> | undefined;\r\n  }\r\n>;\r\n\r\ntype PrepareCalendarFieldsReturn<\r\n  FieldKeys extends FieldKey,\r\n  RequiredFieldsOpt extends ReadonlyArray<FieldKey> | 'partial'\r\n> = RequiredFieldsOpt extends 'partial' ? Partial<CalendarFieldsRecord> : FieldObjectWithRequired<FieldKeys>;\r\n\r\nexport function PrepareCalendarFields<\r\n  FieldKeys extends FieldKey,\r\n  RequiredFields extends ReadonlyArray<FieldKey> | 'partial'\r\n>(\r\n  calendar: BuiltinCalendarId,\r\n  bag: Partial<Record<FieldKeys, unknown>>,\r\n  calendarFieldNames: Array<FieldKeys>,\r\n  nonCalendarFieldNames: Array<FieldKeys>,\r\n  requiredFields: RequiredFields\r\n): PrepareCalendarFieldsReturn<FieldKeys, RequiredFields> {\r\n  const extraFieldNames = calendarImplForID(calendar).extraFields(calendarFieldNames) as FieldKeys[];\r\n  const fields = calendarFieldNames.concat(nonCalendarFieldNames, extraFieldNames);\r\n  const result: Partial<Record<AnyTemporalKey, unknown>> = Object.create(null);\r\n  let any = false;\r\n  fields.sort();\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const property = fields[index];\r\n    const value = bag[property];\r\n    if (value !== undefined) {\r\n      any = true;\r\n      result[property] = castExists(BUILTIN_CASTS[property])(value);\r\n    } else if (requiredFields !== 'partial') {\r\n      if (requiredFields.includes(property)) {\r\n        throw new TypeError(`required property '${property}' missing or undefined`);\r\n      }\r\n      result[property] = BUILTIN_DEFAULTS[property];\r\n    }\r\n  }\r\n  if (requiredFields === 'partial' && !any) {\r\n    throw new TypeError('no supported properties found');\r\n  }\r\n  return result as unknown as PrepareCalendarFieldsReturn<FieldKeys, RequiredFields>;\r\n}\r\n\r\ntype FieldCompleteness = 'complete' | 'partial';\r\n\r\nexport function ToTemporalTimeRecord(bag: Partial<Record<keyof TimeRecord, string | number>>): TimeRecord;\r\nexport function ToTemporalTimeRecord(\r\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\r\n  completeness: 'partial'\r\n): Partial<TimeRecord>;\r\nexport function ToTemporalTimeRecord(\r\n  bag: Partial<Record<keyof TimeRecord, string | number>>,\r\n  completeness: 'complete'\r\n): TimeRecord;\r\nexport function ToTemporalTimeRecord(\r\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\r\n  completeness: FieldCompleteness = 'complete'\r\n): Partial<TimeRecord> {\r\n  // NOTE: Field order is sorted to make the sort in PrepareTemporalFields more efficient.\r\n  const fields: (keyof TimeRecord)[] = ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second'];\r\n  let any = false;\r\n  const result: Partial<TimeRecord> = Object.create(null);\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const field = fields[index];\r\n    const value = bag[field];\r\n    if (value !== undefined) {\r\n      result[field] = ToIntegerWithTruncation(value);\r\n      any = true;\r\n    } else if (completeness === 'complete') {\r\n      result[field] = 0;\r\n    }\r\n  }\r\n  if (!any) throw new TypeError('invalid time-like');\r\n  return result;\r\n}\r\n\r\nexport function ToTemporalDate(\r\n  item: PlainDateParams['from'][0],\r\n  options?: PlainDateParams['from'][1]\r\n): Temporal.PlainDate {\r\n  if (IsObject(item)) {\r\n    if (IsTemporalDate(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDate(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\r\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\r\n      const isoDate = isoDateTime.isoDate;\r\n      return CreateTemporalDate(isoDate, GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalDateTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\r\n      return CreateTemporalDate(GetSlot(item, ISO_DATE_TIME).isoDate, GetSlot(item, CALENDAR));\r\n    }\r\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    const isoDate = CalendarDateFromFields(calendar, fields, overflow);\r\n    return CreateTemporalDate(isoDate, calendar);\r\n  }\r\n  let { year, month, day, calendar, z } = ParseTemporalDateString(RequireString(item));\r\n  if (z) throw new RangeError('Z designator not supported for PlainDate');\r\n  if (!calendar) calendar = 'iso8601';\r\n  calendar = CanonicalizeCalendar(calendar);\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\r\n  GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\r\n  return CreateTemporalDate({ year, month, day }, calendar);\r\n}\r\n\r\nexport function InterpretTemporalDateTimeFields(\r\n  calendar: BuiltinCalendarId,\r\n  fields: CalendarFieldsRecord & TimeRecord,\r\n  overflow: Overflow\r\n) {\r\n  const isoDate = CalendarDateFromFields(calendar, fields, overflow);\r\n  const time = RegulateTime(\r\n    fields.hour,\r\n    fields.minute,\r\n    fields.second,\r\n    fields.millisecond,\r\n    fields.microsecond,\r\n    fields.nanosecond,\r\n    overflow\r\n  );\r\n  return CombineISODateAndTimeRecord(isoDate, time);\r\n}\r\n\r\nexport function ToTemporalDateTime(item: PlainDateTimeParams['from'][0], options?: PlainDateTimeParams['from'][1]) {\r\n  let isoDate, time, calendar;\r\n\r\n  if (IsObject(item)) {\r\n    if (IsTemporalDateTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDateTime(GetSlot(item, ISO_DATE_TIME), GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDateTime(isoDateTime, GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalDate(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDateTime(\r\n        CombineISODateAndTimeRecord(GetSlot(item, ISO_DATE), MidnightTimeRecord()),\r\n        GetSlot(item, CALENDAR)\r\n      );\r\n    }\r\n\r\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(\r\n      calendar,\r\n      item,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\r\n      []\r\n    );\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\r\n  } else {\r\n    let z, year, month, day;\r\n    ({ year, month, day, time, calendar, z } = ParseTemporalDateTimeString(RequireString(item)));\r\n    if (z) throw new RangeError('Z designator not supported for PlainDateTime');\r\n    if (time === 'start-of-day') time = MidnightTimeRecord();\r\n    RejectDateTime(\r\n      year,\r\n      month,\r\n      day,\r\n      time.hour,\r\n      time.minute,\r\n      time.second,\r\n      time.millisecond,\r\n      time.microsecond,\r\n      time.nanosecond\r\n    );\r\n    if (!calendar) calendar = 'iso8601';\r\n    calendar = CanonicalizeCalendar(calendar);\r\n    GetTemporalOverflowOption(GetOptionsObject(options));\r\n    isoDate = { year, month, day };\r\n  }\r\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, time);\r\n  return CreateTemporalDateTime(isoDateTime, calendar);\r\n}\r\n\r\nexport function ToTemporalDuration(item: DurationParams['from'][0]) {\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  if (IsTemporalDuration(item)) {\r\n    return new TemporalDuration(\r\n      GetSlot(item, YEARS),\r\n      GetSlot(item, MONTHS),\r\n      GetSlot(item, WEEKS),\r\n      GetSlot(item, DAYS),\r\n      GetSlot(item, HOURS),\r\n      GetSlot(item, MINUTES),\r\n      GetSlot(item, SECONDS),\r\n      GetSlot(item, MILLISECONDS),\r\n      GetSlot(item, MICROSECONDS),\r\n      GetSlot(item, NANOSECONDS)\r\n    );\r\n  }\r\n  if (!IsObject(item)) {\r\n    return ParseTemporalDurationString(RequireString(item));\r\n  }\r\n  const result = {\r\n    years: 0,\r\n    months: 0,\r\n    weeks: 0,\r\n    days: 0,\r\n    hours: 0,\r\n    minutes: 0,\r\n    seconds: 0,\r\n    milliseconds: 0,\r\n    microseconds: 0,\r\n    nanoseconds: 0\r\n  };\r\n  let partial = ToTemporalPartialDurationRecord(item);\r\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\r\n    const property = DURATION_FIELDS[index];\r\n    const value = partial[property];\r\n    if (value !== undefined) {\r\n      result[property] = value;\r\n    }\r\n  }\r\n  return new TemporalDuration(\r\n    result.years,\r\n    result.months,\r\n    result.weeks,\r\n    result.days,\r\n    result.hours,\r\n    result.minutes,\r\n    result.seconds,\r\n    result.milliseconds,\r\n    result.microseconds,\r\n    result.nanoseconds\r\n  );\r\n}\r\n\r\nexport function ToTemporalInstant(itemParam: InstantParams['from'][0]) {\r\n  let item: string | number;\r\n  if (IsObject(itemParam)) {\r\n    if (IsTemporalInstant(itemParam) || IsTemporalZonedDateTime(itemParam)) {\r\n      return CreateTemporalInstant(GetSlot(itemParam, EPOCHNANOSECONDS));\r\n    }\r\n    item = ToPrimitive(itemParam, String);\r\n  } else {\r\n    item = itemParam;\r\n  }\r\n  const { year, month, day, time, offset, z } = ParseTemporalInstantString(RequireString(item));\r\n  const {\r\n    hour = 0,\r\n    minute = 0,\r\n    second = 0,\r\n    millisecond = 0,\r\n    microsecond = 0,\r\n    nanosecond = 0\r\n  } = time === 'start-of-day' ? {} : time;\r\n\r\n  // ParseTemporalInstantString ensures that either `z` is true or or `offset` is non-undefined\r\n  const offsetNanoseconds = z ? 0 : ParseDateTimeUTCOffset(castExists(offset));\r\n  const balanced = BalanceISODateTime(\r\n    year,\r\n    month,\r\n    day,\r\n    hour,\r\n    minute,\r\n    second,\r\n    millisecond,\r\n    microsecond,\r\n    nanosecond - offsetNanoseconds\r\n  );\r\n  CheckISODaysRange(balanced.isoDate);\r\n  const epochNanoseconds = GetUTCEpochNanoseconds(balanced);\r\n  return CreateTemporalInstant(epochNanoseconds);\r\n}\r\n\r\nexport function ToTemporalMonthDay(item: PlainMonthDayParams['from'][0], options?: PlainMonthDayParams['from'][1]) {\r\n  if (IsObject(item)) {\r\n    if (IsTemporalMonthDay(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalMonthDay(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\r\n    }\r\n    let calendar;\r\n    if (HasSlot(item, CALENDAR)) {\r\n      calendar = GetSlot(item, CALENDAR);\r\n    } else {\r\n      calendar = item.calendar;\r\n      if (calendar === undefined) calendar = 'iso8601';\r\n      calendar = ToTemporalCalendarIdentifier(calendar);\r\n    }\r\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    const isoDate = CalendarMonthDayFromFields(calendar, fields, overflow);\r\n    return CreateTemporalMonthDay(isoDate, calendar);\r\n  }\r\n\r\n  let { month, day, referenceISOYear, calendar } = ParseTemporalMonthDayString(RequireString(item));\r\n  if (calendar === undefined) calendar = 'iso8601';\r\n  calendar = CanonicalizeCalendar(calendar);\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\r\n\r\n  GetTemporalOverflowOption(GetOptionsObject(options));\r\n  if (calendar === 'iso8601') {\r\n    const isoCalendarReferenceYear = 1972; // First leap year after Unix epoch\r\n    return CreateTemporalMonthDay({ year: isoCalendarReferenceYear, month, day }, calendar);\r\n  }\r\n  assertExists(referenceISOYear);\r\n  let isoDate = { year: referenceISOYear, month, day };\r\n  RejectDateRange(isoDate);\r\n  const result = ISODateToFields(calendar, isoDate, 'month-day');\r\n  isoDate = CalendarMonthDayFromFields(calendar, result, 'constrain');\r\n  return CreateTemporalMonthDay(isoDate, calendar);\r\n}\r\n\r\nexport function ToTemporalTime(item: PlainTimeParams['from'][0], options?: PlainTimeParams['from'][1]) {\r\n  let time;\r\n  if (IsObject(item)) {\r\n    if (IsTemporalTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalTime(GetSlot(item, TIME));\r\n    }\r\n    if (IsTemporalDateTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalTime(GetSlot(item, ISO_DATE_TIME).time);\r\n    }\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalTime(isoDateTime.time);\r\n    }\r\n    const { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow);\r\n  } else {\r\n    time = ParseTemporalTimeString(RequireString(item));\r\n    GetTemporalOverflowOption(GetOptionsObject(options));\r\n  }\r\n  return CreateTemporalTime(time);\r\n}\r\n\r\nexport function ToTimeRecordOrMidnight(item: PlainTimeParams['from'][0] | undefined) {\r\n  if (item === undefined) return MidnightTimeRecord();\r\n  return GetSlot(ToTemporalTime(item), TIME);\r\n}\r\n\r\nexport function ToTemporalYearMonth(\r\n  item: PlainYearMonthParams['from'][0],\r\n  options?: PlainYearMonthParams['from'][1]\r\n): Temporal.PlainYearMonth {\r\n  if (IsObject(item)) {\r\n    if (IsTemporalYearMonth(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalYearMonth(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\r\n    }\r\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode'], [], []);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    const isoDate = CalendarYearMonthFromFields(calendar, fields, overflow);\r\n    return CreateTemporalYearMonth(isoDate, calendar);\r\n  }\r\n\r\n  let { year, month, referenceISODay, calendar } = ParseTemporalYearMonthString(RequireString(item));\r\n  if (calendar === undefined) calendar = 'iso8601';\r\n  calendar = CanonicalizeCalendar(calendar);\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\r\n\r\n  GetTemporalOverflowOption(GetOptionsObject(options));\r\n  let isoDate = { year, month, day: referenceISODay };\r\n  RejectYearMonthRange(isoDate);\r\n  const result = ISODateToFields(calendar, isoDate, 'year-month');\r\n  isoDate = CalendarYearMonthFromFields(calendar, result, 'constrain');\r\n  return CreateTemporalYearMonth(isoDate, calendar);\r\n}\r\n\r\ntype OffsetBehaviour = 'wall' | 'exact' | 'option';\r\n\r\nexport function InterpretISODateTimeOffset(\r\n  isoDate: ISODate,\r\n  time: 'start-of-day' | TimeRecord,\r\n  offsetBehaviour: OffsetBehaviour,\r\n  offsetNs: number,\r\n  timeZone: string,\r\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>,\r\n  offsetOpt: Temporal.OffsetDisambiguationOptions['offset'],\r\n  matchMinute: boolean\r\n) {\r\n  // start-of-day signifies that we had a string such as YYYY-MM-DD[Zone]. It is\r\n  // grammatically not possible to specify a UTC offset in that string, so the\r\n  // behaviour collapses into ~WALL~, which is equivalent to offset: \"ignore\".\r\n  if (time === 'start-of-day') {\r\n    assert(offsetBehaviour === 'wall', 'offset cannot be provided in YYYY-MM-DD[Zone] string');\r\n    assert(offsetNs === 0, 'offset cannot be provided in YYYY-MM-DD[Zone] string');\r\n    return GetStartOfDay(timeZone, isoDate);\r\n  }\r\n\r\n  const dt = CombineISODateAndTimeRecord(isoDate, time);\r\n\r\n  if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\r\n    // Simple case: ISO string without a TZ offset (or caller wants to ignore\r\n    // the offset), so just convert DateTime to Instant in the given time zone\r\n    return GetEpochNanosecondsFor(timeZone, dt, disambiguation);\r\n  }\r\n\r\n  // The caller wants the offset to always win ('use') OR the caller is OK\r\n  // with the offset winning ('prefer' or 'reject') as long as it's valid\r\n  // for this timezone and date/time.\r\n  if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\r\n    // Calculate the instant for the input's date/time and offset\r\n    const balanced = BalanceISODateTime(\r\n      isoDate.year,\r\n      isoDate.month,\r\n      isoDate.day,\r\n      time.hour,\r\n      time.minute,\r\n      time.second,\r\n      time.millisecond,\r\n      time.microsecond,\r\n      time.nanosecond - offsetNs\r\n    );\r\n    CheckISODaysRange(balanced.isoDate);\r\n    const epochNs = GetUTCEpochNanoseconds(balanced);\r\n    ValidateEpochNanoseconds(epochNs);\r\n    return epochNs;\r\n  }\r\n\r\n  CheckISODaysRange(isoDate);\r\n  const utcEpochNs = GetUTCEpochNanoseconds(dt);\r\n\r\n  // \"prefer\" or \"reject\"\r\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, dt);\r\n  for (let index = 0; index < possibleEpochNs.length; index++) {\r\n    const candidate = possibleEpochNs[index];\r\n    const candidateOffset = JSBI.toNumber(JSBI.subtract(utcEpochNs, candidate));\r\n    const roundedCandidateOffset = RoundNumberToIncrement(candidateOffset, 60e9, 'halfExpand');\r\n    if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\r\n      return candidate;\r\n    }\r\n  }\r\n\r\n  // the user-provided offset doesn't match any instants for this time\r\n  // zone and date/time.\r\n  if (offsetOpt === 'reject') {\r\n    const offsetStr = FormatUTCOffsetNanoseconds(offsetNs);\r\n    const dtStr = ISODateTimeToString(dt, 'iso8601', 'auto');\r\n    throw new RangeError(`Offset ${offsetStr} is invalid for ${dtStr} in ${timeZone}`);\r\n  }\r\n  // fall through: offsetOpt === 'prefer', but the offset doesn't match\r\n  // so fall back to use the time zone instead.\r\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, dt, disambiguation);\r\n}\r\n\r\nexport function ToTemporalZonedDateTime(\r\n  item: ZonedDateTimeParams['from'][0],\r\n  options?: ZonedDateTimeParams['from'][1]\r\n) {\r\n  let isoDate, time, timeZone, offset, calendar;\r\n  let matchMinute = false;\r\n  let offsetBehaviour: OffsetBehaviour = 'option';\r\n  let disambiguation, offsetOpt;\r\n  if (IsObject(item)) {\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const resolvedOptions = GetOptionsObject(options);\r\n      GetTemporalDisambiguationOption(resolvedOptions); // validate and ignore\r\n      GetTemporalOffsetOption(resolvedOptions, 'reject');\r\n      GetTemporalOverflowOption(resolvedOptions);\r\n      return CreateTemporalZonedDateTime(\r\n        GetSlot(item, EPOCHNANOSECONDS),\r\n        GetSlot(item, TIME_ZONE),\r\n        GetSlot(item, CALENDAR)\r\n      );\r\n    }\r\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(\r\n      calendar,\r\n      item,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\r\n      ['timeZone']\r\n    );\r\n    ({ offset, timeZone } = fields);\r\n    if (offset === undefined) {\r\n      offsetBehaviour = 'wall';\r\n    }\r\n    const resolvedOptions = GetOptionsObject(options);\r\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\r\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\r\n    const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\r\n  } else {\r\n    let tzAnnotation, z, year, month, day;\r\n    ({ year, month, day, time, tzAnnotation, offset, z, calendar } = ParseTemporalZonedDateTimeString(\r\n      RequireString(item)\r\n    ));\r\n    timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\r\n    if (z) {\r\n      offsetBehaviour = 'exact';\r\n    } else if (!offset) {\r\n      offsetBehaviour = 'wall';\r\n    }\r\n    if (!calendar) calendar = 'iso8601';\r\n    calendar = CanonicalizeCalendar(calendar);\r\n    matchMinute = true; // ISO strings may specify offset with less precision\r\n    const resolvedOptions = GetOptionsObject(options);\r\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\r\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\r\n    GetTemporalOverflowOption(resolvedOptions); // validate and ignore\r\n    isoDate = { year, month, day };\r\n  }\r\n  let offsetNs = 0;\r\n  if (offsetBehaviour === 'option') offsetNs = ParseDateTimeUTCOffset(castExists(offset));\r\n  const epochNanoseconds = InterpretISODateTimeOffset(\r\n    isoDate,\r\n    time,\r\n    offsetBehaviour,\r\n    offsetNs,\r\n    timeZone,\r\n    disambiguation,\r\n    offsetOpt,\r\n    matchMinute\r\n  );\r\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\r\n}\r\n\r\nexport function CreateTemporalDateSlots(result: Temporal.PlainDate, isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  RejectDateRange(isoDate);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE, isoDate);\r\n  SetSlot(result, CALENDAR, calendar);\r\n  SetSlot(result, DATE_BRAND, true);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalDateToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainDate <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalDate(isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\r\n  const result = Object.create(TemporalPlainDate.prototype);\r\n  CreateTemporalDateSlots(result, isoDate, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalDateTimeSlots(\r\n  result: Temporal.PlainDateTime,\r\n  isoDateTime: ISODateTime,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  RejectDateTimeRange(isoDateTime);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE_TIME, isoDateTime);\r\n  SetSlot(result, CALENDAR, calendar);\r\n\r\n  if (DEBUG) {\r\n    let repr = ISODateTimeToString(isoDateTime, calendar, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainDateTime <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalDateTime(isoDateTime: ISODateTime, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\r\n  const result = Object.create(TemporalPlainDateTime.prototype);\r\n  CreateTemporalDateTimeSlots(result, isoDateTime, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalMonthDaySlots(\r\n  result: Temporal.PlainMonthDay,\r\n  isoDate: ISODate,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  RejectDateRange(isoDate);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE, isoDate);\r\n  SetSlot(result, CALENDAR, calendar);\r\n  SetSlot(result, MONTH_DAY_BRAND, true);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalMonthDayToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainMonthDay <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalMonthDay(isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\r\n  const result = Object.create(TemporalPlainMonthDay.prototype);\r\n  CreateTemporalMonthDaySlots(result, isoDate, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalTimeSlots(result: Temporal.PlainTime, time: TimeRecord) {\r\n  CreateSlots(result);\r\n  SetSlot(result, TIME, time);\r\n\r\n  if (DEBUG) {\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainTime <${TimeRecordToString(time, 'auto')}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalTime(time: TimeRecord) {\r\n  const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\r\n  const result = Object.create(TemporalPlainTime.prototype);\r\n  CreateTemporalTimeSlots(result, time);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalYearMonthSlots(\r\n  result: Temporal.PlainYearMonth,\r\n  isoDate: ISODate,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  RejectYearMonthRange(isoDate);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE, isoDate);\r\n  SetSlot(result, CALENDAR, calendar);\r\n  SetSlot(result, YEAR_MONTH_BRAND, true);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalYearMonthToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainYearMonth <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalYearMonth(isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\r\n  const result = Object.create(TemporalPlainYearMonth.prototype);\r\n  CreateTemporalYearMonthSlots(result, isoDate, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalInstantSlots(result: Temporal.Instant, epochNanoseconds: JSBI) {\r\n  ValidateEpochNanoseconds(epochNanoseconds);\r\n  CreateSlots(result);\r\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\r\n\r\n  if (DEBUG) {\r\n    const iso = GetISOPartsFromEpoch(epochNanoseconds);\r\n    const repr = ISODateTimeToString(iso, 'iso8601', 'auto', 'never') + 'Z';\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `${result[Symbol.toStringTag]} <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalInstant(epochNanoseconds: JSBI) {\r\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\r\n  const result: Temporal.Instant = Object.create(TemporalInstant.prototype);\r\n  CreateTemporalInstantSlots(result, epochNanoseconds);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalZonedDateTimeSlots(\r\n  result: Temporal.ZonedDateTime,\r\n  epochNanoseconds: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  ValidateEpochNanoseconds(epochNanoseconds);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\r\n  SetSlot(result, TIME_ZONE, timeZone);\r\n  SetSlot(result, CALENDAR, calendar);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalZonedDateTimeToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.ZonedDateTime <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalZonedDateTime(\r\n  epochNanoseconds: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId = 'iso8601'\r\n) {\r\n  const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\r\n  const result: Temporal.ZonedDateTime = Object.create(TemporalZonedDateTime.prototype);\r\n  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\r\n  return result;\r\n}\r\n\r\nfunction CalendarFieldKeysPresent(fields: Record<FieldKey, unknown>) {\r\n  return CALENDAR_FIELD_KEYS.filter((key) => fields[key] !== undefined);\r\n}\r\n\r\nexport function CalendarMergeFields<Base extends Record<string, unknown>, ToAdd extends Record<string, unknown>>(\r\n  calendar: BuiltinCalendarId,\r\n  fields: Base,\r\n  additionalFields: ToAdd\r\n) {\r\n  const additionalKeys = CalendarFieldKeysPresent(additionalFields);\r\n  const overriddenKeys = calendarImplForID(calendar).fieldKeysToIgnore(additionalKeys);\r\n  const merged = Object.create(null);\r\n  const fieldsKeys = CalendarFieldKeysPresent(fields);\r\n  for (let ix = 0; ix < CALENDAR_FIELD_KEYS.length; ix++) {\r\n    let propValue = undefined;\r\n    const key = CALENDAR_FIELD_KEYS[ix];\r\n    if (fieldsKeys.includes(key) && !overriddenKeys.includes(key)) {\r\n      propValue = fields[key];\r\n    }\r\n    if (additionalKeys.includes(key)) {\r\n      propValue = additionalFields[key];\r\n    }\r\n    if (propValue !== undefined) merged[key] = propValue;\r\n  }\r\n  return merged as Base & ToAdd;\r\n}\r\n\r\nexport function CalendarDateAdd(\r\n  calendar: BuiltinCalendarId,\r\n  isoDate: ISODate,\r\n  dateDuration: Partial<DateDuration>,\r\n  overflow: Overflow\r\n) {\r\n  const result = calendarImplForID(calendar).dateAdd(isoDate, dateDuration, overflow);\r\n  RejectDateRange(result);\r\n  return result;\r\n}\r\n\r\nfunction CalendarDateUntil(\r\n  calendar: BuiltinCalendarId,\r\n  isoDate: ISODate,\r\n  isoOtherDate: ISODate,\r\n  largestUnit: Temporal.DateUnit\r\n) {\r\n  return calendarImplForID(calendar).dateUntil(isoDate, isoOtherDate, largestUnit);\r\n}\r\n\r\nexport function ToTemporalCalendarIdentifier(calendarLike: Temporal.CalendarLike): BuiltinCalendarId {\r\n  if (IsObject(calendarLike)) {\r\n    if (HasSlot(calendarLike, CALENDAR)) return GetSlot(calendarLike, CALENDAR);\r\n  }\r\n  const identifier = RequireString(calendarLike);\r\n  try {\r\n    // Fast path: identifier is a calendar type, no ISO string parsing needed\r\n    return CanonicalizeCalendar(identifier);\r\n  } catch {\r\n    // fall through\r\n  }\r\n  let calendar;\r\n  try {\r\n    ({ calendar } = ParseISODateTime(identifier));\r\n  } catch {\r\n    try {\r\n      ({ calendar } = ParseTemporalTimeString(identifier));\r\n    } catch {\r\n      try {\r\n        ({ calendar } = ParseTemporalYearMonthString(identifier));\r\n      } catch {\r\n        ({ calendar } = ParseTemporalMonthDayString(identifier));\r\n      }\r\n    }\r\n  }\r\n  if (!calendar) calendar = 'iso8601';\r\n  return CanonicalizeCalendar(calendar);\r\n}\r\n\r\nfunction GetTemporalCalendarIdentifierWithISODefault(item: { calendar?: Temporal.CalendarLike }) {\r\n  if (HasSlot(item, CALENDAR)) return GetSlot(item, CALENDAR);\r\n  const { calendar } = item;\r\n  if (calendar === undefined) return 'iso8601';\r\n  return ToTemporalCalendarIdentifier(calendar);\r\n}\r\n\r\nexport function CalendarEquals(one: BuiltinCalendarId, two: BuiltinCalendarId) {\r\n  return CanonicalizeCalendar(one) === CanonicalizeCalendar(two);\r\n}\r\n\r\nexport function CalendarDateFromFields(calendar: BuiltinCalendarId, fields: CalendarFieldsRecord, overflow: Overflow) {\r\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\r\n  calendarImpl.resolveFields(fields, 'date');\r\n  const result = calendarImpl.dateToISO(fields, overflow);\r\n  RejectDateRange(result);\r\n  return result;\r\n}\r\n\r\nexport function CalendarYearMonthFromFields(\r\n  calendar: BuiltinCalendarId,\r\n  fields: CalendarFieldsRecord,\r\n  overflow: Overflow\r\n) {\r\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\r\n  calendarImpl.resolveFields(fields, 'year-month');\r\n  fields.day = 1;\r\n  const result = calendarImpl.dateToISO(fields, overflow);\r\n  RejectYearMonthRange(result);\r\n  return result;\r\n}\r\n\r\nexport function CalendarMonthDayFromFields(\r\n  calendar: BuiltinCalendarId,\r\n  fields: MonthDayFromFieldsObject,\r\n  overflow: Overflow\r\n) {\r\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\r\n  calendarImpl.resolveFields(fields, 'month-day');\r\n  const result = calendarImpl.monthDayToISOReferenceDate(fields, overflow);\r\n  RejectDateRange(result);\r\n  return result;\r\n}\r\n\r\nexport function ToTemporalTimeZoneIdentifier(temporalTimeZoneLike: unknown): string {\r\n  if (IsObject(temporalTimeZoneLike)) {\r\n    if (IsTemporalZonedDateTime(temporalTimeZoneLike)) return GetSlot(temporalTimeZoneLike, TIME_ZONE);\r\n  }\r\n  const timeZoneString = RequireString(temporalTimeZoneLike);\r\n  if (timeZoneString === 'UTC') return 'UTC'; // UTC fast path\r\n\r\n  const { tzName, offsetMinutes } = ParseTemporalTimeZoneString(timeZoneString);\r\n  if (offsetMinutes !== undefined) {\r\n    return FormatOffsetTimeZoneIdentifier(offsetMinutes);\r\n  }\r\n  // if offsetMinutes is undefined, then tzName must be present\r\n  const record = GetAvailableNamedTimeZoneIdentifier(castExists(tzName));\r\n  if (!record) throw new RangeError(`Unrecognized time zone ${tzName}`);\r\n  return record.identifier;\r\n}\r\n\r\nexport function TimeZoneEquals(one: string, two: string) {\r\n  if (one === two) return true;\r\n  const offsetMinutes1 = ParseTimeZoneIdentifier(one).offsetMinutes;\r\n  const offsetMinutes2 = ParseTimeZoneIdentifier(two).offsetMinutes;\r\n  if (offsetMinutes1 === undefined && offsetMinutes2 === undefined) {\r\n    // Calling GetAvailableNamedTimeZoneIdentifier is costly, so (unlike the\r\n    // spec) the polyfill will early-return if one of them isn't recognized. Try\r\n    // the second ID first because it's more likely to be unknown, because it\r\n    // can come from the argument of TimeZone.p.equals as opposed to the first\r\n    // ID which comes from the receiver.\r\n    const idRecord2 = GetAvailableNamedTimeZoneIdentifier(two);\r\n    if (!idRecord2) return false;\r\n    const idRecord1 = GetAvailableNamedTimeZoneIdentifier(one);\r\n    if (!idRecord1) return false;\r\n    return idRecord1.primaryIdentifier === idRecord2.primaryIdentifier;\r\n  } else {\r\n    return offsetMinutes1 === offsetMinutes2;\r\n  }\r\n}\r\n\r\nexport function GetOffsetNanosecondsFor(timeZone: string, epochNs: JSBI) {\r\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes;\r\n  if (offsetMinutes !== undefined) return offsetMinutes * 60e9;\r\n\r\n  return GetNamedTimeZoneOffsetNanoseconds(timeZone, epochNs);\r\n}\r\n\r\nexport function FormatUTCOffsetNanoseconds(offsetNs: number): string {\r\n  const sign = offsetNs < 0 ? '-' : '+';\r\n  const absoluteNs = Math.abs(offsetNs);\r\n  const hour = Math.floor(absoluteNs / 3600e9);\r\n  const minute = Math.floor(absoluteNs / 60e9) % 60;\r\n  const second = Math.floor(absoluteNs / 1e9) % 60;\r\n  const subSecondNs = absoluteNs % 1e9;\r\n  const precision = second === 0 && subSecondNs === 0 ? 'minute' : 'auto';\r\n  const timeString = FormatTimeString(hour, minute, second, subSecondNs, precision);\r\n  return `${sign}${timeString}`;\r\n}\r\n\r\nexport function GetISODateTimeFor(timeZone: string, epochNs: JSBI) {\r\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, epochNs);\r\n  let {\r\n    isoDate: { year, month, day },\r\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\r\n  } = GetISOPartsFromEpoch(epochNs);\r\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs);\r\n}\r\n\r\nexport function GetEpochNanosecondsFor(\r\n  timeZone: string,\r\n  isoDateTime: ISODateTime,\r\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\r\n) {\r\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\r\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, isoDateTime, disambiguation);\r\n}\r\n\r\n// TODO: See if this logic can be removed in favour of GetNamedTimeZoneEpochNanoseconds\r\nfunction DisambiguatePossibleEpochNanoseconds(\r\n  possibleEpochNs: JSBI[],\r\n  timeZone: string,\r\n  isoDateTime: ISODateTime,\r\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\r\n) {\r\n  const numInstants = possibleEpochNs.length;\r\n\r\n  if (numInstants === 1) return possibleEpochNs[0];\r\n  if (numInstants) {\r\n    switch (disambiguation) {\r\n      case 'compatible':\r\n      // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\r\n      case 'earlier':\r\n        return possibleEpochNs[0];\r\n      case 'later':\r\n        return possibleEpochNs[numInstants - 1];\r\n      case 'reject': {\r\n        throw new RangeError('multiple instants found');\r\n      }\r\n    }\r\n  }\r\n\r\n  if (disambiguation === 'reject') throw new RangeError('multiple instants found');\r\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\r\n\r\n  const dayBefore = JSBI.subtract(utcns, DAY_NANOS_JSBI);\r\n  ValidateEpochNanoseconds(dayBefore);\r\n  const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\r\n  const dayAfter = JSBI.add(utcns, DAY_NANOS_JSBI);\r\n  ValidateEpochNanoseconds(dayAfter);\r\n  const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\r\n  const nanoseconds = offsetAfter - offsetBefore;\r\n  assert(Math.abs(nanoseconds) <= DAY_NANOS, 'UTC offset shift longer than 24 hours');\r\n\r\n  switch (disambiguation) {\r\n    case 'earlier': {\r\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, -nanoseconds);\r\n      const earlierTime = AddTime(isoDateTime.time, timeDuration);\r\n      const earlierDate = BalanceISODate(\r\n        isoDateTime.isoDate.year,\r\n        isoDateTime.isoDate.month,\r\n        isoDateTime.isoDate.day + earlierTime.deltaDays\r\n      );\r\n      const earlier = CombineISODateAndTimeRecord(earlierDate, earlierTime);\r\n      return GetPossibleEpochNanoseconds(timeZone, earlier)[0];\r\n    }\r\n    case 'compatible':\r\n    // fall through because 'compatible' means 'later' for \"spring forward\" transitions\r\n    case 'later': {\r\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, nanoseconds);\r\n      const laterTime = AddTime(isoDateTime.time, timeDuration);\r\n      const laterDate = BalanceISODate(\r\n        isoDateTime.isoDate.year,\r\n        isoDateTime.isoDate.month,\r\n        isoDateTime.isoDate.day + laterTime.deltaDays\r\n      );\r\n      const later = CombineISODateAndTimeRecord(laterDate, laterTime);\r\n      const possible = GetPossibleEpochNanoseconds(timeZone, later);\r\n      return possible[possible.length - 1];\r\n    }\r\n  }\r\n}\r\n\r\nfunction GetPossibleEpochNanoseconds(timeZone: string, isoDateTime: ISODateTime) {\r\n  // UTC fast path\r\n  if (timeZone === 'UTC') {\r\n    CheckISODaysRange(isoDateTime.isoDate);\r\n    return [GetUTCEpochNanoseconds(isoDateTime)];\r\n  }\r\n\r\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes;\r\n  if (offsetMinutes !== undefined) {\r\n    const balanced = BalanceISODateTime(\r\n      isoDateTime.isoDate.year,\r\n      isoDateTime.isoDate.month,\r\n      isoDateTime.isoDate.day,\r\n      isoDateTime.time.hour,\r\n      isoDateTime.time.minute - offsetMinutes,\r\n      isoDateTime.time.second,\r\n      isoDateTime.time.millisecond,\r\n      isoDateTime.time.microsecond,\r\n      isoDateTime.time.nanosecond\r\n    );\r\n    CheckISODaysRange(balanced.isoDate);\r\n    const epochNs = GetUTCEpochNanoseconds(balanced);\r\n    ValidateEpochNanoseconds(epochNs);\r\n    return [epochNs];\r\n  }\r\n\r\n  CheckISODaysRange(isoDateTime.isoDate);\r\n  return GetNamedTimeZoneEpochNanoseconds(timeZone, isoDateTime);\r\n}\r\n\r\nexport function GetStartOfDay(timeZone: string, isoDate: ISODate) {\r\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\r\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\r\n  // If not a DST gap, return the single or earlier epochNs\r\n  if (possibleEpochNs.length) return possibleEpochNs[0];\r\n\r\n  // Otherwise, 00:00:00 lies within a DST gap. Compute an epochNs that's\r\n  // guaranteed to be before the transition\r\n  assert(!IsOffsetTimeZoneIdentifier(timeZone), 'should only be reached with named time zone');\r\n\r\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\r\n  const dayBefore = JSBI.subtract(utcns, DAY_NANOS_JSBI);\r\n  ValidateEpochNanoseconds(dayBefore);\r\n  return castExists(GetNamedTimeZoneNextTransition(timeZone, dayBefore));\r\n}\r\n\r\nexport function ISOYearString(year: number) {\r\n  let yearString;\r\n  if (year < 0 || year > 9999) {\r\n    const sign = year < 0 ? '-' : '+';\r\n    const yearNumber = Math.abs(year);\r\n    yearString = sign + ToZeroPaddedDecimalString(yearNumber, 6);\r\n  } else {\r\n    yearString = ToZeroPaddedDecimalString(year, 4);\r\n  }\r\n  return yearString;\r\n}\r\n\r\nexport function ISODateTimePartString(part: number) {\r\n  return ToZeroPaddedDecimalString(part, 2);\r\n}\r\n\r\nfunction FormatFractionalSeconds(\r\n  subSecondNanoseconds: number,\r\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\r\n): string {\r\n  let fraction;\r\n  if (precision === 'auto') {\r\n    if (subSecondNanoseconds === 0) return '';\r\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\r\n    // now remove any trailing zeroes\r\n    fraction = fractionFullPrecision.replace(/0+$/, '');\r\n  } else {\r\n    if (precision === 0) return '';\r\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\r\n    fraction = fractionFullPrecision.slice(0, precision);\r\n  }\r\n  return `.${fraction}`;\r\n}\r\n\r\nfunction FormatTimeString(\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  subSecondNanoseconds: number,\r\n  precision: SecondsStringPrecisionRecord['precision']\r\n): string {\r\n  let result = `${ISODateTimePartString(hour)}:${ISODateTimePartString(minute)}`;\r\n  if (precision === 'minute') return result;\r\n\r\n  result += `:${ISODateTimePartString(second)}`;\r\n  result += FormatFractionalSeconds(subSecondNanoseconds, precision);\r\n  return result;\r\n}\r\n\r\nexport function TemporalInstantToString(\r\n  instant: Temporal.Instant,\r\n  timeZone: string | undefined,\r\n  precision: SecondsStringPrecisionRecord['precision']\r\n) {\r\n  let outputTimeZone = timeZone;\r\n  if (outputTimeZone === undefined) outputTimeZone = 'UTC';\r\n  const epochNs = GetSlot(instant, EPOCHNANOSECONDS);\r\n  const iso = GetISODateTimeFor(outputTimeZone, epochNs);\r\n  const dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\r\n  let timeZoneString = 'Z';\r\n  if (timeZone !== undefined) {\r\n    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, epochNs);\r\n    timeZoneString = FormatDateTimeUTCOffsetRounded(offsetNs);\r\n  }\r\n  return `${dateTimeString}${timeZoneString}`;\r\n}\r\n\r\ninterface ToStringOptions {\r\n  unit: SecondsStringPrecisionRecord['unit'];\r\n  increment: number;\r\n  roundingMode: ReturnType<typeof GetRoundingModeOption>;\r\n}\r\n\r\nexport function TemporalDurationToString(\r\n  duration: Temporal.Duration,\r\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\r\n) {\r\n  const years = GetSlot(duration, YEARS);\r\n  const months = GetSlot(duration, MONTHS);\r\n  const weeks = GetSlot(duration, WEEKS);\r\n  const days = GetSlot(duration, DAYS);\r\n  const hours = GetSlot(duration, HOURS);\r\n  const minutes = GetSlot(duration, MINUTES);\r\n  const sign = DurationSign(duration);\r\n\r\n  let datePart = '';\r\n  if (years !== 0) datePart += `${Math.abs(years)}Y`;\r\n  if (months !== 0) datePart += `${Math.abs(months)}M`;\r\n  if (weeks !== 0) datePart += `${Math.abs(weeks)}W`;\r\n  if (days !== 0) datePart += `${Math.abs(days)}D`;\r\n\r\n  let timePart = '';\r\n  if (hours !== 0) timePart += `${Math.abs(hours)}H`;\r\n  if (minutes !== 0) timePart += `${Math.abs(minutes)}M`;\r\n\r\n  // Keeping sub-second units separate avoids losing precision after resolving\r\n  // any overflows from rounding\r\n  const secondsDuration = TimeDuration.fromComponents(\r\n    0,\r\n    0,\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  );\r\n  if (\r\n    !secondsDuration.isZero() ||\r\n    ['second', 'millisecond', 'microsecond', 'nanosecond'].includes(DefaultTemporalLargestUnit(duration)) ||\r\n    precision !== 'auto'\r\n  ) {\r\n    const secondsPart = Math.abs(secondsDuration.sec);\r\n    const subSecondsPart = FormatFractionalSeconds(Math.abs(secondsDuration.subsec), precision);\r\n    timePart += `${secondsPart}${subSecondsPart}S`;\r\n  }\r\n  let result = `${sign < 0 ? '-' : ''}P${datePart}`;\r\n  if (timePart) result = `${result}T${timePart}`;\r\n  return result;\r\n}\r\n\r\nexport function TemporalDateToString(\r\n  date: Temporal.PlainDate,\r\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\r\n) {\r\n  const { year, month, day } = GetSlot(date, ISO_DATE);\r\n  const yearString = ISOYearString(year);\r\n  const monthString = ISODateTimePartString(month);\r\n  const dayString = ISODateTimePartString(day);\r\n  const calendar = FormatCalendarAnnotation(GetSlot(date, CALENDAR), showCalendar);\r\n  return `${yearString}-${monthString}-${dayString}${calendar}`;\r\n}\r\n\r\nexport function TimeRecordToString(\r\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\r\n  precision: SecondsStringPrecisionRecord['precision']\r\n) {\r\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\r\n  return FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\r\n}\r\n\r\nexport function ISODateTimeToString(\r\n  isoDateTime: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  precision: SecondsStringPrecisionRecord['precision'],\r\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto'\r\n) {\r\n  const {\r\n    isoDate: { year, month, day },\r\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\r\n  } = isoDateTime;\r\n  const yearString = ISOYearString(year);\r\n  const monthString = ISODateTimePartString(month);\r\n  const dayString = ISODateTimePartString(day);\r\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\r\n  const timeString = FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\r\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\r\n  return `${yearString}-${monthString}-${dayString}T${timeString}${calendarString}`;\r\n}\r\n\r\nexport function TemporalMonthDayToString(\r\n  monthDay: Temporal.PlainMonthDay,\r\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\r\n) {\r\n  const { year, month, day } = GetSlot(monthDay, ISO_DATE);\r\n  const monthString = ISODateTimePartString(month);\r\n  const dayString = ISODateTimePartString(day);\r\n  let resultString = `${monthString}-${dayString}`;\r\n  const calendar = GetSlot(monthDay, CALENDAR);\r\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\r\n    const yearString = ISOYearString(year);\r\n    resultString = `${yearString}-${resultString}`;\r\n  }\r\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\r\n  if (calendarString) resultString += calendarString;\r\n  return resultString;\r\n}\r\n\r\nexport function TemporalYearMonthToString(\r\n  yearMonth: Temporal.PlainYearMonth,\r\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\r\n) {\r\n  const { year, month, day } = GetSlot(yearMonth, ISO_DATE);\r\n  const yearString = ISOYearString(year);\r\n  const monthString = ISODateTimePartString(month);\r\n  let resultString = `${yearString}-${monthString}`;\r\n  const calendar = GetSlot(yearMonth, CALENDAR);\r\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\r\n    const dayString = ISODateTimePartString(day);\r\n    resultString += `-${dayString}`;\r\n  }\r\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\r\n  if (calendarString) resultString += calendarString;\r\n  return resultString;\r\n}\r\n\r\nexport function TemporalZonedDateTimeToString(\r\n  zdt: Temporal.ZonedDateTime,\r\n  precision: SecondsStringPrecisionRecord['precision'],\r\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto',\r\n  showTimeZone: ReturnType<typeof GetTemporalShowTimeZoneNameOption> = 'auto',\r\n  showOffset: ReturnType<typeof GetTemporalShowOffsetOption> = 'auto',\r\n  options: ToStringOptions | undefined = undefined\r\n) {\r\n  let epochNs = GetSlot(zdt, EPOCHNANOSECONDS);\r\n\r\n  if (options) {\r\n    const { unit, increment, roundingMode } = options;\r\n    epochNs = RoundTemporalInstant(epochNs, increment, unit, roundingMode);\r\n  }\r\n\r\n  const tz = GetSlot(zdt, TIME_ZONE);\r\n  const offsetNs = GetOffsetNanosecondsFor(tz, epochNs);\r\n  const iso = GetISODateTimeFor(tz, epochNs);\r\n  let dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\r\n  if (showOffset !== 'never') {\r\n    dateTimeString += FormatDateTimeUTCOffsetRounded(offsetNs);\r\n  }\r\n  if (showTimeZone !== 'never') {\r\n    const flag = showTimeZone === 'critical' ? '!' : '';\r\n    dateTimeString += `[${flag}${tz}]`;\r\n  }\r\n  dateTimeString += FormatCalendarAnnotation(GetSlot(zdt, CALENDAR), showCalendar);\r\n  return dateTimeString;\r\n}\r\n\r\nexport function IsOffsetTimeZoneIdentifier(string: string) {\r\n  return OFFSET_IDENTIFIER.test(string);\r\n}\r\n\r\nexport function ParseDateTimeUTCOffset(string: string): number {\r\n  const match = OFFSET_WITH_PARTS.exec(string);\r\n  if (!match) {\r\n    throw new RangeError(`invalid time zone offset: ${string}; must match ±HH:MM[:SS.SSSSSSSSS]`);\r\n  }\r\n  const sign = match[1] === '-' ? -1 : +1;\r\n  const hours = +match[2];\r\n  const minutes = +(match[3] || 0);\r\n  const seconds = +(match[4] || 0);\r\n  const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\r\n  const offsetNanoseconds = sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\r\n  return offsetNanoseconds;\r\n}\r\n\r\nlet canonicalTimeZoneIdsCache: Map<string, string> | undefined | null = undefined;\r\nconst isTZIDSep = Object.assign(Object.create(null), { '/': true, '-': true, _: true });\r\n\r\nexport function GetAvailableNamedTimeZoneIdentifier(\r\n  identifier: string\r\n): { identifier: string; primaryIdentifier: string } | undefined {\r\n  // The most common case is when the identifier is a canonical time zone ID.\r\n  // Fast-path that case by caching all canonical IDs. For old ECMAScript\r\n  // implementations lacking this API, set the cache to `null` to avoid retries.\r\n  if (canonicalTimeZoneIdsCache === undefined) {\r\n    const canonicalTimeZoneIds = Intl.supportedValuesOf?.('timeZone');\r\n    if (canonicalTimeZoneIds) {\r\n      canonicalTimeZoneIdsCache = new Map();\r\n      for (let ix = 0; ix < canonicalTimeZoneIds.length; ix++) {\r\n        const id = canonicalTimeZoneIds[ix];\r\n        canonicalTimeZoneIdsCache.set(ASCIILowercase(id), id);\r\n      }\r\n    } else {\r\n      canonicalTimeZoneIdsCache = null;\r\n    }\r\n  }\r\n\r\n  const lower = ASCIILowercase(identifier);\r\n  let primaryIdentifier = canonicalTimeZoneIdsCache?.get(lower);\r\n  if (primaryIdentifier) return { identifier: primaryIdentifier, primaryIdentifier };\r\n\r\n  // It's not already a primary identifier, so get its primary identifier (or\r\n  // return if it's not an available named time zone ID).\r\n  try {\r\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(identifier);\r\n    primaryIdentifier = formatter.resolvedOptions().timeZone;\r\n  } catch {\r\n    return undefined;\r\n  }\r\n\r\n  // Special case this legacy identifier that is listed both in `backzone` and\r\n  // `backward` in the TZDB. Work around implementations that incorrectly use\r\n  // the `backward` data.\r\n  if (lower === 'antarctica/south_pole') primaryIdentifier = 'Antarctica/McMurdo';\r\n\r\n  // Some legacy identifiers are aliases in ICU but not legal IANA identifiers.\r\n  // Reject them even if the implementation's Intl supports them, as they are\r\n  // not present in the IANA time zone database.\r\n  if (ICU_LEGACY_TIME_ZONE_IDS.has(identifier)) {\r\n    throw new RangeError(`${identifier} is a legacy time zone identifier from ICU. Use ${primaryIdentifier} instead`);\r\n  }\r\n\r\n  // The identifier is an alias (a deprecated identifier that's a synonym for a\r\n  // primary identifier), so we need to case-normalize the identifier to match\r\n  // the IANA TZDB, e.g. america/new_york => America/New_York. There's no\r\n  // built-in way to do this using Intl.DateTimeFormat, but the we can normalize\r\n  // almost all aliases (modulo a few special cases) using the TZDB's basic\r\n  // capitalization pattern:\r\n  // 1. capitalize the first letter of the identifier\r\n  // 2. capitalize the letter after every slash, dash, or underscore delimiter\r\n  const chars = [...lower].map((c, i) => (i === 0 || isTZIDSep[lower[i - 1]] ? c.toUpperCase() : c));\r\n  const standardCase = chars.join('');\r\n  const segments = standardCase.split('/');\r\n\r\n  if (segments.length === 1) {\r\n    // If a single-segment legacy ID is 2-3 chars or contains a number or dash, then\r\n    // (except for the \"GB-Eire\" special case) the case-normalized form is uppercase.\r\n    // These are: GMT+0, GMT-0, GB, NZ, PRC, ROC, ROK, UCT, GMT, GMT0, CET, CST6CDT,\r\n    // EET, EST, HST, MET, MST, MST7MDT, PST8PDT, WET, NZ-CHAT, and W-SU.\r\n    // Otherwise it's standard form: first letter capitalized, e.g. Iran, Egypt, Hongkong\r\n    if (lower === 'gb-eire') return { identifier: 'GB-Eire', primaryIdentifier };\r\n    return {\r\n      identifier: lower.length <= 3 || /[-0-9]/.test(lower) ? lower.toUpperCase() : segments[0],\r\n      primaryIdentifier\r\n    };\r\n  }\r\n\r\n  // All Etc zone names are uppercase except three exceptions.\r\n  if (segments[0] === 'Etc') {\r\n    const etcName = ['Zulu', 'Greenwich', 'Universal'].includes(segments[1]) ? segments[1] : segments[1].toUpperCase();\r\n    return { identifier: `Etc/${etcName}`, primaryIdentifier };\r\n  }\r\n\r\n  // Legacy US identifiers like US/Alaska or US/Indiana-Starke are 2 segments and use standard form.\r\n  if (segments[0] === 'Us') return { identifier: `US/${segments[1]}`, primaryIdentifier };\r\n\r\n  // For multi-segment IDs, there's a few special cases in the second/third segments\r\n  const specialCases = new Map([\r\n    ['Act', 'ACT'],\r\n    ['Lhi', 'LHI'],\r\n    ['Nsw', 'NSW'],\r\n    ['Dar_Es_Salaam', 'Dar_es_Salaam'],\r\n    ['Port_Of_Spain', 'Port_of_Spain'],\r\n    ['Port-Au-Prince', 'Port-au-Prince'],\r\n    ['Isle_Of_Man', 'Isle_of_Man'],\r\n    ['Comodrivadavia', 'ComodRivadavia'],\r\n    ['Knox_In', 'Knox_IN'],\r\n    ['Dumontdurville', 'DumontDUrville'],\r\n    ['Mcmurdo', 'McMurdo'],\r\n    ['Denoronha', 'DeNoronha'],\r\n    ['Easterisland', 'EasterIsland'],\r\n    ['Bajanorte', 'BajaNorte'],\r\n    ['Bajasur', 'BajaSur']\r\n  ]);\r\n  segments[1] = specialCases.get(segments[1]) ?? segments[1];\r\n  if (segments.length > 2) segments[2] = specialCases.get(segments[2]) ?? segments[2];\r\n  return { identifier: segments.join('/'), primaryIdentifier };\r\n}\r\n\r\nfunction GetNamedTimeZoneOffsetNanosecondsImpl(id: string, epochMilliseconds: number) {\r\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\r\n  let millisecond = epochMilliseconds % 1000;\r\n  if (millisecond < 0) millisecond += 1000;\r\n  const utc = GetUTCEpochMilliseconds({ isoDate: { year, month, day }, time: { hour, minute, second, millisecond } });\r\n  return (utc - epochMilliseconds) * 1e6;\r\n}\r\n\r\nfunction GetNamedTimeZoneOffsetNanoseconds(id: string, epochNanoseconds: JSBI) {\r\n  // Optimization: We get the offset nanoseconds only with millisecond\r\n  // resolution, assuming that time zone offset changes don't happen in the\r\n  // middle of a millisecond\r\n  return GetNamedTimeZoneOffsetNanosecondsImpl(id, epochNsToMs(epochNanoseconds, 'floor'));\r\n}\r\n\r\nexport function FormatOffsetTimeZoneIdentifier(offsetMinutes: number): string {\r\n  const sign = offsetMinutes < 0 ? '-' : '+';\r\n  const absoluteMinutes = Math.abs(offsetMinutes);\r\n  const hour = Math.floor(absoluteMinutes / 60);\r\n  const minute = absoluteMinutes % 60;\r\n  const timeString = FormatTimeString(hour, minute, 0, 0, 'minute');\r\n  return `${sign}${timeString}`;\r\n}\r\n\r\nfunction FormatDateTimeUTCOffsetRounded(offsetNanosecondsParam: number): string {\r\n  const offsetNanoseconds = RoundNumberToIncrement(offsetNanosecondsParam, MINUTE_NANOS, 'halfExpand');\r\n  return FormatOffsetTimeZoneIdentifier(offsetNanoseconds / 60e9);\r\n}\r\n\r\nfunction GetUTCEpochMilliseconds({\r\n  isoDate: { year, month, day },\r\n  time: { hour, minute, second, millisecond }\r\n}: {\r\n  isoDate: ISODate;\r\n  time: Omit<TimeRecord, 'microsecond' | 'nanosecond'>;\r\n}) {\r\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\r\n  // years. To avoid overflowing at the edges of the range, we reduce the year\r\n  // to the remainder after dividing by 400, and then add back all the\r\n  // nanoseconds from the multiples of 400 years at the end.\r\n  const reducedYear = year % 400;\r\n  const yearCycles = (year - reducedYear) / 400;\r\n\r\n  // Note: Date.UTC() interprets one and two-digit years as being in the\r\n  // 20th century, so don't use it\r\n  const legacyDate = new Date();\r\n  legacyDate.setUTCHours(hour, minute, second, millisecond);\r\n  legacyDate.setUTCFullYear(reducedYear, month - 1, day);\r\n  const ms = legacyDate.getTime();\r\n  return ms + MS_IN_400_YEAR_CYCLE * yearCycles;\r\n}\r\n\r\nfunction GetUTCEpochNanoseconds(isoDateTime: ISODateTime) {\r\n  const ms = GetUTCEpochMilliseconds(isoDateTime);\r\n  const subMs = isoDateTime.time.microsecond * 1e3 + isoDateTime.time.nanosecond;\r\n  return JSBI.add(epochMsToNs(ms), JSBI.BigInt(subMs));\r\n}\r\n\r\nfunction GetISOPartsFromEpoch(epochNanoseconds: JSBI) {\r\n  let epochMilliseconds = epochNsToMs(epochNanoseconds, 'trunc');\r\n  let nanos = JSBI.toNumber(JSBI.remainder(epochNanoseconds, MILLION));\r\n  if (nanos < 0) {\r\n    nanos += 1e6;\r\n    epochMilliseconds -= 1;\r\n  }\r\n  const microsecond = Math.floor(nanos / 1e3) % 1e3;\r\n  const nanosecond = nanos % 1e3;\r\n\r\n  const item = new Date(epochMilliseconds);\r\n  const year = item.getUTCFullYear();\r\n  const month = item.getUTCMonth() + 1;\r\n  const day = item.getUTCDate();\r\n  const hour = item.getUTCHours();\r\n  const minute = item.getUTCMinutes();\r\n  const second = item.getUTCSeconds();\r\n  const millisecond = item.getUTCMilliseconds();\r\n\r\n  return {\r\n    epochMilliseconds,\r\n    isoDate: { year, month, day },\r\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\r\n  };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function GetNamedTimeZoneDateTimeParts(id: string, epochNanoseconds: JSBI) {\r\n  const {\r\n    epochMilliseconds,\r\n    time: { millisecond, microsecond, nanosecond }\r\n  } = GetISOPartsFromEpoch(epochNanoseconds);\r\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\r\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\r\n}\r\n\r\n// Most time zones never transition twice within a short span of days. We still\r\n// accommodate twitchy zones, albeit at a performance penalty. 19 days is the\r\n// default window, past which we'd need to start adding many more special cases.\r\nfunction searchWindowForTransitions(id: string) {\r\n  if (id === 'Africa/El_Aaiun') return DAY_MS * 17;\r\n  if (id === 'America/Argentina/Tucuman') return DAY_MS * 12;\r\n  if (id === 'Europe/Tirane') return DAY_MS * 11;\r\n  if (id === 'Europe/Riga') return DAY_MS * 10;\r\n  if (id === 'Europe/Simferopol' || id === 'Europe/Vienna') return DAY_MS * 9;\r\n  if (id === 'Africa/Tunis') return DAY_MS * 8;\r\n  if (\r\n    id === 'America/Boa_Vista' ||\r\n    id === 'America/Fortaleza' ||\r\n    id === 'America/Maceio' ||\r\n    id === 'America/Noronha' ||\r\n    id === 'America/Recife' ||\r\n    id === 'Asia/Gaza' || // dubious, only in future calculations\r\n    id === 'Asia/Hebron' || // ditto\r\n    id === 'Brazil/DeNoronha'\r\n  ) {\r\n    return DAY_MS * 6;\r\n  }\r\n  return DAY_MS * 19;\r\n}\r\n\r\nexport function GetNamedTimeZoneNextTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\r\n  if (id === 'UTC') return null; // UTC fast path\r\n\r\n  // Optimization: we floor the instant to the previous millisecond boundary\r\n  // so that we can do Number math instead of BigInt math. This assumes that\r\n  // time zone transitions don't happen in the middle of a millisecond.\r\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'floor');\r\n  if (epochMilliseconds < BEFORE_FIRST_DST) {\r\n    return GetNamedTimeZoneNextTransition(id, epochMsToNs(BEFORE_FIRST_DST));\r\n  }\r\n\r\n  // Optimization: the farthest that we'll look for a next transition is 3 years\r\n  // after the later of epochNanoseconds or the current time. If there are no\r\n  // transitions found before then, we'll assume that there will not be any more\r\n  // transitions after that.\r\n  const now = Date.now();\r\n  const base = Math.max(epochMilliseconds, now);\r\n  const uppercap = base + DAY_MS * 366 * 3;\r\n  let leftMs = epochMilliseconds;\r\n  let leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\r\n  let rightMs = leftMs;\r\n  let rightOffsetNs = leftOffsetNs;\r\n  const searchWindow = searchWindowForTransitions(id);\r\n  while (leftOffsetNs === rightOffsetNs && leftMs < uppercap) {\r\n    rightMs = leftMs + searchWindow;\r\n    if (rightMs > MS_MAX) return null;\r\n    rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\r\n    if (leftOffsetNs === rightOffsetNs) {\r\n      leftMs = rightMs;\r\n    }\r\n  }\r\n  if (leftOffsetNs === rightOffsetNs) return null;\r\n  const result = bisect(\r\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\r\n    leftMs,\r\n    rightMs,\r\n    leftOffsetNs,\r\n    rightOffsetNs\r\n  );\r\n  return epochMsToNs(result);\r\n}\r\n\r\nexport function GetNamedTimeZonePreviousTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\r\n  if (id === 'UTC') return null; // UTC fast path\r\n\r\n  // Optimization: we raise the instant to the next millisecond boundary so\r\n  // that we can do Number math instead of BigInt math. This assumes that time\r\n  // zone transitions don't happen in the middle of a millisecond.\r\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'ceil');\r\n\r\n  // Optimization: if the instant is more than 3 years in the future and there\r\n  // are no transitions between the present day and 3 years from now, assume\r\n  // there are none after.\r\n  const now = Date.now();\r\n  const lookahead = now + DAY_MS * 366 * 3;\r\n  if (epochMilliseconds > lookahead) {\r\n    const prevBeforeLookahead = GetNamedTimeZonePreviousTransition(id, epochMsToNs(lookahead));\r\n    if (prevBeforeLookahead === null || JSBI.lessThan(prevBeforeLookahead, epochMsToNs(now))) {\r\n      return prevBeforeLookahead;\r\n    }\r\n  }\r\n\r\n  // We assume most time zones either have regular DST rules that extend\r\n  // indefinitely into the future, or they have no DST transitions between now\r\n  // and next year. Africa/Casablanca and Africa/El_Aaiun are unique cases\r\n  // that fit neither of these. Their irregular DST transitions are\r\n  // precomputed until 2087 in the current time zone database, so requesting\r\n  // the previous transition for an instant far in the future may take an\r\n  // extremely long time as it loops backward 2 weeks at a time.\r\n  if (id === 'Africa/Casablanca' || id === 'Africa/El_Aaiun') {\r\n    const lastPrecomputed = Date.UTC(2088, 0, 1); // 2088-01-01T00Z\r\n    if (lastPrecomputed < epochMilliseconds) {\r\n      return GetNamedTimeZonePreviousTransition(id, epochMsToNs(lastPrecomputed));\r\n    }\r\n  }\r\n\r\n  let rightMs = epochMilliseconds - 1;\r\n  if (rightMs < BEFORE_FIRST_DST) return null;\r\n  let rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\r\n  let leftMs = rightMs;\r\n  let leftOffsetNs = rightOffsetNs;\r\n  const searchWindow = searchWindowForTransitions(id);\r\n  while (rightOffsetNs === leftOffsetNs && rightMs > BEFORE_FIRST_DST) {\r\n    leftMs = rightMs - searchWindow;\r\n    if (leftMs < BEFORE_FIRST_DST) return null;\r\n    leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\r\n    if (rightOffsetNs === leftOffsetNs) {\r\n      rightMs = leftMs;\r\n    }\r\n  }\r\n  if (rightOffsetNs === leftOffsetNs) return null;\r\n  const result = bisect(\r\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\r\n    leftMs,\r\n    rightMs,\r\n    leftOffsetNs,\r\n    rightOffsetNs\r\n  );\r\n  return epochMsToNs(result);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function parseFromEnUsFormat(datetime: string) {\r\n  const splits = datetime.split(/[^\\w]+/);\r\n\r\n  if (splits.length !== 7) {\r\n    throw new RangeError(`expected 7 parts in \"${datetime}`);\r\n  }\r\n\r\n  const month = +splits[0];\r\n  const day = +splits[1];\r\n  let year = +splits[2];\r\n  const era = splits[3];\r\n  if (era[0] === 'b' || era[0] === 'B') {\r\n    year = -year + 1;\r\n  } else if (era[0] !== 'a' && era[0] !== 'A') {\r\n    throw new RangeError(`Unknown era ${era} in \"${datetime}`);\r\n  }\r\n  const hour = splits[4] === '24' ? 0 : +splits[4]; // bugs.chromium.org/p/chromium/issues/detail?id=1045791\r\n  const minute = +splits[5];\r\n  const second = +splits[6];\r\n\r\n  if (\r\n    !Number.isFinite(year) ||\r\n    !Number.isFinite(month) ||\r\n    !Number.isFinite(day) ||\r\n    !Number.isFinite(hour) ||\r\n    !Number.isFinite(minute) ||\r\n    !Number.isFinite(second)\r\n  ) {\r\n    throw new RangeError(`Invalid number in \"${datetime}`);\r\n  }\r\n\r\n  return { year, month, day, hour, minute, second };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function GetFormatterParts(timeZone: string, epochMilliseconds: number) {\r\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\r\n  // Using `format` instead of `formatToParts` for compatibility with older\r\n  // clients and because it is twice as fast\r\n  const datetime = formatter.format(epochMilliseconds);\r\n  return parseFromEnUsFormat(datetime);\r\n}\r\n\r\n// The goal of this function is to find the exact time(s) that correspond to a\r\n// calendar date and clock time in a particular time zone. Normally there will\r\n// be only one match. But for repeated clock times after backwards transitions\r\n// (like when DST ends) there may be two matches. And for skipped clock times\r\n// after forward transitions, there will be no matches.\r\nfunction GetNamedTimeZoneEpochNanoseconds(id: string, isoDateTime: ISODateTime) {\r\n  // Get the offset of one day before and after the requested calendar date and\r\n  // clock time, avoiding overflows if near the edge of the Instant range.\r\n  let ns = GetUTCEpochNanoseconds(isoDateTime);\r\n  let nsEarlier = JSBI.subtract(ns, DAY_NANOS_JSBI);\r\n  if (JSBI.lessThan(nsEarlier, NS_MIN)) nsEarlier = ns;\r\n  let nsLater = JSBI.add(ns, DAY_NANOS_JSBI);\r\n  if (JSBI.greaterThan(nsLater, NS_MAX)) nsLater = ns;\r\n  const earlierOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsEarlier);\r\n  const laterOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsLater);\r\n\r\n  // If before and after offsets are the same, then we assume there was no\r\n  // offset transition in between, and therefore only one exact time can\r\n  // correspond to the provided calendar date and clock time. But if they're\r\n  // different, then there was an offset transition in between, so test both\r\n  // offsets to see which one(s) will yield a matching exact time.\r\n  const found = earlierOffsetNs === laterOffsetNs ? [earlierOffsetNs] : [earlierOffsetNs, laterOffsetNs];\r\n  const candidates = found.map((offsetNanoseconds) => {\r\n    const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\r\n    const parts = GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\r\n    if (CompareISODateTime(isoDateTime, parts) !== 0) return undefined;\r\n    ValidateEpochNanoseconds(epochNanoseconds);\r\n    return epochNanoseconds;\r\n  });\r\n  return candidates.filter((x) => x !== undefined) as JSBI[];\r\n}\r\n\r\nexport function LeapYear(year: number) {\r\n  if (undefined === year) return false;\r\n  const isDiv4 = year % 4 === 0;\r\n  const isDiv100 = year % 100 === 0;\r\n  const isDiv400 = year % 400 === 0;\r\n  return isDiv4 && (!isDiv100 || isDiv400);\r\n}\r\n\r\nexport function ISODaysInMonth(year: number, month: number) {\r\n  const DoM = {\r\n    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\r\n    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\r\n  };\r\n  return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\r\n}\r\n\r\nexport function DurationSign(duration: Temporal.Duration) {\r\n  const fields = [\r\n    GetSlot(duration, YEARS),\r\n    GetSlot(duration, MONTHS),\r\n    GetSlot(duration, WEEKS),\r\n    GetSlot(duration, DAYS),\r\n    GetSlot(duration, HOURS),\r\n    GetSlot(duration, MINUTES),\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  ];\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const prop = fields[index];\r\n    if (prop !== 0) return prop < 0 ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction DateDurationSign(dateDuration: DateDuration) {\r\n  const fieldNames = ['years', 'months', 'weeks', 'days'] as const;\r\n  for (let index = 0; index < fieldNames.length; index++) {\r\n    const prop = dateDuration[fieldNames[index]];\r\n    if (prop !== 0) return prop < 0 ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction InternalDurationSign(duration: InternalDuration) {\r\n  const dateSign = DateDurationSign(duration.date);\r\n  if (dateSign !== 0) return dateSign;\r\n  return duration.time.sign();\r\n}\r\n\r\nexport function BalanceISOYearMonth(yearParam: number, monthParam: number) {\r\n  let year = yearParam;\r\n  let month = monthParam;\r\n  if (!Number.isFinite(year) || !Number.isFinite(month)) throw new RangeError('infinity is out of range');\r\n  month -= 1;\r\n  year += Math.floor(month / 12);\r\n  month %= 12;\r\n  if (month < 0) month += 12;\r\n  month += 1;\r\n  return { year, month };\r\n}\r\n\r\nexport function BalanceISODate(yearParam: number, monthParam: number, dayParam: number) {\r\n  let year = yearParam;\r\n  let month = monthParam;\r\n  let day = dayParam;\r\n  if (!Number.isFinite(day)) throw new RangeError('infinity is out of range');\r\n  ({ year, month } = BalanceISOYearMonth(year, month));\r\n\r\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\r\n  // years. So if we have more than 400 years in days, there's no need to\r\n  // convert days to a year 400 times. We can convert a multiple of 400 all at\r\n  // once.\r\n  const daysIn400YearCycle = 400 * 365 + 97;\r\n  if (Math.abs(day) > daysIn400YearCycle) {\r\n    const nCycles = Math.trunc(day / daysIn400YearCycle);\r\n    year += 400 * nCycles;\r\n    day -= nCycles * daysIn400YearCycle;\r\n  }\r\n\r\n  let daysInYear = 0;\r\n  let testYear = month > 2 ? year : year - 1;\r\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\r\n    year -= 1;\r\n    testYear -= 1;\r\n    day += daysInYear;\r\n  }\r\n  testYear += 1;\r\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\r\n    year += 1;\r\n    testYear += 1;\r\n    day -= daysInYear;\r\n  }\r\n\r\n  while (day < 1) {\r\n    ({ year, month } = BalanceISOYearMonth(year, month - 1));\r\n    day += ISODaysInMonth(year, month);\r\n  }\r\n  while (day > ISODaysInMonth(year, month)) {\r\n    day -= ISODaysInMonth(year, month);\r\n    ({ year, month } = BalanceISOYearMonth(year, month + 1));\r\n  }\r\n\r\n  return { year, month, day };\r\n}\r\n\r\nfunction BalanceISODateTime(\r\n  year: number,\r\n  month: number,\r\n  day: number,\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  millisecond: number,\r\n  microsecond: number,\r\n  nanosecond: number\r\n) {\r\n  const time = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\r\n  return CombineISODateAndTimeRecord(isoDate, time);\r\n}\r\n\r\nfunction BalanceTime(\r\n  hourParam: number,\r\n  minuteParam: number,\r\n  secondParam: number,\r\n  millisecondParam: number,\r\n  microsecondParam: number,\r\n  nanosecondParam: number\r\n) {\r\n  let hour = hourParam;\r\n  let minute = minuteParam;\r\n  let second = secondParam;\r\n  let millisecond = millisecondParam;\r\n  let microsecond = microsecondParam;\r\n  let nanosecond = nanosecondParam;\r\n  let div;\r\n\r\n  ({ div, mod: nanosecond } = TruncatingDivModByPowerOf10(nanosecond, 3));\r\n  microsecond += div;\r\n  if (nanosecond < 0) {\r\n    microsecond -= 1;\r\n    nanosecond += 1000;\r\n  }\r\n\r\n  ({ div, mod: microsecond } = TruncatingDivModByPowerOf10(microsecond, 3));\r\n  millisecond += div;\r\n  if (microsecond < 0) {\r\n    millisecond -= 1;\r\n    microsecond += 1000;\r\n  }\r\n\r\n  second += Math.trunc(millisecond / 1000);\r\n  millisecond %= 1000;\r\n  if (millisecond < 0) {\r\n    second -= 1;\r\n    millisecond += 1000;\r\n  }\r\n\r\n  minute += Math.trunc(second / 60);\r\n  second %= 60;\r\n  if (second < 0) {\r\n    minute -= 1;\r\n    second += 60;\r\n  }\r\n\r\n  hour += Math.trunc(minute / 60);\r\n  minute %= 60;\r\n  if (minute < 0) {\r\n    hour -= 1;\r\n    minute += 60;\r\n  }\r\n\r\n  let deltaDays = Math.trunc(hour / 24);\r\n  hour %= 24;\r\n  if (hour < 0) {\r\n    deltaDays -= 1;\r\n    hour += 24;\r\n  }\r\n\r\n  // Results are possibly -0 at this point, but these are mathematical values in\r\n  // the spec. Force -0 to +0.\r\n  deltaDays += 0;\r\n  hour += 0;\r\n  minute += 0;\r\n  second += 0;\r\n  millisecond += 0;\r\n  microsecond += 0;\r\n  nanosecond += 0;\r\n\r\n  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\r\n}\r\n\r\nexport function DateDurationDays(dateDuration: DateDuration, plainRelativeTo: Temporal.PlainDate) {\r\n  const yearsMonthsWeeksDuration = AdjustDateDurationRecord(dateDuration, 0);\r\n  if (DateDurationSign(yearsMonthsWeeksDuration) === 0) return dateDuration.days;\r\n\r\n  // balance years, months, and weeks down to days\r\n  const isoDate = GetSlot(plainRelativeTo, ISO_DATE);\r\n  const later = CalendarDateAdd(GetSlot(plainRelativeTo, CALENDAR), isoDate, yearsMonthsWeeksDuration, 'constrain');\r\n  const epochDaysEarlier = ISODateToEpochDays(isoDate.year, isoDate.month - 1, isoDate.day);\r\n  const epochDaysLater = ISODateToEpochDays(later.year, later.month - 1, later.day);\r\n  const yearsMonthsWeeksInDays = epochDaysLater - epochDaysEarlier;\r\n  return dateDuration.days + yearsMonthsWeeksInDays;\r\n}\r\n\r\nexport function CreateNegatedTemporalDuration(duration: Temporal.Duration) {\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  return new TemporalDuration(\r\n    -GetSlot(duration, YEARS),\r\n    -GetSlot(duration, MONTHS),\r\n    -GetSlot(duration, WEEKS),\r\n    -GetSlot(duration, DAYS),\r\n    -GetSlot(duration, HOURS),\r\n    -GetSlot(duration, MINUTES),\r\n    -GetSlot(duration, SECONDS),\r\n    -GetSlot(duration, MILLISECONDS),\r\n    -GetSlot(duration, MICROSECONDS),\r\n    -GetSlot(duration, NANOSECONDS)\r\n  );\r\n}\r\n\r\nexport function ConstrainToRange(value: number | undefined, min: number, max: number) {\r\n  // Math.Max accepts undefined values and returns NaN. Undefined values are\r\n  // used for optional params in the method below.\r\n  return Math.min(max, Math.max(min, value as number));\r\n}\r\nexport function ConstrainISODate(year: number, monthParam: number, dayParam?: number) {\r\n  const month = ConstrainToRange(monthParam, 1, 12);\r\n  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\r\n  return { year, month, day };\r\n}\r\n\r\nexport function RejectToRange(value: number, min: number, max: number) {\r\n  if (value < min || value > max) throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\r\n}\r\n\r\nexport function RejectISODate(year: number, month: number, day: number) {\r\n  RejectToRange(month, 1, 12);\r\n  RejectToRange(day, 1, ISODaysInMonth(year, month));\r\n}\r\n\r\nfunction RejectDateRange(isoDate: ISODate) {\r\n  // Noon avoids trouble at edges of DateTime range (excludes midnight)\r\n  RejectDateTimeRange(CombineISODateAndTimeRecord(isoDate, NoonTimeRecord()));\r\n}\r\n\r\nexport function RejectTime(\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  millisecond: number,\r\n  microsecond: number,\r\n  nanosecond: number\r\n) {\r\n  RejectToRange(hour, 0, 23);\r\n  RejectToRange(minute, 0, 59);\r\n  RejectToRange(second, 0, 59);\r\n  RejectToRange(millisecond, 0, 999);\r\n  RejectToRange(microsecond, 0, 999);\r\n  RejectToRange(nanosecond, 0, 999);\r\n}\r\n\r\nexport function RejectDateTime(\r\n  year: number,\r\n  month: number,\r\n  day: number,\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  millisecond: number,\r\n  microsecond: number,\r\n  nanosecond: number\r\n) {\r\n  RejectISODate(year, month, day);\r\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n}\r\n\r\nexport function RejectDateTimeRange(isoDateTime: ISODateTime) {\r\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\r\n  if (JSBI.lessThan(ns, DATETIME_NS_MIN) || JSBI.greaterThan(ns, DATETIME_NS_MAX)) {\r\n    // Because PlainDateTime's range is wider than Instant's range, the line\r\n    // below will always throw. Calling `ValidateEpochNanoseconds` avoids\r\n    // repeating the same error message twice.\r\n    ValidateEpochNanoseconds(ns);\r\n  }\r\n}\r\n\r\n// Same as above, but throws a different, non-user-facing error\r\nfunction AssertISODateTimeWithinLimits(isoDateTime: ISODateTime) {\r\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\r\n  assert(\r\n    JSBI.greaterThanOrEqual(ns, DATETIME_NS_MIN) && JSBI.lessThanOrEqual(ns, DATETIME_NS_MAX),\r\n    `${ISODateTimeToString(isoDateTime, 'iso8601', 'auto')} is outside the representable range`\r\n  );\r\n}\r\n\r\n// In the spec, IsValidEpochNanoseconds returns a boolean and call sites are\r\n// responsible for throwing. In the polyfill, ValidateEpochNanoseconds takes its\r\n// place so that we can DRY the throwing code.\r\nfunction ValidateEpochNanoseconds(epochNanoseconds: JSBI) {\r\n  if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\r\n    throw new RangeError('date/time value is outside of supported range');\r\n  }\r\n}\r\n\r\nfunction RejectYearMonthRange({ year, month }: Omit<ISODate, 'day'>) {\r\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\r\n  if (year === YEAR_MIN) {\r\n    RejectToRange(month, 4, 12);\r\n  } else if (year === YEAR_MAX) {\r\n    RejectToRange(month, 1, 9);\r\n  }\r\n}\r\n\r\nexport function RejectDuration(\r\n  y: number,\r\n  mon: number,\r\n  w: number,\r\n  d: number,\r\n  h: number,\r\n  min: number,\r\n  s: number,\r\n  ms: number,\r\n  µs: number,\r\n  ns: number\r\n) {\r\n  let sign: -1 | 0 | 1 = 0;\r\n  const fields = [y, mon, w, d, h, min, s, ms, µs, ns];\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const prop = fields[index];\r\n    if (prop === Infinity || prop === -Infinity) throw new RangeError('infinite values not allowed as duration fields');\r\n    if (prop !== 0) {\r\n      const propSign = prop < 0 ? -1 : 1;\r\n      if (sign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\r\n      sign = propSign;\r\n    }\r\n  }\r\n  if (Math.abs(y) >= 2 ** 32 || Math.abs(mon) >= 2 ** 32 || Math.abs(w) >= 2 ** 32) {\r\n    throw new RangeError('years, months, and weeks must be < 2³²');\r\n  }\r\n  const msResult = TruncatingDivModByPowerOf10(ms, 3);\r\n  const µsResult = TruncatingDivModByPowerOf10(µs, 6);\r\n  const nsResult = TruncatingDivModByPowerOf10(ns, 9);\r\n  const remainderSec = TruncatingDivModByPowerOf10(msResult.mod * 1e6 + µsResult.mod * 1e3 + nsResult.mod, 9).div;\r\n  const totalSec = d * 86400 + h * 3600 + min * 60 + s + msResult.div + µsResult.div + nsResult.div + remainderSec;\r\n  if (!Number.isSafeInteger(totalSec)) {\r\n    throw new RangeError('total of duration time units cannot exceed 9007199254740991.999999999 s');\r\n  }\r\n}\r\n\r\nexport function ToInternalDurationRecord(duration: Temporal.Duration) {\r\n  const date = {\r\n    years: GetSlot(duration, YEARS),\r\n    months: GetSlot(duration, MONTHS),\r\n    weeks: GetSlot(duration, WEEKS),\r\n    days: GetSlot(duration, DAYS)\r\n  };\r\n  const time = TimeDuration.fromComponents(\r\n    GetSlot(duration, HOURS),\r\n    GetSlot(duration, MINUTES),\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  );\r\n  return { date, time };\r\n}\r\n\r\nexport function ToInternalDurationRecordWith24HourDays(duration: Temporal.Duration) {\r\n  const time = TimeDuration.fromComponents(\r\n    GetSlot(duration, HOURS),\r\n    GetSlot(duration, MINUTES),\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  ).add24HourDays(GetSlot(duration, DAYS));\r\n  const date = {\r\n    years: GetSlot(duration, YEARS),\r\n    months: GetSlot(duration, MONTHS),\r\n    weeks: GetSlot(duration, WEEKS),\r\n    days: 0\r\n  };\r\n  return { date, time };\r\n}\r\n\r\nfunction ToDateDurationRecordWithoutTime(duration: Temporal.Duration) {\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n  const days = Math.trunc(internalDuration.time.sec / 86400);\r\n  RejectDuration(\r\n    internalDuration.date.years,\r\n    internalDuration.date.months,\r\n    internalDuration.date.weeks,\r\n    days,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    0\r\n  );\r\n  return { ...internalDuration.date, days };\r\n}\r\n\r\nexport function TemporalDurationFromInternal(internalDuration: InternalDuration, largestUnit: Temporal.DateTimeUnit) {\r\n  const sign = internalDuration.time.sign();\r\n  let nanoseconds = internalDuration.time.abs().subsec;\r\n  let microseconds = 0;\r\n  let milliseconds = 0;\r\n  let seconds = internalDuration.time.abs().sec;\r\n  let minutes = 0;\r\n  let hours = 0;\r\n  let days = 0;\r\n\r\n  switch (largestUnit) {\r\n    case 'year':\r\n    case 'month':\r\n    case 'week':\r\n    case 'day':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      minutes = Math.trunc(seconds / 60);\r\n      seconds %= 60;\r\n      hours = Math.trunc(minutes / 60);\r\n      minutes %= 60;\r\n      days = Math.trunc(hours / 24);\r\n      hours %= 24;\r\n      break;\r\n    case 'hour':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      minutes = Math.trunc(seconds / 60);\r\n      seconds %= 60;\r\n      hours = Math.trunc(minutes / 60);\r\n      minutes %= 60;\r\n      break;\r\n    case 'minute':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      minutes = Math.trunc(seconds / 60);\r\n      seconds %= 60;\r\n      break;\r\n    case 'second':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      break;\r\n    case 'millisecond':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = FMAPowerOf10(seconds, 3, Math.trunc(microseconds / 1000));\r\n      microseconds %= 1000;\r\n      seconds = 0;\r\n      break;\r\n    case 'microsecond':\r\n      microseconds = FMAPowerOf10(seconds, 6, Math.trunc(nanoseconds / 1000));\r\n      nanoseconds %= 1000;\r\n      seconds = 0;\r\n      break;\r\n    case 'nanosecond':\r\n      nanoseconds = FMAPowerOf10(seconds, 9, nanoseconds);\r\n      seconds = 0;\r\n      break;\r\n    default:\r\n      /* c8 ignore next */ assertNotReached();\r\n  }\r\n\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  return new TemporalDuration(\r\n    internalDuration.date.years,\r\n    internalDuration.date.months,\r\n    internalDuration.date.weeks,\r\n    internalDuration.date.days + sign * days,\r\n    sign * hours,\r\n    sign * minutes,\r\n    sign * seconds,\r\n    sign * milliseconds,\r\n    sign * microseconds,\r\n    sign * nanoseconds\r\n  );\r\n}\r\n\r\nexport function CombineDateAndTimeDuration(dateDuration: DateDuration, timeDuration: TimeDuration) {\r\n  const dateSign = DateDurationSign(dateDuration);\r\n  const timeSign = timeDuration.sign();\r\n  assert(\r\n    dateSign === 0 || timeSign === 0 || dateSign === timeSign,\r\n    'should not be able to create mixed sign duration fields here'\r\n  );\r\n  return { date: dateDuration, time: timeDuration };\r\n}\r\n\r\n// Caution: month is 0-based\r\nexport function ISODateToEpochDays(year: number, month: number, day: number) {\r\n  return (\r\n    GetUTCEpochMilliseconds({\r\n      isoDate: { year, month: month + 1, day },\r\n      time: { hour: 0, minute: 0, second: 0, millisecond: 0 }\r\n    }) / DAY_MS\r\n  );\r\n}\r\n\r\n// This is needed before calling GetUTCEpochNanoseconds, because it uses MakeDay\r\n// which is ill-defined in how it handles large year numbers. If the issue\r\n// https://github.com/tc39/ecma262/issues/1087 is fixed, this can be removed\r\n// with no observable changes.\r\nfunction CheckISODaysRange({ year, month, day }: ISODate) {\r\n  if (Math.abs(ISODateToEpochDays(year, month - 1, day)) > 1e8) {\r\n    throw new RangeError('date/time value is outside the supported range');\r\n  }\r\n}\r\n\r\nfunction DifferenceTime(time1: TimeRecord, time2: TimeRecord) {\r\n  const hours = time2.hour - time1.hour;\r\n  const minutes = time2.minute - time1.minute;\r\n  const seconds = time2.second - time1.second;\r\n  const milliseconds = time2.millisecond - time1.millisecond;\r\n  const microseconds = time2.microsecond - time1.microsecond;\r\n  const nanoseconds = time2.nanosecond - time1.nanosecond;\r\n  const timeDuration = TimeDuration.fromComponents(hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n  assert(timeDuration.abs().sec < 86400, '_bt_.[[Days]] should be 0');\r\n  return timeDuration;\r\n}\r\n\r\nfunction DifferenceInstant(\r\n  ns1: JSBI,\r\n  ns2: JSBI,\r\n  increment: number,\r\n  smallestUnit: Temporal.TimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  let timeDuration = TimeDuration.fromEpochNsDiff(ns2, ns1);\r\n  timeDuration = RoundTimeDuration(timeDuration, increment, smallestUnit, roundingMode);\r\n  return CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\r\n}\r\n\r\nfunction DifferenceISODateTime(\r\n  isoDateTime1: ISODateTime,\r\n  isoDateTime2: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit\r\n) {\r\n  AssertISODateTimeWithinLimits(isoDateTime1);\r\n  AssertISODateTimeWithinLimits(isoDateTime2);\r\n  let timeDuration = DifferenceTime(isoDateTime1.time, isoDateTime2.time);\r\n\r\n  const timeSign = timeDuration.sign();\r\n  const dateSign = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\r\n\r\n  // back-off a day from date2 so that the signs of the date and time diff match\r\n  let adjustedDate = isoDateTime2.isoDate;\r\n  if (dateSign === timeSign) {\r\n    adjustedDate = BalanceISODate(adjustedDate.year, adjustedDate.month, adjustedDate.day + timeSign);\r\n    timeDuration = timeDuration.add24HourDays(-timeSign);\r\n  }\r\n\r\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\r\n  const dateDifference = CalendarDateUntil(calendar, isoDateTime1.isoDate, adjustedDate, dateLargestUnit);\r\n  if (largestUnit !== dateLargestUnit) {\r\n    // largestUnit < days, so add the days in to the internal duration\r\n    timeDuration = timeDuration.add24HourDays(dateDifference.days);\r\n    dateDifference.days = 0;\r\n  }\r\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\r\n}\r\n\r\nfunction DifferenceZonedDateTime(\r\n  ns1: JSBI,\r\n  ns2: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit\r\n) {\r\n  const nsDiff = JSBI.subtract(ns2, ns1);\r\n  if (JSBI.equal(nsDiff, ZERO)) return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\r\n  const sign = JSBI.lessThan(nsDiff, ZERO) ? -1 : 1;\r\n\r\n  // Convert start/end instants to datetimes\r\n  const isoDtStart = GetISODateTimeFor(timeZone, ns1);\r\n  const isoDtEnd = GetISODateTimeFor(timeZone, ns2);\r\n\r\n  // Simulate moving ns1 as many years/months/weeks/days as possible without\r\n  // surpassing ns2. This value is stored in intermediateDateTime/intermediateInstant/intermediateNs.\r\n  // We do not literally move years/months/weeks/days with calendar arithmetic,\r\n  // but rather assume intermediateDateTime will have the same time-parts as\r\n  // dtStart and the date-parts from dtEnd, and move backward from there.\r\n  // The number of days we move backward is stored in dayCorrection.\r\n  // Credit to Adam Shaw for devising this algorithm.\r\n  let dayCorrection = 0;\r\n  let intermediateDateTime: ISODateTime | undefined;\r\n\r\n  // The max number of allowed day corrections depends on the direction of travel.\r\n  // Both directions allow for 1 day correction due to an ISO wall-clock overshoot (see below).\r\n  // Only the forward direction allows for an additional 1 day correction caused by a push-forward\r\n  // 'compatible' DST transition causing the wall-clock to overshoot again.\r\n  // This max value is inclusive.\r\n  let maxDayCorrection = sign === 1 ? 2 : 1;\r\n\r\n  // Detect ISO wall-clock overshoot.\r\n  // If the diff of the ISO wall-clock times is opposite to the overall diff's sign,\r\n  // we are guaranteed to need at least one day correction.\r\n  let timeDuration = DifferenceTime(isoDtStart.time, isoDtEnd.time);\r\n  if (timeDuration.sign() === -sign) {\r\n    dayCorrection++;\r\n  }\r\n\r\n  for (; dayCorrection <= maxDayCorrection; dayCorrection++) {\r\n    const intermediateDate = BalanceISODate(\r\n      isoDtEnd.isoDate.year,\r\n      isoDtEnd.isoDate.month,\r\n      isoDtEnd.isoDate.day - dayCorrection * sign\r\n    );\r\n\r\n    // Incorporate time parts from dtStart\r\n    intermediateDateTime = CombineISODateAndTimeRecord(intermediateDate, isoDtStart.time);\r\n\r\n    // Convert intermediate datetime to epoch-nanoseconds (may disambiguate)\r\n    const intermediateNs = GetEpochNanosecondsFor(timeZone, intermediateDateTime, 'compatible');\r\n\r\n    // Compute the nanosecond diff between the intermediate instant and the final destination\r\n    timeDuration = TimeDuration.fromEpochNsDiff(ns2, intermediateNs);\r\n\r\n    // Did intermediateNs NOT surpass ns2?\r\n    // If so, exit the loop with success (without incrementing dayCorrection past maxDayCorrection)\r\n    if (timeDuration.sign() !== -sign) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  assert(dayCorrection <= maxDayCorrection, `more than ${maxDayCorrection} day correction needed`);\r\n\r\n  // Output of the above loop\r\n  assertExists(intermediateDateTime);\r\n\r\n  // Similar to what happens in DifferenceISODateTime with date parts only:\r\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\r\n  const dateDifference = CalendarDateUntil(calendar, isoDtStart.isoDate, intermediateDateTime.isoDate, dateLargestUnit);\r\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\r\n}\r\n\r\n// Epoch-nanosecond bounding technique where the start/end of the calendar-unit\r\n// interval are converted to epoch-nanosecond times and destEpochNs is nudged to\r\n// either one.\r\nfunction NudgeToCalendarUnit(\r\n  sign: -1 | 1,\r\n  durationParam: InternalDuration,\r\n  destEpochNs: JSBI,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  increment: number,\r\n  unit: Temporal.DateUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be day, week, month, or year\r\n  // timeZone may be undefined\r\n  let duration = durationParam;\r\n\r\n  // Create a duration with smallestUnit trunc'd towards zero\r\n  // Create a separate duration that incorporates roundingIncrement\r\n  let r1, r2, startDuration, endDuration;\r\n  switch (unit) {\r\n    case 'year': {\r\n      const years = RoundNumberToIncrement(duration.date.years, increment, 'trunc');\r\n      r1 = years;\r\n      r2 = years + increment * sign;\r\n      startDuration = { years: r1, months: 0, weeks: 0, days: 0 };\r\n      endDuration = { ...startDuration, years: r2 };\r\n      break;\r\n    }\r\n    case 'month': {\r\n      const months = RoundNumberToIncrement(duration.date.months, increment, 'trunc');\r\n      r1 = months;\r\n      r2 = months + increment * sign;\r\n      startDuration = AdjustDateDurationRecord(duration.date, 0, 0, r1);\r\n      endDuration = AdjustDateDurationRecord(duration.date, 0, 0, r2);\r\n      break;\r\n    }\r\n    case 'week': {\r\n      const yearsMonths = AdjustDateDurationRecord(duration.date, 0, 0);\r\n      const weeksStart = CalendarDateAdd(calendar, isoDateTime.isoDate, yearsMonths, 'constrain');\r\n      const weeksEnd = BalanceISODate(weeksStart.year, weeksStart.month, weeksStart.day + duration.date.days);\r\n      const untilResult = CalendarDateUntil(calendar, weeksStart, weeksEnd, 'week');\r\n      const weeks = RoundNumberToIncrement(duration.date.weeks + untilResult.weeks, increment, 'trunc');\r\n      r1 = weeks;\r\n      r2 = weeks + increment * sign;\r\n      startDuration = AdjustDateDurationRecord(duration.date, 0, r1);\r\n      endDuration = AdjustDateDurationRecord(duration.date, 0, r2);\r\n      break;\r\n    }\r\n    case 'day': {\r\n      const days = RoundNumberToIncrement(duration.date.days, increment, 'trunc');\r\n      r1 = days;\r\n      r2 = days + increment * sign;\r\n      startDuration = AdjustDateDurationRecord(duration.date, r1);\r\n      endDuration = AdjustDateDurationRecord(duration.date, r2);\r\n      break;\r\n    }\r\n    default:\r\n      /* c8 ignore next */ assertNotReached();\r\n  }\r\n\r\n  if (sign === 1) assert(r1 >= 0 && r1 < r2, `positive ordering of r1, r2: 0 ≤ ${r1} < ${r2}`);\r\n  if (sign === -1) assert(r1 <= 0 && r1 > r2, `negative ordering of r1, r2: 0 ≥ ${r1} > ${r2}`);\r\n\r\n  // Apply to origin, output PlainDateTimes\r\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, startDuration, 'constrain');\r\n  const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\r\n\r\n  // Convert to epoch-nanoseconds\r\n  let startEpochNs, endEpochNs;\r\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\r\n  const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\r\n  if (timeZone) {\r\n    startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\r\n    endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\r\n  } else {\r\n    startEpochNs = GetUTCEpochNanoseconds(startDateTime);\r\n    endEpochNs = GetUTCEpochNanoseconds(endDateTime);\r\n  }\r\n\r\n  // Round the smallestUnit within the epoch-nanosecond span\r\n  if (sign === 1) {\r\n    assert(\r\n      JSBI.lessThanOrEqual(startEpochNs, destEpochNs) && JSBI.lessThanOrEqual(destEpochNs, endEpochNs),\r\n      `${unit} was 0 days long`\r\n    );\r\n  }\r\n  if (sign === -1) {\r\n    assert(\r\n      JSBI.lessThanOrEqual(endEpochNs, destEpochNs) && JSBI.lessThanOrEqual(destEpochNs, startEpochNs),\r\n      `${unit} was 0 days long`\r\n    );\r\n  }\r\n  assert(!JSBI.equal(endEpochNs, startEpochNs), 'startEpochNs must ≠ endEpochNs');\r\n  const numerator = TimeDuration.fromEpochNsDiff(destEpochNs, startEpochNs);\r\n  const denominator = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\r\n  const unsignedRoundingMode = GetUnsignedRoundingMode(roundingMode, sign < 0 ? 'negative' : 'positive');\r\n  const cmp = numerator.add(numerator).abs().subtract(denominator.abs()).sign();\r\n  const even = (Math.abs(r1) / increment) % 2 === 0;\r\n  // prettier-ignore\r\n  const roundedUnit = numerator.isZero()\r\n    ? Math.abs(r1)\r\n    : !numerator.cmp(denominator) // equal?\r\n      ? Math.abs(r2)\r\n      : ApplyUnsignedRoundingMode(Math.abs(r1), Math.abs(r2), cmp, even, unsignedRoundingMode);\r\n\r\n  // Trick to minimize rounding error, due to the lack of fma() in JS\r\n  const fakeNumerator = new TimeDuration(\r\n    JSBI.add(\r\n      JSBI.multiply(denominator.totalNs, JSBI.BigInt(r1)),\r\n      JSBI.multiply(numerator.totalNs, JSBI.BigInt(increment * sign))\r\n    )\r\n  );\r\n  const total = fakeNumerator.fdiv(denominator.totalNs);\r\n  assert(Math.abs(r1) <= Math.abs(total) && Math.abs(total) <= Math.abs(r2), 'r1 ≤ total ≤ r2');\r\n\r\n  // Determine whether expanded or contracted\r\n  const didExpandCalendarUnit = roundedUnit === Math.abs(r2);\r\n  duration = { date: didExpandCalendarUnit ? endDuration : startDuration, time: TimeDuration.ZERO };\r\n\r\n  const nudgeResult = {\r\n    duration,\r\n    nudgedEpochNs: didExpandCalendarUnit ? endEpochNs : startEpochNs,\r\n    didExpandCalendarUnit\r\n  };\r\n  return { nudgeResult, total };\r\n}\r\n\r\n// Attempts rounding of time units within a time zone's day, but if the rounding\r\n// causes time to exceed the total time within the day, rerun rounding in next\r\n// day.\r\nfunction NudgeToZonedTime(\r\n  sign: -1 | 1,\r\n  durationParam: InternalDuration,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  increment: number,\r\n  unit: Temporal.TimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be hour or smaller\r\n  let duration = durationParam;\r\n\r\n  // Apply to origin, output start/end of the day as PlainDateTimes\r\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, duration.date, 'constrain');\r\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\r\n  const endDate = BalanceISODate(start.year, start.month, start.day + sign);\r\n  const endDateTime = CombineISODateAndTimeRecord(endDate, isoDateTime.time);\r\n\r\n  // Compute the epoch-nanosecond start/end of the final whole-day interval\r\n  // If duration has negative sign, startEpochNs will be after endEpochNs\r\n  const startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\r\n  const endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\r\n\r\n  // The signed amount of time from the start of the whole-day interval to the end\r\n  const daySpan = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\r\n  if (daySpan.sign() !== sign) throw new RangeError('time zone returned inconsistent Instants');\r\n\r\n  // Compute time parts of the duration to nanoseconds and round\r\n  // Result could be negative\r\n  const unitIncrement = JSBI.BigInt(NS_PER_TIME_UNIT[unit] * increment);\r\n  let roundedTimeDuration = duration.time.round(unitIncrement, roundingMode);\r\n\r\n  // Does the rounded time exceed the time-in-day?\r\n  const beyondDaySpan = roundedTimeDuration.subtract(daySpan);\r\n  const didRoundBeyondDay = beyondDaySpan.sign() !== -sign;\r\n\r\n  let dayDelta, nudgedEpochNs;\r\n  if (didRoundBeyondDay) {\r\n    // If rounded into next day, use the day-end as the local origin and rerun\r\n    // the rounding\r\n    dayDelta = sign;\r\n    roundedTimeDuration = beyondDaySpan.round(unitIncrement, roundingMode);\r\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(endEpochNs);\r\n  } else {\r\n    // Otherwise, if time not rounded beyond day, use the day-start as the local\r\n    // origin\r\n    dayDelta = 0;\r\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(startEpochNs);\r\n  }\r\n\r\n  const dateDuration = AdjustDateDurationRecord(duration.date, duration.date.days + dayDelta);\r\n  const resultDuration = CombineDateAndTimeDuration(dateDuration, roundedTimeDuration);\r\n  return {\r\n    duration: resultDuration,\r\n    nudgedEpochNs,\r\n    didExpandCalendarUnit: didRoundBeyondDay\r\n  };\r\n}\r\n\r\n// Converts all fields to nanoseconds and does integer rounding.\r\nfunction NudgeToDayOrTime(\r\n  durationParam: InternalDuration,\r\n  destEpochNs: JSBI,\r\n  largestUnit: Temporal.DateTimeUnit,\r\n  increment: number,\r\n  smallestUnit: Temporal.TimeUnit | 'day',\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be day or smaller\r\n  let duration = durationParam;\r\n\r\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\r\n  // Convert to nanoseconds and round\r\n  const roundedTime = timeDuration.round(JSBI.BigInt(increment * NS_PER_TIME_UNIT[smallestUnit]), roundingMode);\r\n  const diffTime = roundedTime.subtract(timeDuration);\r\n\r\n  // Determine if whole days expanded\r\n  const { quotient: wholeDays } = timeDuration.divmod(DAY_NANOS);\r\n  const { quotient: roundedWholeDays } = roundedTime.divmod(DAY_NANOS);\r\n  const didExpandDays = Math.sign(roundedWholeDays - wholeDays) === timeDuration.sign();\r\n\r\n  const nudgedEpochNs = diffTime.addToEpochNs(destEpochNs);\r\n\r\n  let days = 0;\r\n  let remainder = roundedTime;\r\n  if (TemporalUnitCategory(largestUnit) === 'date') {\r\n    days = roundedWholeDays;\r\n    remainder = roundedTime.add(TimeDuration.fromComponents(-roundedWholeDays * 24, 0, 0, 0, 0, 0));\r\n  }\r\n\r\n  const dateDuration = AdjustDateDurationRecord(duration.date, days);\r\n  return {\r\n    duration: { date: dateDuration, time: remainder },\r\n    nudgedEpochNs,\r\n    didExpandCalendarUnit: didExpandDays\r\n  };\r\n}\r\n\r\n// Given a potentially bottom-heavy duration, bubble up smaller units to larger\r\n// units. Any units smaller than smallestUnit are already zeroed-out.\r\nfunction BubbleRelativeDuration(\r\n  sign: -1 | 1,\r\n  durationParam: InternalDuration,\r\n  nudgedEpochNs: JSBI,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateUnit,\r\n  smallestUnit: Temporal.DateUnit\r\n) {\r\n  // smallestUnit is day or larger\r\n  let duration = durationParam;\r\n\r\n  if (smallestUnit === largestUnit) return duration;\r\n\r\n  // Check to see if nudgedEpochNs has hit the boundary of any units higher than\r\n  // smallestUnit, in which case increment the higher unit and clear smaller\r\n  // units.\r\n  const largestUnitIndex = UNITS_DESCENDING.indexOf(largestUnit);\r\n  const smallestUnitIndex = UNITS_DESCENDING.indexOf(smallestUnit);\r\n  for (let unitIndex = smallestUnitIndex - 1; unitIndex >= largestUnitIndex; unitIndex--) {\r\n    // The only situation where days and smaller bubble-up into weeks is when\r\n    // largestUnit is 'week' (not to be confused with the situation where\r\n    // smallestUnit is 'week', in which case days and smaller are ROUNDED-up\r\n    // into weeks, but that has already happened by the time this function\r\n    // executes)\r\n    // So, if days and smaller are NOT bubbled-up into weeks, and the current\r\n    // unit is weeks, skip.\r\n    const unit = UNITS_DESCENDING[unitIndex];\r\n    if (unit === 'week' && largestUnit !== 'week') {\r\n      continue;\r\n    }\r\n\r\n    let endDuration;\r\n    switch (unit) {\r\n      case 'year': {\r\n        const years = duration.date.years + sign;\r\n        endDuration = { years, months: 0, weeks: 0, days: 0 };\r\n        break;\r\n      }\r\n      case 'month': {\r\n        const months = duration.date.months + sign;\r\n        endDuration = AdjustDateDurationRecord(duration.date, 0, 0, months);\r\n        break;\r\n      }\r\n      case 'week': {\r\n        const weeks = duration.date.weeks + sign;\r\n        endDuration = AdjustDateDurationRecord(duration.date, 0, weeks);\r\n        break;\r\n      }\r\n      default:\r\n        /* c8 ignore next */ assertNotReached();\r\n    }\r\n\r\n    // Compute end-of-unit in epoch-nanoseconds\r\n    const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\r\n    const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\r\n    let endEpochNs;\r\n    if (timeZone) {\r\n      endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\r\n    } else {\r\n      endEpochNs = GetUTCEpochNanoseconds(endDateTime);\r\n    }\r\n\r\n    const didExpandToEnd = compare(nudgedEpochNs, endEpochNs) !== -sign;\r\n\r\n    // Is nudgedEpochNs at the end-of-unit? This means it should bubble-up to\r\n    // the next highest unit (and possibly further...)\r\n    if (didExpandToEnd) {\r\n      duration = { date: endDuration, time: TimeDuration.ZERO };\r\n    } else {\r\n      // NOT at end-of-unit. Stop looking for bubbling\r\n      break;\r\n    }\r\n  }\r\n\r\n  return duration;\r\n}\r\n\r\nfunction RoundRelativeDuration(\r\n  durationParam: InternalDuration,\r\n  destEpochNs: JSBI,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnitParam: Temporal.DateTimeUnit,\r\n  increment: number,\r\n  smallestUnit: Temporal.DateTimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  let duration = durationParam;\r\n  // The duration must already be balanced. This should be achieved by calling\r\n  // one of the non-rounding since/until internal methods prior. It's okay to\r\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\r\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\r\n  // >24 hours in its timezone. (should automatically end up like this if using\r\n  // non-rounding since/until internal methods prior)\r\n  const irregularLengthUnit = IsCalendarUnit(smallestUnit) || (timeZone && smallestUnit === 'day');\r\n  const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\r\n\r\n  let nudgeResult;\r\n  if (irregularLengthUnit) {\r\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\r\n    ({ nudgeResult } = NudgeToCalendarUnit(\r\n      sign,\r\n      duration,\r\n      destEpochNs,\r\n      isoDateTime,\r\n      timeZone,\r\n      calendar,\r\n      increment,\r\n      smallestUnit,\r\n      roundingMode\r\n    ));\r\n  } else if (timeZone) {\r\n    // Special-case for rounding time units within a zoned day\r\n    uncheckedAssertNarrowedType<Temporal.TimeUnit>(\r\n      smallestUnit,\r\n      'other values handled in irregularLengthUnit clause above'\r\n    );\r\n    nudgeResult = NudgeToZonedTime(\r\n      sign,\r\n      duration,\r\n      isoDateTime,\r\n      timeZone,\r\n      calendar,\r\n      increment,\r\n      smallestUnit,\r\n      roundingMode\r\n    );\r\n  } else {\r\n    // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\r\n    // math. years/months/weeks unchanged\r\n    nudgeResult = NudgeToDayOrTime(duration, destEpochNs, largestUnitParam, increment, smallestUnit, roundingMode);\r\n  }\r\n\r\n  duration = nudgeResult.duration;\r\n  // Did nudging cause the duration to expand to the next day or larger?\r\n  // Bubble-up smaller calendar units into higher ones, except for weeks, which\r\n  // don't balance up into months\r\n  if (nudgeResult.didExpandCalendarUnit && smallestUnit !== 'week') {\r\n    uncheckedAssertNarrowedType<Temporal.DateUnit>(\r\n      largestUnitParam,\r\n      'if we expanded to a calendar unit, then largestUnit is a calendar unit'\r\n    );\r\n    duration = BubbleRelativeDuration(\r\n      sign,\r\n      duration,\r\n      nudgeResult.nudgedEpochNs, // The destEpochNs after expanding/contracting\r\n      isoDateTime,\r\n      timeZone,\r\n      calendar,\r\n      largestUnitParam, // where to STOP bubbling\r\n      LargerOfTwoTemporalUnits(smallestUnit, 'day') as Temporal.DateUnit // where to START bubbling-up from\r\n    );\r\n  }\r\n\r\n  return duration;\r\n}\r\n\r\nfunction TotalRelativeDuration(\r\n  duration: InternalDuration,\r\n  destEpochNs: JSBI,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  unit: Temporal.DateTimeUnit\r\n) {\r\n  // The duration must already be balanced. This should be achieved by calling\r\n  // one of the non-rounding since/until internal methods prior. It's okay to\r\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\r\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\r\n  // >24 hours in its timezone. (should automatically end up like this if using\r\n  // non-rounding since/until internal methods prior)\r\n  if (IsCalendarUnit(unit) || (timeZone && unit === 'day')) {\r\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\r\n    const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\r\n    return NudgeToCalendarUnit(sign, duration, destEpochNs, isoDateTime, timeZone, calendar, 1, unit, 'trunc').total;\r\n  }\r\n  // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\r\n  // math. years/months/weeks unchanged\r\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\r\n  return TotalTimeDuration(timeDuration, unit);\r\n}\r\n\r\nexport function DifferencePlainDateTimeWithRounding(\r\n  isoDateTime1: ISODateTime,\r\n  isoDateTime2: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit,\r\n  roundingIncrement: number,\r\n  smallestUnit: Temporal.DateTimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) {\r\n    return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\r\n  }\r\n\r\n  RejectDateTimeRange(isoDateTime1);\r\n  RejectDateTimeRange(isoDateTime2);\r\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, largestUnit);\r\n\r\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\r\n\r\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\r\n  return RoundRelativeDuration(\r\n    duration,\r\n    destEpochNs,\r\n    isoDateTime1,\r\n    null,\r\n    calendar,\r\n    largestUnit,\r\n    roundingIncrement,\r\n    smallestUnit,\r\n    roundingMode\r\n  );\r\n}\r\n\r\nexport function DifferencePlainDateTimeWithTotal(\r\n  isoDateTime1: ISODateTime,\r\n  isoDateTime2: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  unit: Temporal.DateTimeUnit\r\n) {\r\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) return 0;\r\n\r\n  RejectDateTimeRange(isoDateTime1);\r\n  RejectDateTimeRange(isoDateTime2);\r\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, unit);\r\n\r\n  if (unit === 'nanosecond') return JSBI.toNumber(duration.time.totalNs);\r\n\r\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\r\n  return TotalRelativeDuration(duration, destEpochNs, isoDateTime1, null, calendar, unit);\r\n}\r\n\r\nexport function DifferenceZonedDateTimeWithRounding(\r\n  ns1: JSBI,\r\n  ns2: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit,\r\n  roundingIncrement: number,\r\n  smallestUnit: Temporal.DateTimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  if (TemporalUnitCategory(largestUnit) === 'time') {\r\n    // The user is only asking for a time difference, so return difference of instants.\r\n    return DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit as Temporal.TimeUnit, roundingMode);\r\n  }\r\n\r\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit);\r\n\r\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\r\n\r\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\r\n  return RoundRelativeDuration(\r\n    duration,\r\n    ns2,\r\n    dateTime,\r\n    timeZone,\r\n    calendar,\r\n    largestUnit,\r\n    roundingIncrement,\r\n    smallestUnit,\r\n    roundingMode\r\n  );\r\n}\r\n\r\nexport function DifferenceZonedDateTimeWithTotal(\r\n  ns1: JSBI,\r\n  ns2: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  unit: Temporal.DateTimeUnit\r\n) {\r\n  if (TemporalUnitCategory(unit) === 'time') {\r\n    // The user is only asking for a time difference, so return difference of instants.\r\n    return TotalTimeDuration(TimeDuration.fromEpochNsDiff(ns2, ns1), unit as Temporal.TimeUnit);\r\n  }\r\n\r\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, unit);\r\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\r\n  return TotalRelativeDuration(duration, ns2, dateTime, timeZone, calendar, unit);\r\n}\r\n\r\ntype DifferenceOperation = 'since' | 'until';\r\n\r\nfunction GetDifferenceSettings<T extends Temporal.DateTimeUnit>(\r\n  op: DifferenceOperation,\r\n  options: Temporal.DifferenceOptions<T>,\r\n  group: 'datetime' | 'date' | 'time',\r\n  disallowed: (Temporal.DateTimeUnit | 'auto')[],\r\n  fallbackSmallest: T,\r\n  smallestLargestDefaultUnit: T\r\n) {\r\n  const ALLOWED_UNITS = TEMPORAL_UNITS.reduce((allowed, unitInfo) => {\r\n    const p = unitInfo[0];\r\n    const s = unitInfo[1];\r\n    const c = unitInfo[2];\r\n    if ((group === 'datetime' || c === group) && !disallowed.includes(s)) {\r\n      allowed.push(s, p);\r\n    }\r\n    return allowed;\r\n  }, [] as (Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit>)[]);\r\n\r\n  let largestUnit = GetTemporalUnitValuedOption(options, 'largestUnit', group, 'auto');\r\n  if (disallowed.includes(largestUnit)) {\r\n    throw new RangeError(`largestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${largestUnit}`);\r\n  }\r\n\r\n  const roundingIncrement = GetTemporalRoundingIncrementOption(options);\r\n\r\n  let roundingMode = GetRoundingModeOption(options, 'trunc');\r\n  if (op === 'since') roundingMode = NegateRoundingMode(roundingMode);\r\n\r\n  const smallestUnit = GetTemporalUnitValuedOption(options, 'smallestUnit', group, fallbackSmallest);\r\n  if (disallowed.includes(smallestUnit)) {\r\n    throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\r\n  }\r\n\r\n  const defaultLargestUnit = LargerOfTwoTemporalUnits(smallestLargestDefaultUnit, smallestUnit);\r\n  if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\r\n  if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\r\n    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\r\n  }\r\n  const MAX_DIFFERENCE_INCREMENTS: { [k in Temporal.DateTimeUnit]?: number } = {\r\n    hour: 24,\r\n    minute: 60,\r\n    second: 60,\r\n    millisecond: 1000,\r\n    microsecond: 1000,\r\n    nanosecond: 1000\r\n  };\r\n  const maximum = MAX_DIFFERENCE_INCREMENTS[smallestUnit];\r\n  if (maximum !== undefined) ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\r\n\r\n  return { largestUnit: largestUnit as T, roundingIncrement, roundingMode, smallestUnit: smallestUnit as T };\r\n}\r\n\r\nexport function DifferenceTemporalInstant(\r\n  operation: DifferenceOperation,\r\n  instant: Temporal.Instant,\r\n  otherParam: InstantParams['until'][0],\r\n  options: InstantParams['until'][1]\r\n) {\r\n  const other = ToTemporalInstant(otherParam);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'second');\r\n\r\n  const onens = GetSlot(instant, EPOCHNANOSECONDS);\r\n  const twons = GetSlot(other, EPOCHNANOSECONDS);\r\n  const duration = DifferenceInstant(\r\n    onens,\r\n    twons,\r\n    settings.roundingIncrement,\r\n    settings.smallestUnit,\r\n    settings.roundingMode\r\n  );\r\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainDate(\r\n  operation: DifferenceOperation,\r\n  plainDate: Temporal.PlainDate,\r\n  otherParam: PlainDateParams['until'][0],\r\n  options: PlainDateParams['until'][1]\r\n) {\r\n  const other = ToTemporalDate(otherParam);\r\n  const calendar = GetSlot(plainDate, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', [], 'day', 'day');\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n  const isoDate = GetSlot(plainDate, ISO_DATE);\r\n  const isoOther = GetSlot(other, ISO_DATE);\r\n  if (CompareISODate(isoDate, isoOther) === 0) return new Duration();\r\n\r\n  const dateDifference = CalendarDateUntil(calendar, isoDate, isoOther, settings.largestUnit);\r\n\r\n  let duration = { date: dateDifference, time: TimeDuration.ZERO };\r\n  const roundingIsNoop = settings.smallestUnit === 'day' && settings.roundingIncrement === 1;\r\n  if (!roundingIsNoop) {\r\n    const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\r\n    const isoDateTimeOther = CombineISODateAndTimeRecord(isoOther, MidnightTimeRecord());\r\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\r\n    duration = RoundRelativeDuration(\r\n      duration,\r\n      destEpochNs,\r\n      isoDateTime,\r\n      null,\r\n      calendar,\r\n      settings.largestUnit,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit,\r\n      settings.roundingMode\r\n    );\r\n  }\r\n\r\n  let result = TemporalDurationFromInternal(duration, 'day');\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainDateTime(\r\n  operation: DifferenceOperation,\r\n  plainDateTime: Temporal.PlainDateTime,\r\n  otherParam: PlainDateTimeParams['until'][0],\r\n  options: PlainDateTimeParams['until'][1]\r\n) {\r\n  const other = ToTemporalDateTime(otherParam);\r\n  const calendar = GetSlot(plainDateTime, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'day');\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n  const isoDateTime1 = GetSlot(plainDateTime, ISO_DATE_TIME);\r\n  const isoDateTime2 = GetSlot(other, ISO_DATE_TIME);\r\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) === 0) return new Duration();\r\n\r\n  const duration = DifferencePlainDateTimeWithRounding(\r\n    isoDateTime1,\r\n    isoDateTime2,\r\n    calendar,\r\n    settings.largestUnit,\r\n    settings.roundingIncrement,\r\n    settings.smallestUnit,\r\n    settings.roundingMode\r\n  );\r\n\r\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainTime(\r\n  operation: DifferenceOperation,\r\n  plainTime: Temporal.PlainTime,\r\n  otherParam: PlainTimeParams['until'][0],\r\n  options: PlainTimeParams['until'][1]\r\n) {\r\n  const other = ToTemporalTime(otherParam);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'hour');\r\n\r\n  let timeDuration = DifferenceTime(GetSlot(plainTime, TIME), GetSlot(other, TIME));\r\n  timeDuration = RoundTimeDuration(\r\n    timeDuration,\r\n    settings.roundingIncrement,\r\n    settings.smallestUnit,\r\n    settings.roundingMode\r\n  );\r\n  const duration = CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\r\n\r\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainYearMonth(\r\n  operation: DifferenceOperation,\r\n  yearMonth: Temporal.PlainYearMonth,\r\n  otherParam: PlainYearMonthParams['until'][0],\r\n  options: PlainYearMonthParams['until'][1]\r\n) {\r\n  const other = ToTemporalYearMonth(otherParam);\r\n  const calendar = GetSlot(yearMonth, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between months of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', ['week', 'day'], 'month', 'year');\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n  if (CompareISODate(GetSlot(yearMonth, ISO_DATE), GetSlot(other, ISO_DATE)) == 0) {\r\n    return new Duration();\r\n  }\r\n\r\n  const thisFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\r\n  thisFields.day = 1;\r\n  const thisDate = CalendarDateFromFields(calendar, thisFields, 'constrain');\r\n  const otherFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(other, ISO_DATE), 'year-month');\r\n  otherFields.day = 1;\r\n  const otherDate = CalendarDateFromFields(calendar, otherFields, 'constrain');\r\n\r\n  const dateDifference = CalendarDateUntil(calendar, thisDate, otherDate, settings.largestUnit);\r\n  let duration = { date: AdjustDateDurationRecord(dateDifference, 0, 0), time: TimeDuration.ZERO };\r\n  if (settings.smallestUnit !== 'month' || settings.roundingIncrement !== 1) {\r\n    const isoDateTime = CombineISODateAndTimeRecord(thisDate, MidnightTimeRecord());\r\n    const isoDateTimeOther = CombineISODateAndTimeRecord(otherDate, MidnightTimeRecord());\r\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\r\n    duration = RoundRelativeDuration(\r\n      duration,\r\n      destEpochNs,\r\n      isoDateTime,\r\n      null,\r\n      calendar,\r\n      settings.largestUnit,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit,\r\n      settings.roundingMode\r\n    );\r\n  }\r\n\r\n  let result = TemporalDurationFromInternal(duration, 'day');\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalZonedDateTime(\r\n  operation: DifferenceOperation,\r\n  zonedDateTime: Temporal.ZonedDateTime,\r\n  otherParam: ZonedDateTimeParams['until'][0],\r\n  options: ZonedDateTimeParams['until'][1]\r\n) {\r\n  const other = ToTemporalZonedDateTime(otherParam);\r\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'hour');\r\n\r\n  const ns1 = GetSlot(zonedDateTime, EPOCHNANOSECONDS);\r\n  const ns2 = GetSlot(other, EPOCHNANOSECONDS);\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n\r\n  let result;\r\n  if (TemporalUnitCategory(settings.largestUnit) !== 'date') {\r\n    // The user is only asking for a time difference, so return difference of instants.\r\n    const duration = DifferenceInstant(\r\n      ns1,\r\n      ns2,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit as Temporal.TimeUnit,\r\n      settings.roundingMode\r\n    );\r\n    result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  } else {\r\n    const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\r\n    if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\r\n      throw new RangeError(\r\n        \"When calculating difference between time zones, largestUnit must be 'hours' \" +\r\n          'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.'\r\n      );\r\n    }\r\n\r\n    if (JSBI.equal(ns1, ns2)) return new Duration();\r\n\r\n    const duration = DifferenceZonedDateTimeWithRounding(\r\n      ns1,\r\n      ns2,\r\n      timeZone,\r\n      calendar,\r\n      settings.largestUnit,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit,\r\n      settings.roundingMode\r\n    );\r\n    result = TemporalDurationFromInternal(duration, 'hour');\r\n  }\r\n\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function AddTime(\r\n  { hour, minute, second: secondParam, millisecond, microsecond, nanosecond: nanosecondParam }: TimeRecord,\r\n  timeDuration: TimeDuration\r\n) {\r\n  let second = secondParam;\r\n  let nanosecond = nanosecondParam;\r\n\r\n  second += timeDuration.sec;\r\n  nanosecond += timeDuration.subsec;\r\n  return BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n}\r\n\r\nfunction AddInstant(epochNanoseconds: JSBI, timeDuration: TimeDuration) {\r\n  const result = timeDuration.addToEpochNs(epochNanoseconds);\r\n  ValidateEpochNanoseconds(result);\r\n  return result;\r\n}\r\n\r\nexport function AddZonedDateTime(\r\n  epochNs: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  duration: InternalDuration,\r\n  overflow: Overflow = 'constrain'\r\n) {\r\n  // If only time is to be added, then use Instant math. It's not OK to fall\r\n  // through to the date/time code below because compatible disambiguation in\r\n  // the PlainDateTime=>Instant conversion will change the offset of any\r\n  // ZonedDateTime in the repeated clock time after a backwards transition.\r\n  // When adding/subtracting time units and not dates, this disambiguation is\r\n  // not expected and so is avoided below via a fast path for time-only\r\n  // arithmetic.\r\n  // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\r\n  if (DateDurationSign(duration.date) === 0) return AddInstant(epochNs, duration.time);\r\n\r\n  // RFC 5545 requires the date portion to be added in calendar days and the\r\n  // time portion to be added in exact time.\r\n  const dt = GetISODateTimeFor(timeZone, epochNs);\r\n  const addedDate = CalendarDateAdd(calendar, dt.isoDate, duration.date, overflow);\r\n  const dtIntermediate = CombineISODateAndTimeRecord(addedDate, dt.time);\r\n\r\n  // Note that 'compatible' is used below because this disambiguation behavior\r\n  // is required by RFC 5545.\r\n  const intermediateNs = GetEpochNanosecondsFor(timeZone, dtIntermediate, 'compatible');\r\n  return AddInstant(intermediateNs, duration.time);\r\n}\r\n\r\ntype AddSubtractOperation = 'add' | 'subtract';\r\n\r\nexport function AddDurations(\r\n  operation: AddSubtractOperation,\r\n  duration: Temporal.Duration,\r\n  otherParam: DurationParams['add'][0]\r\n) {\r\n  let other = ToTemporalDuration(otherParam);\r\n  if (operation === 'subtract') other = CreateNegatedTemporalDuration(other);\r\n\r\n  const largestUnit1 = DefaultTemporalLargestUnit(duration);\r\n  const largestUnit2 = DefaultTemporalLargestUnit(other);\r\n  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\r\n  if (IsCalendarUnit(largestUnit)) {\r\n    throw new RangeError('For years, months, or weeks arithmetic, use date arithmetic relative to a starting point');\r\n  }\r\n\r\n  const d1 = ToInternalDurationRecordWith24HourDays(duration);\r\n  const d2 = ToInternalDurationRecordWith24HourDays(other);\r\n  const result = CombineDateAndTimeDuration(ZeroDateDuration(), d1.time.add(d2.time));\r\n  return TemporalDurationFromInternal(result, largestUnit);\r\n}\r\n\r\nexport function AddDurationToInstant(\r\n  operation: AddSubtractOperation,\r\n  instant: Temporal.Instant,\r\n  durationLike: InstantParams['add'][0]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const largestUnit = DefaultTemporalLargestUnit(duration);\r\n  if (TemporalUnitCategory(largestUnit) === 'date') {\r\n    throw new RangeError(\r\n      `Duration field ${largestUnit} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`\r\n    );\r\n  }\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n  const ns = AddInstant(GetSlot(instant, EPOCHNANOSECONDS), internalDuration.time);\r\n  return CreateTemporalInstant(ns);\r\n}\r\n\r\nexport function AddDurationToDate(\r\n  operation: AddSubtractOperation,\r\n  plainDate: Temporal.PlainDate,\r\n  durationLike: PlainDateParams['add'][0],\r\n  options: PlainDateParams['add'][1]\r\n) {\r\n  const calendar = GetSlot(plainDate, CALENDAR);\r\n\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const dateDuration = ToDateDurationRecordWithoutTime(duration);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n\r\n  const addedDate = CalendarDateAdd(calendar, GetSlot(plainDate, ISO_DATE), dateDuration, overflow);\r\n  return CreateTemporalDate(addedDate, calendar);\r\n}\r\n\r\nexport function AddDurationToDateTime(\r\n  operation: AddSubtractOperation,\r\n  dateTime: Temporal.PlainDateTime,\r\n  durationLike: PlainDateTimeParams['add'][0],\r\n  options: PlainDateTimeParams['add'][1]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n\r\n  const calendar = GetSlot(dateTime, CALENDAR);\r\n\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n\r\n  // Add the time part\r\n  const isoDateTime = GetSlot(dateTime, ISO_DATE_TIME);\r\n  const timeResult = AddTime(isoDateTime.time, internalDuration.time);\r\n  const dateDuration = AdjustDateDurationRecord(internalDuration.date, timeResult.deltaDays);\r\n\r\n  // Delegate the date part addition to the calendar\r\n  RejectDuration(dateDuration.years, dateDuration.months, dateDuration.weeks, dateDuration.days, 0, 0, 0, 0, 0, 0);\r\n  const addedDate = CalendarDateAdd(calendar, isoDateTime.isoDate, dateDuration, overflow);\r\n\r\n  const result = CombineISODateAndTimeRecord(addedDate, timeResult);\r\n  return CreateTemporalDateTime(result, calendar);\r\n}\r\n\r\nexport function AddDurationToTime(\r\n  operation: AddSubtractOperation,\r\n  temporalTime: Temporal.PlainTime,\r\n  durationLike: PlainTimeParams['add'][0]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n  const { hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\r\n    GetSlot(temporalTime, TIME),\r\n    internalDuration.time\r\n  );\r\n  const time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject');\r\n  return CreateTemporalTime(time);\r\n}\r\n\r\nexport function AddDurationToYearMonth(\r\n  operation: AddSubtractOperation,\r\n  yearMonth: Temporal.PlainYearMonth,\r\n  durationLike: PlainYearMonthParams['add'][0],\r\n  options: PlainYearMonthParams['add'][1]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n  const sign = DurationSign(duration);\r\n\r\n  const calendar = GetSlot(yearMonth, CALENDAR);\r\n  const fields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\r\n  fields.day = 1;\r\n  let startDate = CalendarDateFromFields(calendar, fields, 'constrain');\r\n  if (sign < 0) {\r\n    const nextMonth = CalendarDateAdd(calendar, startDate, { months: 1 }, 'constrain');\r\n    startDate = BalanceISODate(nextMonth.year, nextMonth.month, nextMonth.day - 1);\r\n  }\r\n  const durationToAdd = ToDateDurationRecordWithoutTime(duration);\r\n  RejectDateRange(startDate);\r\n  const addedDate = CalendarDateAdd(calendar, startDate, durationToAdd, overflow);\r\n  const addedDateFields = ISODateToFields(calendar, addedDate, 'year-month');\r\n\r\n  const isoDate = CalendarYearMonthFromFields(calendar, addedDateFields, overflow);\r\n  return CreateTemporalYearMonth(isoDate, calendar);\r\n}\r\n\r\nexport function AddDurationToZonedDateTime(\r\n  operation: AddSubtractOperation,\r\n  zonedDateTime: Temporal.ZonedDateTime,\r\n  durationLike: ZonedDateTimeParams['add'][0],\r\n  options: ZonedDateTimeParams['add'][1]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n  const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\r\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\r\n  const internalDuration = ToInternalDurationRecord(duration);\r\n  const epochNanoseconds = AddZonedDateTime(\r\n    GetSlot(zonedDateTime, EPOCHNANOSECONDS),\r\n    timeZone,\r\n    calendar,\r\n    internalDuration,\r\n    overflow\r\n  );\r\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function RoundNumberToIncrement(quantity: number, increment: number, mode: Temporal.RoundingMode) {\r\n  const quotient = Math.trunc(quantity / increment);\r\n  const remainder = quantity % increment;\r\n  const sign = quantity < 0 ? 'negative' : 'positive';\r\n  const r1 = Math.abs(quotient);\r\n  const r2 = r1 + 1;\r\n  const cmp = ComparisonResult(Math.abs(remainder * 2) - increment);\r\n  const even = r1 % 2 === 0;\r\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\r\n  const rounded = remainder === 0 ? r1 : ApplyUnsignedRoundingMode(r1, r2, cmp, even, unsignedRoundingMode);\r\n  return increment * (sign === 'positive' ? rounded : -rounded);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function RoundNumberToIncrementAsIfPositive(\r\n  quantityParam: JSBI | bigint,\r\n  incrementParam: JSBI | bigint,\r\n  mode: Temporal.RoundingMode\r\n) {\r\n  const quantity = ensureJSBI(quantityParam);\r\n  const increment = ensureJSBI(incrementParam);\r\n  const quotient = JSBI.divide(quantity, increment);\r\n  const remainder = JSBI.remainder(quantity, increment);\r\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, 'positive');\r\n  let r1: JSBI, r2: JSBI;\r\n  if (JSBI.lessThan(quantity, ZERO)) {\r\n    r1 = JSBI.subtract(quotient, ONE);\r\n    r2 = quotient;\r\n  } else {\r\n    r1 = quotient;\r\n    r2 = JSBI.add(quotient, ONE);\r\n  }\r\n  // Similar to the comparison in RoundNumberToIncrement, but multiplied by an\r\n  // extra sign to make sure we treat it as positive\r\n  const cmp = (compare(abs(JSBI.multiply(remainder, TWO)), increment) * (JSBI.lessThan(quantity, ZERO) ? -1 : 1) +\r\n    0) as -1 | 0 | 1;\r\n  const rounded = JSBI.equal(remainder, ZERO)\r\n    ? quotient\r\n    : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(r1), unsignedRoundingMode);\r\n  return JSBI.multiply(rounded, increment);\r\n}\r\n\r\nexport function RoundTemporalInstant(\r\n  epochNs: JSBI,\r\n  increment: number,\r\n  unit: TimeUnitOrDay,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  const incrementNs = NS_PER_TIME_UNIT[unit] * increment;\r\n  return RoundNumberToIncrementAsIfPositive(epochNs, JSBI.BigInt(incrementNs), roundingMode);\r\n}\r\n\r\nexport function RoundISODateTime(\r\n  isoDateTime: ISODateTime,\r\n  increment: number,\r\n  unit: UnitSmallerThanOrEqualTo<'day'>,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  AssertISODateTimeWithinLimits(isoDateTime);\r\n  const { year, month, day } = isoDateTime.isoDate;\r\n  const time = RoundTime(isoDateTime.time, increment, unit, roundingMode);\r\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\r\n  return CombineISODateAndTimeRecord(isoDate, time);\r\n}\r\n\r\nexport function RoundTime(\r\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\r\n  increment: number,\r\n  unit: TimeUnitOrDay,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  let quantity;\r\n  switch (unit) {\r\n    case 'day':\r\n    case 'hour':\r\n      quantity = ((((hour * 60 + minute) * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'minute':\r\n      quantity = (((minute * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'second':\r\n      quantity = ((second * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'millisecond':\r\n      quantity = (millisecond * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'microsecond':\r\n      quantity = microsecond * 1000 + nanosecond;\r\n      break;\r\n    case 'nanosecond':\r\n      quantity = nanosecond;\r\n  }\r\n  const nsPerUnit = NS_PER_TIME_UNIT[unit];\r\n  const result = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode) / nsPerUnit;\r\n  switch (unit) {\r\n    case 'day':\r\n      return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\r\n    case 'hour':\r\n      return BalanceTime(result, 0, 0, 0, 0, 0);\r\n    case 'minute':\r\n      return BalanceTime(hour, result, 0, 0, 0, 0);\r\n    case 'second':\r\n      return BalanceTime(hour, minute, result, 0, 0, 0);\r\n    case 'millisecond':\r\n      return BalanceTime(hour, minute, second, result, 0, 0);\r\n    case 'microsecond':\r\n      return BalanceTime(hour, minute, second, millisecond, result, 0);\r\n    case 'nanosecond':\r\n      return BalanceTime(hour, minute, second, millisecond, microsecond, result);\r\n    default:\r\n      throw new Error(`Invalid unit ${unit}`);\r\n  }\r\n}\r\n\r\nexport function RoundTimeDuration(\r\n  timeDuration: TimeDuration,\r\n  increment: number,\r\n  unit: Temporal.TimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be a time unit\r\n  const divisor = NS_PER_TIME_UNIT[unit];\r\n  return timeDuration.round(JSBI.BigInt(divisor * increment), roundingMode);\r\n}\r\n\r\nexport function TotalTimeDuration(timeDuration: TimeDuration, unit: TimeUnitOrDay) {\r\n  const divisor = NS_PER_TIME_UNIT[unit];\r\n  return timeDuration.fdiv(JSBI.BigInt(divisor));\r\n}\r\n\r\nexport function CompareISODate(isoDate1: ISODate, isoDate2: ISODate) {\r\n  if (isoDate1.year !== isoDate2.year) return ComparisonResult(isoDate1.year - isoDate2.year);\r\n  if (isoDate1.month !== isoDate2.month) return ComparisonResult(isoDate1.month - isoDate2.month);\r\n  if (isoDate1.day !== isoDate2.day) return ComparisonResult(isoDate1.day - isoDate2.day);\r\n  return 0;\r\n}\r\n\r\nexport function CompareTimeRecord(time1: TimeRecord, time2: TimeRecord) {\r\n  if (time1.hour !== time2.hour) return ComparisonResult(time1.hour - time2.hour);\r\n  if (time1.minute !== time2.minute) return ComparisonResult(time1.minute - time2.minute);\r\n  if (time1.second !== time2.second) return ComparisonResult(time1.second - time2.second);\r\n  if (time1.millisecond !== time2.millisecond) return ComparisonResult(time1.millisecond - time2.millisecond);\r\n  if (time1.microsecond !== time2.microsecond) return ComparisonResult(time1.microsecond - time2.microsecond);\r\n  if (time1.nanosecond !== time2.nanosecond) return ComparisonResult(time1.nanosecond - time2.nanosecond);\r\n  return 0;\r\n}\r\n\r\nexport function CompareISODateTime(isoDateTime1: ISODateTime, isoDateTime2: ISODateTime) {\r\n  const dateResult = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\r\n  if (dateResult !== 0) return dateResult;\r\n  return CompareTimeRecord(isoDateTime1.time, isoDateTime2.time);\r\n}\r\n\r\n// Defaults to native bigint, or something \"native bigint-like\".\r\n// For users of Temporal that are running in environments without native BigInt,\r\n// the only guarantee we should give is that the returned object's toString will\r\n// return a string containing an accurate base 10 value of this bigint. This\r\n// form factor should correctly interop with other bigint compat libraries\r\n// easily.\r\ntype ExternalBigInt = bigint;\r\n\r\nexport function ToBigIntExternal(arg: unknown): ExternalBigInt {\r\n  const jsbiBI = ToBigInt(arg);\r\n  if (typeof (globalThis as any).BigInt !== 'undefined') return (globalThis as any).BigInt(jsbiBI.toString(10));\r\n  return jsbiBI as unknown as ExternalBigInt;\r\n}\r\n\r\n// rounding modes supported: floor, ceil, trunc\r\nexport function epochNsToMs(epochNanosecondsParam: JSBI | bigint, mode: 'floor' | 'ceil' | 'trunc') {\r\n  const epochNanoseconds = ensureJSBI(epochNanosecondsParam);\r\n  const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\r\n  let epochMilliseconds = JSBI.toNumber(quotient);\r\n  if (mode === 'floor' && JSBI.toNumber(remainder) < 0) epochMilliseconds -= 1;\r\n  if (mode === 'ceil' && JSBI.toNumber(remainder) > 0) epochMilliseconds += 1;\r\n  return epochMilliseconds;\r\n}\r\n\r\nexport function epochMsToNs(epochMilliseconds: number) {\r\n  if (!Number.isInteger(epochMilliseconds)) throw new RangeError('epoch milliseconds must be an integer');\r\n  return JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\r\n}\r\n\r\nexport function ToBigInt(arg: unknown): JSBI {\r\n  let prim = arg;\r\n  if (typeof arg === 'object') {\r\n    const toPrimFn = (arg as { [Symbol.toPrimitive]: unknown })[Symbol.toPrimitive];\r\n    if (toPrimFn && typeof toPrimFn === 'function') {\r\n      prim = toPrimFn.call(arg, 'number');\r\n    }\r\n  }\r\n\r\n  // The AO ToBigInt throws on numbers because it does not allow implicit\r\n  // conversion between number and bigint (unlike the bigint constructor).\r\n  if (typeof prim === 'number') {\r\n    throw new TypeError('cannot convert number to bigint');\r\n  }\r\n  if (typeof prim === 'bigint') {\r\n    // JSBI doesn't know anything about the bigint type, and intentionally\r\n    // assumes it doesn't exist. Passing one to the BigInt function will throw\r\n    // an error.\r\n    return JSBI.BigInt(prim.toString(10));\r\n  }\r\n  // JSBI will properly coerce types into a BigInt the same as the native BigInt\r\n  // constructor will, with the exception of native bigint which is handled\r\n  // above.\r\n  // As of 2023-04-07, the only runtime type that neither of those can handle is\r\n  // 'symbol', and both native bigint and the JSBI.BigInt function will throw an\r\n  // error if they are given a Symbol.\r\n  return JSBI.BigInt(prim as string | boolean | object);\r\n}\r\n\r\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\r\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\r\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\r\nexport const SystemUTCEpochNanoSeconds: () => JSBI = (() => {\r\n  let ns = JSBI.BigInt(Date.now() % 1e6);\r\n  return () => {\r\n    const now = Date.now();\r\n    const ms = JSBI.BigInt(now);\r\n    const result = JSBI.add(epochMsToNs(now), ns);\r\n    ns = JSBI.remainder(ms, MILLION);\r\n    if (JSBI.greaterThan(result, NS_MAX)) return NS_MAX;\r\n    if (JSBI.lessThan(result, NS_MIN)) return NS_MIN;\r\n    return result;\r\n  };\r\n})();\r\n\r\nexport function DefaultTimeZone() {\r\n  return new Intl.DateTimeFormat().resolvedOptions().timeZone;\r\n}\r\n\r\nexport function ComparisonResult(value: number) {\r\n  return value < 0 ? -1 : value > 0 ? 1 : (value as 0);\r\n}\r\n\r\nexport function GetOptionsObject<T>(options: T) {\r\n  if (options === undefined) return Object.create(null) as NonNullable<T>;\r\n  if (IsObject(options) && options !== null) return options;\r\n  throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\r\n}\r\n\r\nexport function CreateOnePropObject<K extends string, V>(propName: K, propValue: V): { [k in K]: V } {\r\n  const o = Object.create(null);\r\n  o[propName] = propValue;\r\n  return o;\r\n}\r\n\r\ntype StringlyTypedKeys<T> = Exclude<keyof T, symbol | number>;\r\nfunction GetOption<P extends StringlyTypedKeys<O>, O extends Partial<Record<P, unknown>>>(\r\n  options: O,\r\n  property: P,\r\n  allowedValues: ReadonlyArray<O[P]>,\r\n  fallback: undefined\r\n): O[P];\r\nfunction GetOption<\r\n  P extends StringlyTypedKeys<O>,\r\n  O extends Partial<Record<P, unknown>>,\r\n  Fallback extends Required<O>[P] | typeof REQUIRED | undefined\r\n>(\r\n  options: O,\r\n  property: P,\r\n  allowedValues: ReadonlyArray<O[P]>,\r\n  fallback: Fallback\r\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P];\r\nfunction GetOption<\r\n  P extends StringlyTypedKeys<O>,\r\n  O extends Partial<Record<P, unknown>>,\r\n  Fallback extends Required<O>[P] | undefined\r\n>(\r\n  options: O,\r\n  property: P,\r\n  allowedValues: ReadonlyArray<O[P]>,\r\n  fallback: O[P]\r\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P] {\r\n  let value = options[property];\r\n  if (value !== undefined) {\r\n    value = ToString(value) as O[P];\r\n    if (!allowedValues.includes(value)) {\r\n      throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\r\n    }\r\n    return value;\r\n  }\r\n  if (fallback === REQUIRED) throw new RangeError(`${property} option is required`);\r\n  return fallback;\r\n}\r\n\r\n// This is a temporary implementation. Ideally we'd rely on Intl.DateTimeFormat\r\n// here, to provide the latest CLDR alias data, when implementations catch up to\r\n// the ECMA-402 change. The aliases below are taken from\r\n// https://github.com/unicode-org/cldr/blob/main/common/bcp47/calendar.xml\r\nexport function CanonicalizeCalendar(idParam: string): BuiltinCalendarId {\r\n  const id = ASCIILowercase(idParam);\r\n\r\n  if (!BUILTIN_CALENDAR_IDS.includes(ASCIILowercase(id))) {\r\n    throw new RangeError(`invalid calendar identifier ${id}`);\r\n  }\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(id, 'above code throws out any non-calendar IDs');\r\n\r\n  switch (id) {\r\n    case 'ethiopic-amete-alem':\r\n      // May need to be removed in the future.\r\n      // See https://github.com/tc39/ecma402/issues/285\r\n      return 'ethioaa';\r\n    // case 'gregorian':\r\n    // (Skip 'gregorian'. It isn't a valid identifier as it's a single\r\n    // subcomponent longer than 8 letters. It can only be used with the old\r\n    // @key=value syntax.)\r\n    case 'islamicc':\r\n      return 'islamic-civil';\r\n  }\r\n  return id;\r\n}\r\n\r\nfunction ASCIILowercase<T extends string>(str: T): T {\r\n  // The spec defines this operation distinct from String.prototype.lowercase,\r\n  // so we'll follow the spec here. Note that nasty security issues that can\r\n  // happen for some use cases if you're comparing case-modified non-ASCII\r\n  // values. For example, Turkish's \"I\" character was the source of a security\r\n  // issue involving \"file://\" URLs. See\r\n  // https://haacked.com/archive/2012/07/05/turkish-i-problem-and-why-you-should-care.aspx/.\r\n  let lowercase = '';\r\n  for (let ix = 0; ix < str.length; ix++) {\r\n    const code = str.charCodeAt(ix);\r\n    if (code >= 0x41 && code <= 0x5a) {\r\n      lowercase += String.fromCharCode(code + 0x20);\r\n    } else {\r\n      lowercase += String.fromCharCode(code);\r\n    }\r\n  }\r\n  return lowercase as T;\r\n}\r\n\r\n// This function isn't in the spec, but we put it in the polyfill to avoid\r\n// repeating the same (long) error message in many files.\r\nexport function ValueOfThrows(constructorName: string): never {\r\n  const compareCode =\r\n    constructorName === 'PlainMonthDay'\r\n      ? 'Temporal.PlainDate.compare(obj1.toPlainDate(year), obj2.toPlainDate(year))'\r\n      : `Temporal.${constructorName}.compare(obj1, obj2)`;\r\n\r\n  throw new TypeError(\r\n    'Do not use built-in arithmetic operators with Temporal objects. ' +\r\n      `When comparing, use ${compareCode}, not obj1 > obj2. ` +\r\n      \"When coercing to strings, use `${obj}` or String(obj), not '' + obj. \" +\r\n      'When coercing to numbers, use properties or methods of the object, not `+obj`. ' +\r\n      'When concatenating with strings, use `${str}${obj}` or str.concat(obj), not str + obj. ' +\r\n      'In React, coerce to a string before rendering a Temporal object.'\r\n  );\r\n}\r\n\r\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\r\nconst OFFSET_WITH_PARTS = new RegExp(`^${PARSE.offsetWithParts.source}$`);\r\n\r\nfunction bisect(\r\n  getState: (epochMs: number) => number,\r\n  leftParam: number,\r\n  rightParam: number,\r\n  lstateParam = getState(leftParam),\r\n  rstateParam = getState(rightParam)\r\n) {\r\n  let left = leftParam;\r\n  let right = rightParam;\r\n  let lstate = lstateParam;\r\n  let rstate = rstateParam;\r\n  while (right - left > 1) {\r\n    let middle = Math.trunc((left + right) / 2);\r\n    const mstate = getState(middle);\r\n    if (mstate === lstate) {\r\n      left = middle;\r\n      lstate = mstate;\r\n    } else if (mstate === rstate) {\r\n      right = middle;\r\n      rstate = mstate;\r\n    } else {\r\n      /* c8 ignore next */ assertNotReached(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\r\n    }\r\n  }\r\n  return right;\r\n}\r\n","import * as ES from './ecmascript';\r\nimport { DefineIntrinsic } from './intrinsicclass';\r\nimport type { Temporal } from '..';\r\nimport type {\r\n  BuiltinCalendarId,\r\n  CalendarDateRecord,\r\n  CalendarFieldsRecord,\r\n  CalendarYMD,\r\n  DateDuration,\r\n  FieldKey,\r\n  ISODate,\r\n  ISODateToFieldsType,\r\n  MonthDayFromFieldsObject,\r\n  Overflow,\r\n  Resolve\r\n} from './internaltypes';\r\n\r\nfunction arrayFromSet<T>(src: Set<T>): T[] {\r\n  return [...src];\r\n}\r\n\r\nfunction calendarDateWeekOfYear(id: BuiltinCalendarId, isoDate: ISODate): { week: number; year: number } | undefined {\r\n  // Supports only ISO8601 calendar; can be updated to add support for other calendars.\r\n  // Returns undefined for calendars without a well-defined week calendar system.\r\n  // eslint-disable-next-line max-len\r\n  // Also see: https://github.com/unicode-org/icu/blob/ab72ab1d4a3c3f9beeb7d92b0c7817ca93dfdb04/icu4c/source/i18n/calendar.cpp#L1606\r\n  if (id !== 'iso8601') return undefined;\r\n  const calendar = impl[id];\r\n  let yow = isoDate.year;\r\n  const { dayOfWeek, dayOfYear, daysInYear } = calendar.isoToDate(isoDate, {\r\n    dayOfWeek: true,\r\n    dayOfYear: true,\r\n    daysInYear: true\r\n  });\r\n  const fdow = calendar.getFirstDayOfWeek();\r\n  const mdow = calendar.getMinimalDaysInFirstWeek();\r\n  ES.uncheckedAssertNarrowedType<number>(fdow, 'guaranteed to exist for iso8601');\r\n  ES.uncheckedAssertNarrowedType<number>(mdow, 'guaranteed to exist for iso8601');\r\n\r\n  // For both the input date and the first day of its calendar year, calculate the day of week\r\n  // relative to first day of week in the relevant calendar (e.g., in iso8601, relative to Monday).\r\n  let relDow = (dayOfWeek + 7 - fdow) % 7;\r\n  // Assuming the year length is less than 7000 days.\r\n  let relDowJan1 = (dayOfWeek - dayOfYear + 7001 - fdow) % 7;\r\n\r\n  let woy = Math.floor((dayOfYear - 1 + relDowJan1) / 7);\r\n  if (7 - relDowJan1 >= mdow) {\r\n    ++woy;\r\n  }\r\n\r\n  // Adjust for weeks at the year end that overlap into the previous or next calendar year.\r\n  if (woy == 0) {\r\n    // Check for last week of previous year; if true, handle the case for\r\n    // first week of next year\r\n    const prevYearCalendar = calendar.isoToDate(calendar.dateAdd(isoDate, { years: -1 }, 'constrain'), {\r\n      daysInYear: true\r\n    });\r\n    let prevDoy = dayOfYear + prevYearCalendar.daysInYear;\r\n    woy = weekNumber(fdow, mdow, prevDoy, dayOfWeek);\r\n    yow--;\r\n  } else {\r\n    // For it to be week 1 of the next year, dayOfYear must be >= lastDoy - 5\r\n    //          L-5                  L\r\n    // doy: 359 360 361 362 363 364 365 001\r\n    // dow:      1   2   3   4   5   6   7\r\n    let lastDoy = daysInYear;\r\n    if (dayOfYear >= lastDoy - 5) {\r\n      let lastRelDow = (relDow + lastDoy - dayOfYear) % 7;\r\n      if (lastRelDow < 0) {\r\n        lastRelDow += 7;\r\n      }\r\n      if (6 - lastRelDow >= mdow && dayOfYear + 7 - relDow > lastDoy) {\r\n        woy = 1;\r\n        yow++;\r\n      }\r\n    }\r\n  }\r\n  return { week: woy, year: yow };\r\n}\r\n\r\nfunction ISODateSurpasses(sign: -1 | 0 | 1, y1: number, m1: number, d1: number, isoDate2: ISODate) {\r\n  if (y1 !== isoDate2.year) {\r\n    if (sign * (y1 - isoDate2.year) > 0) return true;\r\n  } else if (m1 !== isoDate2.month) {\r\n    if (sign * (m1 - isoDate2.month) > 0) return true;\r\n  } else if (d1 !== isoDate2.day) {\r\n    if (sign * (d1 - isoDate2.day) > 0) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\ntype ResolveFieldsReturn<Type extends ISODateToFieldsType> = Resolve<\r\n  CalendarFieldsRecord & {\r\n    year: Type extends 'date' ? number : never;\r\n    month: number;\r\n    monthCode: string;\r\n    day: number;\r\n  }\r\n>;\r\n\r\n/**\r\n * Shape of internal implementation of each built-in calendar. Note that\r\n * parameter types are simpler than CalendarProtocol because the `Calendar`\r\n * class performs validation and parameter normalization before handing control\r\n * over to CalendarImpl.\r\n *\r\n * There are two instances of this interface: one for the ISO calendar and\r\n * another that handles logic that's the same across all non-ISO calendars. The\r\n * latter is cloned for each non-ISO calendar at the end of this file.\r\n */\r\nexport interface CalendarImpl {\r\n  isoToDate<\r\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\r\n    T extends {\r\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\r\n    }\r\n  >(\r\n    isoDate: ISODate,\r\n    requestedFields: Request\r\n  ): T;\r\n  getFirstDayOfWeek(): number | undefined;\r\n  getMinimalDaysInFirstWeek(): number | undefined;\r\n  resolveFields<Type extends ISODateToFieldsType>(\r\n    fields: CalendarFieldsRecord,\r\n    type: Type\r\n  ): asserts fields is ResolveFieldsReturn<Type>;\r\n  dateToISO(fields: ResolveFieldsReturn<'date'>, overflow: Overflow): ISODate;\r\n  monthDayToISOReferenceDate(fields: ResolveFieldsReturn<'month-day'>, overflow: Overflow): ISODate;\r\n  dateAdd(date: ISODate, duration: Partial<DateDuration>, overflow: Overflow): ISODate;\r\n  dateUntil(one: ISODate, two: ISODate, largestUnit: 'year' | 'month' | 'week' | 'day'): DateDuration;\r\n  extraFields(fields: FieldKey[]): FieldKey[];\r\n  fieldKeysToIgnore(keys: FieldKey[]): FieldKey[];\r\n}\r\n\r\ntype CalendarImplementations = {\r\n  [k in BuiltinCalendarId]: CalendarImpl;\r\n};\r\n\r\n/**\r\n * Implementations for each calendar.\r\n * Registration for each of these calendars happens throughout this file. The ISO and non-ISO calendars are registered\r\n * separately - look for 'iso8601' for the ISO calendar registration, and all non-ISO calendar registrations happens\r\n * at the bottom of the file.\r\n */\r\nconst impl: CalendarImplementations = {} as unknown as CalendarImplementations;\r\n\r\n/**\r\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\r\n * guaranteed to be supported by all ECMAScript implementations, including those\r\n * without Intl (ECMA-402) support.\r\n */\r\nimpl['iso8601'] = {\r\n  resolveFields(fields, type) {\r\n    if ((type === 'date' || type === 'year-month') && fields.year === undefined) {\r\n      throw new TypeError('year is required');\r\n    }\r\n    if ((type === 'date' || type === 'month-day') && fields.day === undefined) {\r\n      throw new TypeError('day is required');\r\n    }\r\n    Object.assign(fields, resolveNonLunisolarMonth(fields));\r\n  },\r\n  dateToISO(fields, overflow) {\r\n    return ES.RegulateISODate(fields.year, fields.month, fields.day, overflow);\r\n  },\r\n  monthDayToISOReferenceDate(fields, overflow) {\r\n    const referenceISOYear = 1972;\r\n    const { month, day } = ES.RegulateISODate(fields.year ?? referenceISOYear, fields.month, fields.day, overflow);\r\n    return { month, day, year: referenceISOYear };\r\n  },\r\n  extraFields() {\r\n    return [];\r\n  },\r\n  fieldKeysToIgnore(keys) {\r\n    const result = new Set<FieldKey>();\r\n    for (let ix = 0; ix < keys.length; ix++) {\r\n      const key = keys[ix];\r\n      result.add(key);\r\n      if (key === 'month') {\r\n        result.add('monthCode');\r\n      } else if (key === 'monthCode') {\r\n        result.add('month');\r\n      }\r\n    }\r\n    return arrayFromSet(result);\r\n  },\r\n  dateAdd(isoDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow) {\r\n    let { year, month, day } = isoDate;\r\n    year += years;\r\n    month += months;\r\n    ({ year, month } = ES.BalanceISOYearMonth(year, month));\r\n    ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\r\n    day += days + 7 * weeks;\r\n    return ES.BalanceISODate(year, month, day);\r\n  },\r\n  dateUntil(one, two, largestUnit) {\r\n    const sign = -ES.CompareISODate(one, two);\r\n    if (sign === 0) return { years: 0, months: 0, weeks: 0, days: 0 };\r\n    ES.uncheckedAssertNarrowedType<-1 | 1>(sign, \"the - operator's return type is number\");\r\n\r\n    let years = 0;\r\n    let months = 0;\r\n    let intermediate;\r\n    if (largestUnit === 'year' || largestUnit === 'month') {\r\n      // We can skip right to the neighbourhood of the correct number of years,\r\n      // it'll be at least one less than two.year - one.year (unless it's zero)\r\n      let candidateYears = two.year - one.year;\r\n      if (candidateYears !== 0) candidateYears -= sign;\r\n      // loops at most twice\r\n      while (!ISODateSurpasses(sign, one.year + candidateYears, one.month, one.day, two)) {\r\n        years = candidateYears;\r\n        candidateYears += sign;\r\n      }\r\n\r\n      let candidateMonths = sign;\r\n      intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + candidateMonths);\r\n      // loops at most 12 times\r\n      while (!ISODateSurpasses(sign, intermediate.year, intermediate.month, one.day, two)) {\r\n        months = candidateMonths;\r\n        candidateMonths += sign;\r\n        intermediate = ES.BalanceISOYearMonth(intermediate.year, intermediate.month + sign);\r\n      }\r\n\r\n      if (largestUnit === 'month') {\r\n        months += years * 12;\r\n        years = 0;\r\n      }\r\n    }\r\n\r\n    intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + months);\r\n    const constrained = ES.ConstrainISODate(intermediate.year, intermediate.month, one.day);\r\n\r\n    let weeks = 0;\r\n    let days =\r\n      ES.ISODateToEpochDays(two.year, two.month - 1, two.day) -\r\n      ES.ISODateToEpochDays(constrained.year, constrained.month - 1, constrained.day);\r\n\r\n    if (largestUnit === 'week') {\r\n      weeks = Math.trunc(days / 7);\r\n      days %= 7;\r\n    }\r\n\r\n    return { years, months, weeks, days };\r\n  },\r\n  isoToDate<\r\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\r\n    T extends {\r\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\r\n    }\r\n  >({ year, month, day }: ISODate, requestedFields: Request): T {\r\n    // requestedFields parameter is not part of the spec text. It's an\r\n    // illustration of one way implementations may choose to optimize this\r\n    // operation.\r\n    const date: Partial<CalendarDateRecord> = {\r\n      era: undefined,\r\n      eraYear: undefined,\r\n      year,\r\n      month,\r\n      day,\r\n      daysInWeek: 7,\r\n      monthsInYear: 12\r\n    };\r\n    if (requestedFields.monthCode) date.monthCode = buildMonthCode(month);\r\n    if (requestedFields.dayOfWeek) {\r\n      // https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Disparate_variation\r\n      const shiftedMonth = month + (month < 3 ? 10 : -2);\r\n      const shiftedYear = year - (month < 3 ? 1 : 0);\r\n\r\n      const century = Math.floor(shiftedYear / 100);\r\n      const yearInCentury = shiftedYear - century * 100;\r\n\r\n      const monthTerm = Math.floor(2.6 * shiftedMonth - 0.2);\r\n      const yearTerm = yearInCentury + Math.floor(yearInCentury / 4);\r\n      const centuryTerm = Math.floor(century / 4) - 2 * century;\r\n\r\n      const dow = (day + monthTerm + yearTerm + centuryTerm) % 7;\r\n\r\n      date.dayOfWeek = dow + (dow <= 0 ? 7 : 0);\r\n    }\r\n    if (requestedFields.dayOfYear) {\r\n      let days = day;\r\n      for (let m = month - 1; m > 0; m--) {\r\n        days += ES.ISODaysInMonth(year, m);\r\n      }\r\n      date.dayOfYear = days;\r\n    }\r\n    if (requestedFields.weekOfYear) date.weekOfYear = calendarDateWeekOfYear('iso8601', { year, month, day });\r\n    if (requestedFields.daysInMonth) date.daysInMonth = ES.ISODaysInMonth(year, month);\r\n    if (requestedFields.daysInYear || requestedFields.inLeapYear) {\r\n      date.inLeapYear = ES.LeapYear(year);\r\n      date.daysInYear = date.inLeapYear ? 366 : 365;\r\n    }\r\n    return date as T;\r\n  },\r\n  getFirstDayOfWeek() {\r\n    return 1;\r\n  },\r\n  getMinimalDaysInFirstWeek() {\r\n    return 4;\r\n  }\r\n};\r\n\r\n// Note: Built-in calendars other than iso8601 are not part of the Temporal\r\n// proposal for ECMA-262. These calendars will be standardized as part of\r\n// ECMA-402. Code below here includes an implementation of these calendars to\r\n// validate the Temporal API and to get feedback. However, native non-ISO\r\n// calendar behavior is at least somewhat implementation-defined, so may not\r\n// match this polyfill's output exactly.\r\n//\r\n// Some ES implementations don't include ECMA-402. For this reason, it's helpful\r\n// to ensure a clean separation between the ISO calendar implementation which is\r\n// a part of ECMA-262 and the non-ISO calendar implementation which requires\r\n// ECMA-402.\r\n//\r\n// To ensure this separation, the implementation is split. A `CalendarImpl`\r\n// interface defines the common operations between both ISO and non-ISO\r\n// calendars.\r\n\r\n/**\r\n * This type is passed through from CalendarImpl#dateFromFields().\r\n * `monthExtra` is additional information used internally to identify lunisolar leap months.\r\n */\r\ntype CalendarDateFields = CalendarFieldsRecord & { monthExtra?: string };\r\n\r\n/**\r\n * This is a \"fully populated\" calendar date record. It's only lacking\r\n * `era`/`eraYear` (which may not be present in all calendars) and `monthExtra`\r\n * which is only used in some cases.\r\n */\r\ntype FullCalendarDate = {\r\n  era?: string;\r\n  eraYear?: number;\r\n  year: number;\r\n  month: number;\r\n  monthCode: string;\r\n  day: number;\r\n  monthExtra?: string;\r\n};\r\n\r\n// The types below are various subsets of calendar dates\r\ntype CalendarYM = { year: number; month: number };\r\ntype CalendarYearOnly = { year: number };\r\ntype EraAndEraYear = { era: string; eraYear: number };\r\n\r\nfunction nonLeapMonthCodeNumberPart(monthCode: string) {\r\n  if (!monthCode.startsWith('M')) {\r\n    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\r\n  }\r\n  const month = +monthCode.slice(1);\r\n  if (Number.isNaN(month)) throw new RangeError(`Invalid month code: ${monthCode}`);\r\n  return month;\r\n}\r\n\r\nfunction buildMonthCode(month: number, leap = false) {\r\n  const digitPart = `${month}`.padStart(2, '0');\r\n  const leapMarker = leap ? 'L' : '';\r\n  return `M${digitPart}${leapMarker}`;\r\n}\r\n\r\n/**\r\n * Safely merge a month, monthCode pair into an integer month.\r\n * If both are present, make sure they match.\r\n * This logic doesn't work for lunisolar calendars!\r\n * */\r\nfunction resolveNonLunisolarMonth<T extends { monthCode?: string; month?: number }>(\r\n  calendarDate: T,\r\n  overflow: Overflow | undefined = undefined,\r\n  monthsPerYear = 12\r\n) {\r\n  let { month, monthCode } = calendarDate;\r\n  if (monthCode === undefined) {\r\n    if (month === undefined) throw new TypeError('Either month or monthCode are required');\r\n    // The ISO calendar uses the default (undefined) value because it does\r\n    // constrain/reject after this method returns. Non-ISO calendars, however,\r\n    // rely on this function to constrain/reject out-of-range `month` values.\r\n    if (overflow === 'reject') ES.RejectToRange(month, 1, monthsPerYear);\r\n    if (overflow === 'constrain') month = ES.ConstrainToRange(month, 1, monthsPerYear);\r\n    monthCode = buildMonthCode(month);\r\n  } else {\r\n    const numberPart = nonLeapMonthCodeNumberPart(monthCode);\r\n    if (monthCode !== buildMonthCode(numberPart)) {\r\n      throw new RangeError(`Invalid month code: ${monthCode}`);\r\n    }\r\n    if (month !== undefined && month !== numberPart) {\r\n      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\r\n    }\r\n    month = numberPart;\r\n    if (month < 1 || month > monthsPerYear) throw new RangeError(`Invalid monthCode: ${monthCode}`);\r\n  }\r\n  return { ...calendarDate, month, monthCode };\r\n}\r\n\r\nfunction weekNumber(firstDayOfWeek: number, minimalDaysInFirstWeek: number, desiredDay: number, dayOfWeek: number) {\r\n  let periodStartDayOfWeek = (dayOfWeek - firstDayOfWeek - desiredDay + 1) % 7;\r\n  if (periodStartDayOfWeek < 0) periodStartDayOfWeek += 7;\r\n  let weekNo = Math.floor((desiredDay + periodStartDayOfWeek - 1) / 7);\r\n  if (7 - periodStartDayOfWeek >= minimalDaysInFirstWeek) {\r\n    ++weekNo;\r\n  }\r\n  return weekNo;\r\n}\r\n\r\n/**\r\n * This prototype implementation of non-ISO calendars makes many repeated calls\r\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\r\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\r\n * to a specific Temporal object, which speeds up multiple calendar calls on the\r\n * same Temporal object instance.  No invalidation or pruning is necessary\r\n * because each object's cache is thrown away when the object is GC-ed.\r\n */\r\nclass OneObjectCache {\r\n  map = new Map();\r\n  calls = 0;\r\n  // now = OneObjectCache.monotonicTimestamp();\r\n  hits = 0;\r\n  misses = 0;\r\n\r\n  // static monotonicTimestamp() {\r\n  //   return performance?.now() ?? Date.now();\r\n  // }\r\n\r\n  constructor(cacheToClone?: OneObjectCache) {\r\n    if (cacheToClone !== undefined) {\r\n      let i = 0;\r\n      for (const entry of cacheToClone.map.entries()) {\r\n        if (++i > OneObjectCache.MAX_CACHE_ENTRIES) break;\r\n        this.map.set(...entry);\r\n      }\r\n    }\r\n  }\r\n  get(key: string) {\r\n    const result = this.map.get(key);\r\n    if (result) {\r\n      this.hits++;\r\n      this.report();\r\n    }\r\n    this.calls++;\r\n    return result;\r\n  }\r\n  set(key: string, value: unknown) {\r\n    this.map.set(key, value);\r\n    this.misses++;\r\n    this.report();\r\n  }\r\n  report() {\r\n    // if (this.calls === 0) return;\r\n    // const ms = OneObjectCache.monotonicTimestamp() - this.now;\r\n    // const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\r\n    // const t = `${ms.toFixed(2)}ms`;\r\n    // // eslint-disable-next-line no-console\r\n    // console.log(`${this.calls} calls in ${t}. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\r\n  }\r\n  setObject(obj: ISODate) {\r\n    if (OneObjectCache.objectMap.get(obj)) throw new RangeError('object already cached');\r\n    OneObjectCache.objectMap.set(obj, this);\r\n    this.report();\r\n  }\r\n\r\n  static objectMap = new WeakMap();\r\n  static MAX_CACHE_ENTRIES = 1000;\r\n\r\n  /**\r\n   * Returns a WeakMap-backed cache that's used to store expensive results\r\n   * that are associated with a particular Temporal object instance.\r\n   *\r\n   * @param obj - object to associate with the cache\r\n   */\r\n  static getCacheForObject(obj: ISODate) {\r\n    let cache = OneObjectCache.objectMap.get(obj);\r\n    if (!cache) {\r\n      cache = new OneObjectCache();\r\n      OneObjectCache.objectMap.set(obj, cache);\r\n    }\r\n    return cache;\r\n  }\r\n}\r\n\r\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }: { isoYear: number; isoMonth: number; isoDay: number }) {\r\n  const yearString = ES.ISOYearString(isoYear);\r\n  const monthString = ES.ISODateTimePartString(isoMonth);\r\n  const dayString = ES.ISODateTimePartString(isoDay);\r\n  return `${yearString}-${monthString}-${dayString}T00:00Z`;\r\n}\r\n\r\nfunction simpleDateDiff(one: CalendarYMD, two: CalendarYMD) {\r\n  return {\r\n    years: one.year - two.year,\r\n    months: one.month - two.month,\r\n    days: one.day - two.day\r\n  };\r\n}\r\n\r\n/**\r\n * Implementation helper that's common to all non-ISO calendars\r\n */\r\nabstract class HelperBase {\r\n  abstract id: BuiltinCalendarId;\r\n  abstract monthsInYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): number;\r\n  abstract maximumMonthLength(calendarDate?: CalendarYM): number;\r\n  abstract minimumMonthLength(calendarDate?: CalendarYM): number;\r\n  abstract maxLengthOfMonthCodeInAnyYear(monthCode: string): number;\r\n  abstract estimateIsoDate(calendarDate: CalendarYMD): ISODate;\r\n  abstract inLeapYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): boolean;\r\n  abstract calendarType: 'solar' | 'lunar' | 'lunisolar';\r\n  reviseIntlEra?<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T;\r\n  eras: Era[] = [];\r\n  checkIcuBugs?(isoDate: ISODate): void;\r\n  private formatter?: globalThis.Intl.DateTimeFormat;\r\n  getFormatter() {\r\n    // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\r\n    // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\r\n    // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\r\n    // calendars that are used. Note that the HelperBase class is extended to\r\n    // create each calendar's implementation before any cache is created, so\r\n    // each calendar gets its own separate cached formatter.\r\n    if (typeof this.formatter === 'undefined') {\r\n      this.formatter = new Intl.DateTimeFormat(`en-US-u-ca-${this.id}`, {\r\n        day: 'numeric',\r\n        month: 'numeric',\r\n        year: 'numeric',\r\n        era: 'short',\r\n        timeZone: 'UTC'\r\n      });\r\n    }\r\n    return this.formatter;\r\n  }\r\n  getCalendarParts(isoString: string) {\r\n    let dateTimeFormat = this.getFormatter();\r\n    let legacyDate = new Date(isoString);\r\n\r\n    // PlainDate's minimum date -271821-04-19 is one day beyond legacy Date's\r\n    // minimum -271821-04-20, because of accommodating all Instants in all time\r\n    // zones. If we have -271821-04-19, instead format -271821-04-20 in a time\r\n    // zone that pushes the result into the previous day. This is a slow path\r\n    // because we create a new Intl.DateTimeFormat.\r\n    if (isoString === '-271821-04-19T00:00Z') {\r\n      const options = dateTimeFormat.resolvedOptions();\r\n      dateTimeFormat = new Intl.DateTimeFormat(options.locale, {\r\n        ...(options as Intl.DateTimeFormatOptions),\r\n        timeZone: 'Etc/GMT+1'\r\n      });\r\n      legacyDate = new Date('-271821-04-20T00:00Z');\r\n    }\r\n\r\n    try {\r\n      return dateTimeFormat.formatToParts(legacyDate);\r\n    } catch (e) {\r\n      throw new RangeError(`Invalid ISO date: ${isoString}`);\r\n    }\r\n  }\r\n  isoToCalendarDate(isoDate: ISODate, cache: OneObjectCache): FullCalendarDate {\r\n    const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\r\n    const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\r\n    const cached = cache.get(key);\r\n    if (cached) return cached;\r\n\r\n    const isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\r\n    const parts = this.getCalendarParts(isoString);\r\n    const result: Partial<FullCalendarDate> = {};\r\n    for (let i = 0; i < parts.length; i++) {\r\n      const { type, value } = parts[i];\r\n      // TODO: remove this type annotation when `relatedYear` gets into TS lib types\r\n      if (type === 'year' || type === ('relatedYear' as Intl.DateTimeFormatPartTypes)) {\r\n        if (this.hasEra) {\r\n          result.eraYear = +value;\r\n        } else {\r\n          result.year = +value;\r\n        }\r\n      }\r\n      if (type === 'month') {\r\n        const matches = /^([0-9]*)(.*?)$/.exec(value);\r\n        if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\r\n          throw new RangeError(`Unexpected month: ${value}`);\r\n        }\r\n        // If the month has no numeric part (should only see this for the Hebrew\r\n        // calendar with newer FF / Chromium versions; see\r\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\r\n        // placeholder month index of `1` and rely on the derived class to\r\n        // calculate the correct month index from the month name stored in\r\n        // `monthExtra`.\r\n        result.month = matches[1] ? +matches[1] : 1;\r\n        if (result.month < 1) {\r\n          throw new RangeError(\r\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\r\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)'\r\n          );\r\n        }\r\n        if (result.month > 13) {\r\n          throw new RangeError(\r\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\r\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\r\n          );\r\n        }\r\n\r\n        // The ICU formats for the Hebrew calendar no longer support a numeric\r\n        // month format. So we'll rely on the derived class to interpret it.\r\n        // `monthExtra` is also used on the Chinese calendar to handle a suffix\r\n        // \"bis\" indicating a leap month.\r\n        if (matches[2]) result.monthExtra = matches[2];\r\n      }\r\n      if (type === 'day') result.day = +value;\r\n      if (this.hasEra && type === 'era' && value != null && value !== '') {\r\n        // The convention for Temporal era values is lowercase, so following\r\n        // that convention in this prototype. Punctuation is removed, accented\r\n        // letters are normalized, and spaces are replaced with dashes.\r\n        // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\r\n        // The call to normalize() and the replacement regex deals with era\r\n        // names that contain non-ASCII characters like Japanese eras. Also\r\n        // ignore extra content in parentheses like JPN era date ranges.\r\n        result.era = value\r\n          .split(' (')[0]\r\n          .normalize('NFD')\r\n          .replace(/[^-0-9 \\p{L}]/gu, '')\r\n          .replace(/ /g, '-')\r\n          .toLowerCase();\r\n      }\r\n    }\r\n    if (this.hasEra && result.eraYear === undefined) {\r\n      // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\r\n      // output of Intl.DateTimeFormat.formatToParts.\r\n      throw new RangeError(\r\n        `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\r\n      );\r\n    }\r\n    // Translate old ICU era codes \"ERA0\" etc. into canonical era names.\r\n    if (this.hasEra) {\r\n      const replacement = this.eras.find((e) => result.era === e.genericName);\r\n      if (replacement) result.era = replacement.code;\r\n    }\r\n    // Translate eras that may be handled differently by Temporal vs. by Intl\r\n    // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\r\n    if (this.reviseIntlEra) {\r\n      const { era, eraYear } = this.reviseIntlEra(result, isoDate);\r\n      result.era = era;\r\n      result.eraYear = eraYear;\r\n    }\r\n    if (this.checkIcuBugs) this.checkIcuBugs(isoDate);\r\n\r\n    const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\r\n    if (calendarDate.year === undefined) throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\r\n    if (calendarDate.month === undefined) {\r\n      throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\r\n    }\r\n    if (calendarDate.day === undefined) throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\r\n    cache.set(key, calendarDate);\r\n    // Also cache the reverse mapping\r\n    const cacheReverse = (overflow: Overflow) => {\r\n      const keyReverse = JSON.stringify({\r\n        func: 'calendarToIsoDate',\r\n        year: calendarDate.year,\r\n        month: calendarDate.month,\r\n        day: calendarDate.day,\r\n        overflow,\r\n        id: this.id\r\n      });\r\n      cache.set(keyReverse, isoDate);\r\n    };\r\n    (['constrain', 'reject'] as const).forEach(cacheReverse);\r\n    return calendarDate;\r\n  }\r\n  validateCalendarDate(calendarDate: Partial<FullCalendarDate>): asserts calendarDate is FullCalendarDate {\r\n    const { month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\r\n    // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\r\n    // the derived class must deal with it.\r\n    if (monthExtra !== undefined) throw new RangeError('Unexpected `monthExtra` value');\r\n    if (year === undefined && eraYear === undefined) throw new TypeError('year or eraYear is required');\r\n    if (month === undefined && monthCode === undefined) throw new TypeError('month or monthCode is required');\r\n    if (day === undefined) throw new RangeError('Missing day');\r\n    if (monthCode !== undefined) {\r\n      if (typeof monthCode !== 'string') {\r\n        throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\r\n      }\r\n      if (!/^M([01]?\\d)(L?)$/.test(monthCode)) {\r\n        throw new RangeError(`Invalid monthCode: ${monthCode}`);\r\n      }\r\n    }\r\n    if (this.hasEra) {\r\n      if ((calendarDate['era'] === undefined) !== (calendarDate['eraYear'] === undefined)) {\r\n        throw new TypeError('properties era and eraYear must be provided together');\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Allows derived calendars to add additional fields and/or to make\r\n   * adjustments e.g. to set the era based on the date or to revise the month\r\n   * number in lunisolar calendars per\r\n   * https://github.com/tc39/proposal-temporal/issues/1203.\r\n   *\r\n   * The base implementation fills in missing values by assuming the simplest\r\n   * possible calendar:\r\n   * - no eras\r\n   * - non-lunisolar calendar (no leap months)\r\n   * */\r\n  adjustCalendarDate(\r\n    calendarDateParam: Partial<FullCalendarDate>,\r\n    cache: OneObjectCache | undefined = undefined,\r\n    overflow: Overflow = 'constrain',\r\n    // This param is only used by derived classes\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    fromLegacyDate = false\r\n  ): FullCalendarDate {\r\n    if (this.calendarType === 'lunisolar') throw new RangeError('Override required for lunisolar calendars');\r\n    let calendarDate = calendarDateParam;\r\n    this.validateCalendarDate(calendarDate);\r\n    const largestMonth = this.monthsInYear(calendarDate, cache);\r\n    let { month, monthCode } = calendarDate;\r\n\r\n    ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\r\n    return { ...(calendarDate as typeof calendarDate & CalendarYMD), month, monthCode };\r\n  }\r\n  regulateMonthDayNaive(calendarDate: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): FullCalendarDate {\r\n    const largestMonth = this.monthsInYear(calendarDate, cache);\r\n    let { month, day } = calendarDate;\r\n    if (overflow === 'reject') {\r\n      ES.RejectToRange(month, 1, largestMonth);\r\n      ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\r\n    } else {\r\n      month = ES.ConstrainToRange(month, 1, largestMonth);\r\n      day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\r\n    }\r\n    return { ...calendarDate, month, day };\r\n  }\r\n  calendarToIsoDate(dateParam: CalendarDateFields, overflow: Overflow = 'constrain', cache: OneObjectCache): ISODate {\r\n    const originalDate = dateParam as Partial<FullCalendarDate>;\r\n    // First, normalize the calendar date to ensure that (year, month, day)\r\n    // are all present, converting monthCode and eraYear if needed.\r\n    let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\r\n\r\n    // Fix obviously out-of-bounds values. Values that are valid generally, but\r\n    // not in this particular year, may not be caught here for some calendars.\r\n    // If so, these will be handled lower below.\r\n    date = this.regulateMonthDayNaive(date, overflow, cache);\r\n\r\n    const { year, month, day } = date;\r\n    const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\r\n    let cached = cache.get(key);\r\n    if (cached) return cached;\r\n    // If YMD are present in the input but the input has been constrained\r\n    // already, then cache both the original value and the constrained value.\r\n    let keyOriginal;\r\n    if (\r\n      originalDate.year !== undefined &&\r\n      originalDate.month !== undefined &&\r\n      originalDate.day !== undefined &&\r\n      (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)\r\n    ) {\r\n      keyOriginal = JSON.stringify({\r\n        func: 'calendarToIsoDate',\r\n        year: originalDate.year,\r\n        month: originalDate.month,\r\n        day: originalDate.day,\r\n        overflow,\r\n        id: this.id\r\n      });\r\n      cached = cache.get(keyOriginal);\r\n      if (cached) return cached;\r\n    }\r\n\r\n    // First, try to roughly guess the result\r\n    let isoEstimate = this.estimateIsoDate({ year, month, day });\r\n    const calculateSameMonthResult = (diffDays: number) => {\r\n      // If the estimate is in the same year & month as the target, then we can\r\n      // calculate the result exactly and short-circuit any additional logic.\r\n      // This optimization assumes that months are continuous. It would break if\r\n      // a calendar skipped days, like the Julian->Gregorian switchover. But\r\n      // current ICU calendars only skip days (japanese/roc/buddhist) because of\r\n      // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\r\n      // that's currently worked around by a custom calendarToIsoDate\r\n      // implementation in those calendars. So this optimization should be safe\r\n      // for all ICU calendars.\r\n      let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\r\n      if (date.day > this.minimumMonthLength(date)) {\r\n        // There's a chance that the calendar date is out of range. Throw or\r\n        // constrain if so.\r\n        let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\r\n        while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\r\n          if (overflow === 'reject') {\r\n            throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\r\n          }\r\n          // Back up a day at a time until we're not hanging over the month end\r\n          testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\r\n          testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\r\n        }\r\n      }\r\n      return testIsoEstimate;\r\n    };\r\n    let sign = 0;\r\n    let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\r\n    let diff = simpleDateDiff(date, roundtripEstimate);\r\n    if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\r\n      const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\r\n      isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\r\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\r\n      diff = simpleDateDiff(date, roundtripEstimate);\r\n      if (diff.years === 0 && diff.months === 0) {\r\n        isoEstimate = calculateSameMonthResult(diff.days);\r\n      } else {\r\n        sign = this.compareCalendarDates(date, roundtripEstimate);\r\n      }\r\n    }\r\n    // If the initial guess is not in the same month, then bisect the\r\n    // distance to the target, starting with 8 days per step.\r\n    let increment = 8;\r\n    while (sign) {\r\n      isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\r\n      const oldRoundtripEstimate = roundtripEstimate;\r\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\r\n      const oldSign = sign;\r\n      sign = this.compareCalendarDates(date, roundtripEstimate);\r\n      if (sign) {\r\n        diff = simpleDateDiff(date, roundtripEstimate);\r\n        if (diff.years === 0 && diff.months === 0) {\r\n          isoEstimate = calculateSameMonthResult(diff.days);\r\n          // Signal the loop condition that there's a match.\r\n          sign = 0;\r\n        } else if (oldSign && sign !== oldSign) {\r\n          if (increment > 1) {\r\n            // If the estimate overshot the target, try again with a smaller increment\r\n            // in the reverse direction.\r\n            increment /= 2;\r\n          } else {\r\n            // Increment is 1, and neither the previous estimate nor the new\r\n            // estimate is correct. The only way that can happen is if the\r\n            // original date was an invalid value that will be constrained or\r\n            // rejected here.\r\n            if (overflow === 'reject') {\r\n              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\r\n            } else {\r\n              // To constrain, pick the earliest value\r\n              const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\r\n              // If current value is larger, then back up to the previous value.\r\n              if (order > 0) isoEstimate = this.addDaysIso(isoEstimate, -1);\r\n              sign = 0;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    cache.set(key, isoEstimate);\r\n    if (keyOriginal) cache.set(keyOriginal, isoEstimate);\r\n    if (\r\n      date.year === undefined ||\r\n      date.month === undefined ||\r\n      date.day === undefined ||\r\n      date.monthCode === undefined ||\r\n      (this.hasEra && (date.era === undefined || date.eraYear === undefined))\r\n    ) {\r\n      throw new RangeError('Unexpected missing property');\r\n    }\r\n    return isoEstimate;\r\n  }\r\n  compareCalendarDates(date1: CalendarYMD, date2: CalendarYMD) {\r\n    if (date1.year !== date2.year) return ES.ComparisonResult(date1.year - date2.year);\r\n    if (date1.month !== date2.month) return ES.ComparisonResult(date1.month - date2.month);\r\n    if (date1.day !== date2.day) return ES.ComparisonResult(date1.day - date2.day);\r\n    return 0;\r\n  }\r\n  /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\r\n  regulateDate(calendarDate: CalendarYMD, overflow: Overflow = 'constrain', cache: OneObjectCache): FullCalendarDate {\r\n    const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\r\n    return this.isoToCalendarDate(isoDate, cache);\r\n  }\r\n  addDaysIso(isoDate: ISODate, days: number): ISODate {\r\n    const added = ES.BalanceISODate(isoDate.year, isoDate.month, isoDate.day + days);\r\n    return added;\r\n  }\r\n  addDaysCalendar(calendarDate: CalendarYMD, days: number, cache: OneObjectCache): FullCalendarDate {\r\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n    const addedIso = this.addDaysIso(isoDate, days);\r\n    const addedCalendar = this.isoToCalendarDate(addedIso, cache);\r\n    return addedCalendar;\r\n  }\r\n  addMonthsCalendar(\r\n    calendarDateParam: CalendarYMD,\r\n    months: number,\r\n    overflow: Overflow,\r\n    cache: OneObjectCache\r\n  ): CalendarYMD {\r\n    let calendarDate = calendarDateParam;\r\n    const { day } = calendarDate;\r\n    for (let i = 0, absMonths = Math.abs(months); i < absMonths; i++) {\r\n      const { month } = calendarDate;\r\n      const oldCalendarDate = calendarDate;\r\n      const days =\r\n        months < 0\r\n          ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\r\n          : this.daysInMonth(calendarDate, cache);\r\n      const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n      let addedIso = this.addDaysIso(isoDate, days);\r\n      calendarDate = this.isoToCalendarDate(addedIso, cache);\r\n\r\n      // Normally, we can advance one month by adding the number of days in the\r\n      // current month. However, if we're at the end of the current month and\r\n      // the next month has fewer days, then we rolled over to the after-next\r\n      // month. Below we detect this condition and back up until we're back in\r\n      // the desired month.\r\n      if (months > 0) {\r\n        const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\r\n        while (calendarDate.month - 1 !== month % monthsInOldYear) {\r\n          addedIso = this.addDaysIso(addedIso, -1);\r\n          calendarDate = this.isoToCalendarDate(addedIso, cache);\r\n        }\r\n      }\r\n\r\n      if (calendarDate.day !== day) {\r\n        // try to retain the original day-of-month, if possible\r\n        calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\r\n      }\r\n    }\r\n    if (overflow === 'reject' && calendarDate.day !== day) {\r\n      throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\r\n    }\r\n    return calendarDate;\r\n  }\r\n  addCalendar(\r\n    calendarDate: CalendarYMD & { monthCode: string },\r\n    { years = 0, months = 0, weeks = 0, days = 0 },\r\n    overflow: Overflow,\r\n    cache: OneObjectCache\r\n  ): FullCalendarDate {\r\n    const { year, day, monthCode } = calendarDate;\r\n    const addedYears = this.adjustCalendarDate({ year: year + years, monthCode, day }, cache);\r\n    const addedMonths = this.addMonthsCalendar(addedYears, months, overflow, cache);\r\n    const initialDays = days + weeks * 7;\r\n    const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\r\n    return addedDays;\r\n  }\r\n  untilCalendar(\r\n    calendarOne: FullCalendarDate,\r\n    calendarTwo: FullCalendarDate,\r\n    largestUnit: Temporal.DateUnit,\r\n    cache: OneObjectCache\r\n  ): { years: number; months: number; weeks: number; days: number } {\r\n    let days = 0;\r\n    let weeks = 0;\r\n    let months = 0;\r\n    let years = 0;\r\n    switch (largestUnit) {\r\n      case 'day':\r\n        days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\r\n        break;\r\n      case 'week': {\r\n        const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\r\n        days = totalDays % 7;\r\n        weeks = (totalDays - days) / 7;\r\n        break;\r\n      }\r\n      case 'month':\r\n      case 'year': {\r\n        const sign = this.compareCalendarDates(calendarTwo, calendarOne);\r\n        if (!sign) {\r\n          return { years: 0, months: 0, weeks: 0, days: 0 };\r\n        }\r\n        const diffYears = calendarTwo.year - calendarOne.year;\r\n        const diffDays = calendarTwo.day - calendarOne.day;\r\n        if (largestUnit === 'year' && diffYears) {\r\n          let diffInYearSign = 0;\r\n          if (calendarTwo.monthCode > calendarOne.monthCode) diffInYearSign = 1;\r\n          if (calendarTwo.monthCode < calendarOne.monthCode) diffInYearSign = -1;\r\n          if (!diffInYearSign) diffInYearSign = Math.sign(diffDays);\r\n          const isOneFurtherInYear = diffInYearSign * sign < 0;\r\n          years = isOneFurtherInYear ? diffYears - sign : diffYears;\r\n        }\r\n        const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\r\n        // Now we have less than one year remaining. Add one month at a time\r\n        // until we go over the target, then back up one month and calculate\r\n        // remaining days and weeks.\r\n        let current;\r\n        let next: CalendarYMD = yearsAdded;\r\n        do {\r\n          months += sign;\r\n          current = next;\r\n          next = this.addMonthsCalendar(current, sign, 'constrain', cache);\r\n          if (next.day !== calendarOne.day) {\r\n            // In case the day was constrained down, try to un-constrain it\r\n            next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\r\n          }\r\n        } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\r\n        months -= sign; // correct for loop above which overshoots by 1\r\n        const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\r\n        days = remainingDays;\r\n        break;\r\n      }\r\n    }\r\n    return { years, months, weeks, days };\r\n  }\r\n  daysInMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\r\n    // Add enough days to roll over to the next month. One we're in the next\r\n    // month, we can calculate the length of the current month. NOTE: This\r\n    // algorithm assumes that months are continuous. It would break if a\r\n    // calendar skipped days, like the Julian->Gregorian switchover. But current\r\n    // ICU calendars only skip days (japanese/roc/buddhist) because of a bug\r\n    // (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158) that's\r\n    // currently worked around by a custom calendarToIsoDate implementation in\r\n    // those calendars. So this code should be safe for all ICU calendars.\r\n    const { day } = calendarDate;\r\n    const max = this.maximumMonthLength(calendarDate);\r\n    const min = this.minimumMonthLength(calendarDate);\r\n    // easiest case: we already know the month length if min and max are the same.\r\n    if (min === max) return min;\r\n\r\n    // Add enough days to get into the next month, without skipping it\r\n    const increment = day <= max - min ? max : min;\r\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n    const addedIsoDate = this.addDaysIso(isoDate, increment);\r\n    const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\r\n\r\n    // Now back up to the last day of the original month\r\n    const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\r\n    const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\r\n    return endOfMonthCalendar.day;\r\n  }\r\n  daysInPreviousMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\r\n    const { day, month, year } = calendarDate;\r\n\r\n    // Check to see if we already know the month length, and return it if so\r\n    const previousMonthYear = month > 1 ? year : year - 1;\r\n    let previousMonthDate = { year: previousMonthYear, month, day: 1 };\r\n    const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\r\n    previousMonthDate = { ...previousMonthDate, month: previousMonth };\r\n    const min = this.minimumMonthLength(previousMonthDate);\r\n    const max = this.maximumMonthLength(previousMonthDate);\r\n    if (min === max) return max;\r\n\r\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n    const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\r\n    const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\r\n    return lastDayOfPreviousMonthCalendar.day;\r\n  }\r\n  startOfCalendarYear(calendarDate: CalendarYearOnly): CalendarYMD & { monthCode: string } {\r\n    return { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\r\n  }\r\n  startOfCalendarMonth(calendarDate: CalendarYM): CalendarYMD {\r\n    return { year: calendarDate.year, month: calendarDate.month, day: 1 };\r\n  }\r\n  calendarDaysUntil(calendarOne: CalendarYMD, calendarTwo: CalendarYMD, cache: OneObjectCache): number {\r\n    const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\r\n    const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\r\n    return (\r\n      ES.ISODateToEpochDays(twoIso.year, twoIso.month - 1, twoIso.day) -\r\n      ES.ISODateToEpochDays(oneIso.year, oneIso.month - 1, oneIso.day)\r\n    );\r\n  }\r\n  // Override if calendar uses eras\r\n  hasEra = false;\r\n  // See https://github.com/tc39/proposal-temporal/issues/1784\r\n  erasBeginMidYear = false;\r\n  // Override this to shortcut the search space if certain month codes only\r\n  // occur long in the past\r\n  monthDaySearchStartYear(monthCode: string, day: number) {\r\n    void monthCode, day;\r\n    return 1972;\r\n  }\r\n  monthDayFromFields(fields: MonthDayFromFieldsObject, overflow: Overflow, cache: OneObjectCache): ISODate {\r\n    let { era, eraYear, year, month, monthCode, day } = fields;\r\n    if (month !== undefined && year === undefined && (!this.hasEra || era === undefined || eraYear === undefined)) {\r\n      throw new TypeError('when month is present, year (or era and eraYear) are required');\r\n    }\r\n    if (monthCode === undefined || year !== undefined || (this.hasEra && eraYear !== undefined)) {\r\n      // Apply overflow behaviour to year/month/day, to get correct monthCode/day\r\n      ({ monthCode, day } = this.isoToCalendarDate(this.calendarToIsoDate(fields, overflow, cache), cache));\r\n    }\r\n\r\n    let isoYear, isoMonth, isoDay;\r\n    let closestCalendar, closestIso;\r\n    // Look backwards starting from one of the calendar years spanning ISO year\r\n    // 1972, up to 20 calendar years prior, to find a year that has this month\r\n    // and day. Normal months and days will match immediately, but for leap days\r\n    // and leap months we may have to look for a while. For searches longer than\r\n    // 20 years, override the start date in monthDaySearchStartYear.\r\n    const startDateIso = {\r\n      year: this.monthDaySearchStartYear(monthCode, day),\r\n      month: 12,\r\n      day: 31\r\n    };\r\n    const calendarOfStartDateIso = this.isoToCalendarDate(startDateIso, cache);\r\n    // Note: relies on lexicographical ordering of monthCodes\r\n    const calendarYear =\r\n      calendarOfStartDateIso.monthCode > monthCode ||\r\n      (calendarOfStartDateIso.monthCode === monthCode && calendarOfStartDateIso.day >= day)\r\n        ? calendarOfStartDateIso.year\r\n        : calendarOfStartDateIso.year - 1;\r\n    for (let i = 0; i < 20; i++) {\r\n      const testCalendarDate: FullCalendarDate = this.adjustCalendarDate(\r\n        { day, monthCode, year: calendarYear - i },\r\n        cache\r\n      );\r\n      const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\r\n      const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\r\n      ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\r\n      if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\r\n        return { month: isoMonth, day: isoDay, year: isoYear };\r\n      } else if (overflow === 'constrain') {\r\n        // If the requested day is never present in any instance of this month\r\n        // code, and the round trip date is an instance of this month code with\r\n        // the most possible days, we are as close as we can get.\r\n        const maxDayForMonthCode = this.maxLengthOfMonthCodeInAnyYear(roundTripCalendarDate.monthCode);\r\n        if (\r\n          roundTripCalendarDate.monthCode === monthCode &&\r\n          roundTripCalendarDate.day === maxDayForMonthCode &&\r\n          day > maxDayForMonthCode\r\n        ) {\r\n          return { month: isoMonth, day: isoDay, year: isoYear };\r\n        }\r\n        // non-ISO constrain algorithm tries to find the closest date in a matching month\r\n        if (\r\n          closestCalendar === undefined ||\r\n          (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\r\n            roundTripCalendarDate.day > closestCalendar.day)\r\n        ) {\r\n          closestCalendar = roundTripCalendarDate;\r\n          closestIso = isoDate;\r\n        }\r\n      }\r\n    }\r\n    if (overflow === 'constrain' && closestIso !== undefined) return closestIso;\r\n    throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\r\n  }\r\n  getFirstDayOfWeek(): number | undefined {\r\n    return undefined;\r\n  }\r\n  getMinimalDaysInFirstWeek(): number | undefined {\r\n    return undefined;\r\n  }\r\n}\r\n\r\ninterface HebrewMonthInfo {\r\n  [m: string]: (\r\n    | {\r\n        leap: undefined;\r\n        regular: number;\r\n      }\r\n    | {\r\n        leap: number;\r\n        regular: undefined;\r\n      }\r\n    | {\r\n        leap: number;\r\n        regular: number;\r\n      }\r\n  ) & {\r\n    monthCode: string;\r\n    days:\r\n      | number\r\n      | {\r\n          min: number;\r\n          max: number;\r\n        };\r\n  };\r\n}\r\n\r\nclass HebrewHelper extends HelperBase {\r\n  id = 'hebrew' as const;\r\n  calendarType = 'lunisolar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    const { year } = calendarDate;\r\n    // FYI: In addition to adding a month in leap years, the Hebrew calendar\r\n    // also has per-year changes to the number of days of Heshvan and Kislev.\r\n    // Given that these can be calculated by counting the number of days in\r\n    // those months, I assume that these DO NOT need to be exposed as\r\n    // Hebrew-only prototype fields or methods.\r\n    return (7 * year + 1) % 19 < 7;\r\n  }\r\n  monthsInYear(calendarDate: CalendarYearOnly) {\r\n    return this.inLeapYear(calendarDate) ? 13 : 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    return this.minMaxMonthLength(calendarDate, 'min');\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    return this.minMaxMonthLength(calendarDate, 'max');\r\n  }\r\n  minMaxMonthLength(calendarDate: CalendarYM, minOrMax: 'min' | 'max') {\r\n    const { month, year } = calendarDate;\r\n    const monthCode = this.getMonthCode(year, month);\r\n    const monthInfo = Object.entries(this.months).find((m) => m[1].monthCode === monthCode);\r\n    if (monthInfo === undefined) throw new RangeError(`unmatched Hebrew month: ${month}`);\r\n    const daysInMonth = monthInfo[1].days;\r\n    return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    return ['M04', 'M06', 'M08', 'M10', 'M12'].includes(monthCode) ? 29 : 30;\r\n  }\r\n  /** Take a guess at what ISO date a particular calendar date corresponds to */\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year } = calendarDate;\r\n    return { year: year - 3760, month: 1, day: 1 };\r\n  }\r\n  months: HebrewMonthInfo = {\r\n    Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\r\n    Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\r\n    Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\r\n    Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\r\n    Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\r\n    Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\r\n    'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\r\n    'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\r\n    Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\r\n    Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\r\n    Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\r\n    Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\r\n    Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\r\n    Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\r\n  };\r\n  getMonthCode(year: number, month: number) {\r\n    if (this.inLeapYear({ year })) {\r\n      return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\r\n    } else {\r\n      return buildMonthCode(month);\r\n    }\r\n  }\r\n  override adjustCalendarDate(\r\n    calendarDate: Partial<FullCalendarDate>,\r\n    cache?: OneObjectCache,\r\n    overflow: Overflow = 'constrain',\r\n    fromLegacyDate = false\r\n  ): FullCalendarDate {\r\n    let { year, month, monthCode, day, monthExtra } = calendarDate as Omit<typeof calendarDate, 'day'> & {\r\n      day: number;\r\n    };\r\n    if (year === undefined) throw new TypeError('Missing property: year');\r\n    if (fromLegacyDate) {\r\n      // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\r\n      // output returns the numeric equivalent of `month` as a string, meaning\r\n      // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\r\n      // means Adar. In this case, `month` will already be correct and no action\r\n      // is needed. However, in Node 14 and later formatToParts returns the name\r\n      // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\r\n      // correct `month` using the string name as a key.\r\n      if (monthExtra) {\r\n        const monthInfo = this.months[monthExtra];\r\n        if (!monthInfo) throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\r\n        month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\r\n      }\r\n      // Because we're getting data from legacy Date, then `month` will always be present\r\n      monthCode = this.getMonthCode(year, month as number);\r\n      return { year, month: month as number, day, monthCode };\r\n    } else {\r\n      // When called without input coming from legacy Date output, simply ensure\r\n      // that all fields are present.\r\n      this.validateCalendarDate(calendarDate);\r\n      if (month === undefined) {\r\n        ES.assertExists(monthCode);\r\n        if (monthCode.endsWith('L')) {\r\n          if (monthCode !== 'M05L') {\r\n            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\r\n          }\r\n          month = 6;\r\n          if (!this.inLeapYear({ year })) {\r\n            if (overflow === 'reject') {\r\n              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\r\n            } else {\r\n              // constrain to same day of next month (Adar)\r\n              month = 6;\r\n              monthCode = 'M06';\r\n            }\r\n          }\r\n        } else {\r\n          month = nonLeapMonthCodeNumberPart(monthCode);\r\n          // if leap month is before this one, the month index is one more than the month code\r\n          if (this.inLeapYear({ year }) && month >= 6) month++;\r\n          const largestMonth = this.monthsInYear({ year });\r\n          if (month < 1 || month > largestMonth) throw new RangeError(`Invalid monthCode: ${monthCode}`);\r\n        }\r\n      } else {\r\n        if (overflow === 'reject') {\r\n          ES.RejectToRange(month, 1, this.monthsInYear({ year }));\r\n          ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\r\n        } else {\r\n          month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\r\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\r\n        }\r\n        if (monthCode === undefined) {\r\n          monthCode = this.getMonthCode(year, month);\r\n        } else {\r\n          const calculatedMonthCode = this.getMonthCode(year, month);\r\n          if (calculatedMonthCode !== monthCode) {\r\n            throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\r\n          }\r\n        }\r\n      }\r\n      return { ...calendarDate, day, month, monthCode, year };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * For Temporal purposes, the Islamic calendar is simple because it's always the\r\n * same 12 months in the same order.\r\n */\r\nabstract class IslamicBaseHelper extends HelperBase {\r\n  abstract override id: BuiltinCalendarId;\r\n  calendarType = 'lunar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    const startOfYearCalendar = { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\r\n    const startOfNextYearCalendar = { year: calendarDate.year + 1, month: 1, monthCode: 'M01', day: 1 };\r\n    const result = this.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\r\n    return result === 355;\r\n  }\r\n  monthsInYear(/* calendarYear, cache */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(/* calendarDate */) {\r\n    return 29;\r\n  }\r\n  maximumMonthLength(/* calendarDate */) {\r\n    return 30;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(/* monthCode */) {\r\n    return 30;\r\n  }\r\n  DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\r\n  DAYS_PER_ISO_YEAR = 365.2425;\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year } = this.adjustCalendarDate(calendarDate);\r\n    return { year: Math.floor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\r\n  }\r\n}\r\n\r\n// There are 6 Islamic calendars with the same implementation in this polyfill.\r\n// They vary only in their ID. They do emit different output from the underlying\r\n// Intl implementation, but our code for each of them is identical.\r\nclass IslamicHelper extends IslamicBaseHelper {\r\n  id = 'islamic' as const;\r\n}\r\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\r\n  id = 'islamic-umalqura' as const;\r\n}\r\nclass IslamicTblaHelper extends IslamicBaseHelper {\r\n  id = 'islamic-tbla' as const;\r\n}\r\nclass IslamicCivilHelper extends IslamicBaseHelper {\r\n  id = 'islamic-civil' as const;\r\n}\r\nclass IslamicRgsaHelper extends IslamicBaseHelper {\r\n  id = 'islamic-rgsa' as const;\r\n}\r\nclass IslamicCcHelper extends IslamicBaseHelper {\r\n  id = 'islamicc' as const;\r\n}\r\n\r\nclass PersianHelper extends HelperBase {\r\n  id = 'persian' as const;\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    // If the last month has 30 days, it's a leap year.\r\n    return this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache) === 30;\r\n  }\r\n  monthsInYear(/* calendarYear, cache */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    if (month === 12) return 29;\r\n    return month <= 6 ? 31 : 30;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    if (month === 12) return 30;\r\n    return month <= 6 ? 31 : 30;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    return month <= 6 ? 31 : 30;\r\n  }\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year } = this.adjustCalendarDate(calendarDate);\r\n    return { year: year + 621, month: 1, day: 1 };\r\n  }\r\n}\r\n\r\ninterface IndianMonthInfo {\r\n  [month: number]: {\r\n    length: number;\r\n    month: number;\r\n    day: number;\r\n    leap?: {\r\n      length: number;\r\n      month: number;\r\n      day: number;\r\n    };\r\n    nextYear?: true | undefined;\r\n  };\r\n}\r\n\r\nclass IndianHelper extends HelperBase {\r\n  id = 'indian' as const;\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    // From https://en.wikipedia.org/wiki/Indian_national_calendar:\r\n    // Years are counted in the Saka era, which starts its year 0 in the year 78\r\n    // of the Common Era. To determine leap years, add 78 to the Saka year – if\r\n    // the result is a leap year in the Gregorian calendar, then the Saka year\r\n    // is a leap year as well.\r\n    return isGregorianLeapYear(calendarDate.year + 78);\r\n  }\r\n  monthsInYear(/* calendarYear, cache */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    return this.getMonthInfo(calendarDate).length;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    return this.getMonthInfo(calendarDate).length;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    let monthInfo = this.months[month];\r\n    monthInfo = monthInfo.leap ?? monthInfo;\r\n    return monthInfo.length;\r\n  }\r\n  // Indian months always start at the same well-known Gregorian month and\r\n  // day. So this conversion is easy and fast. See\r\n  // https://en.wikipedia.org/wiki/Indian_national_calendar\r\n  months: IndianMonthInfo = {\r\n    1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\r\n    2: { length: 31, month: 4, day: 21 },\r\n    3: { length: 31, month: 5, day: 22 },\r\n    4: { length: 31, month: 6, day: 22 },\r\n    5: { length: 31, month: 7, day: 23 },\r\n    6: { length: 31, month: 8, day: 23 },\r\n    7: { length: 30, month: 9, day: 23 },\r\n    8: { length: 30, month: 10, day: 23 },\r\n    9: { length: 30, month: 11, day: 22 },\r\n    10: { length: 30, month: 12, day: 22 },\r\n    11: { length: 30, month: 1, nextYear: true, day: 21 },\r\n    12: { length: 30, month: 2, nextYear: true, day: 20 }\r\n  };\r\n  getMonthInfo(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    let monthInfo = this.months[month];\r\n    if (monthInfo === undefined) throw new RangeError(`Invalid month: ${month}`);\r\n    if (this.inLeapYear(calendarDate) && monthInfo.leap) monthInfo = monthInfo.leap;\r\n    return monthInfo;\r\n  }\r\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\r\n    // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\r\n    // calendar fast!\r\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\r\n    const monthInfo = this.getMonthInfo(calendarDate);\r\n    const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\r\n    const isoMonth = monthInfo.month;\r\n    const isoDay = monthInfo.day;\r\n    const isoDate = ES.BalanceISODate(isoYear, isoMonth, isoDay + calendarDate.day - 1);\r\n    return isoDate;\r\n  }\r\n  // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\r\n  // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\r\n  // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\r\n  // expected.\r\n  vulnerableToBceBug =\r\n    new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\r\n  override checkIcuBugs(isoDate: ISODate) {\r\n    if (this.vulnerableToBceBug && isoDate.year < 1) {\r\n      throw new RangeError(\r\n        `calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\r\n          ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Era metadata defined for each calendar.\r\n * TODO: instead of optional properties, this should really have rules\r\n * encoded in the type, e.g. isoEpoch is required unless reverseOf is present.\r\n *  */\r\ninterface InputEra {\r\n  /**\r\n   * Era code, used to populate the 'era' field of Temporal instances.\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   */\r\n  code: string;\r\n\r\n  /**\r\n   * Names are additionally accepted as alternate era codes on input, and the\r\n   * first name is also output in error messages (and may be the era code if\r\n   * desired.)\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   * If absent, this field defaults to a single element matching the code.\r\n   */\r\n  names?: string[];\r\n\r\n  /**\r\n   * Signed calendar year where this era begins.Will be\r\n   * 1 (or 0 for zero-based eras) for the anchor era assuming that `year`\r\n   * numbering starts at the beginning of the anchor era, which is true\r\n   * for all ICU calendars except Japanese. If an era starts mid-year\r\n   * then a calendar month and day are included. Otherwise\r\n   * `{ month: 1, day: 1 }` is assumed.\r\n   */\r\n  anchorEpoch?: CalendarYearOnly | CalendarYMD;\r\n\r\n  /** ISO date of the first day of this era */\r\n  isoEpoch?: { year: number; month: number; day: number };\r\n\r\n  /**\r\n   * If present, then this era counts years backwards like BC\r\n   * and this property points to the forward era. This must be\r\n   * the last (oldest) era in the array.\r\n   * */\r\n  reverseOf?: string;\r\n\r\n  /**\r\n   * If true, the era's years are 0-based. If omitted or false,\r\n   * then the era's years are 1-based.\r\n   * */\r\n  hasYearZero?: boolean;\r\n\r\n  /**\r\n   * Override if this era is the anchor. Not normally used because\r\n   * anchor eras are inferred.\r\n   * */\r\n  isAnchor?: boolean;\r\n}\r\n/**\r\n * Transformation of the `InputEra` type with all fields filled in by\r\n * `adjustEras()`\r\n * */\r\ninterface Era {\r\n  /**\r\n   * Era code, used to populate the 'era' field of Temporal instances.\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   */\r\n  code: string;\r\n\r\n  /**\r\n   * Names are additionally accepted as alternate era codes on input, and the\r\n   * first name is also output in error messages (and may be the era code if\r\n   * desired.)\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   * If absent, this field defaults to a single element matching the code.\r\n   */\r\n  names: string[];\r\n\r\n  /**\r\n   * alternate name of the era used in old versions of ICU data\r\n   * format is `era{n}` where n is the zero-based index of the era\r\n   * with the oldest era being 0.\r\n   * */\r\n  genericName: string;\r\n\r\n  /**\r\n   * Signed calendar year where this era begins. Will be 1 (or 0 for zero-based\r\n   * eras) for the anchor era assuming that `year` numbering starts at the\r\n   * beginning of the anchor era, which is true for all ICU calendars except\r\n   * Japanese. For input, the month and day are optional. If an era starts\r\n   * mid-year then a calendar month and day are included.\r\n   * Otherwise `{ month: 1, day: 1 }` is assumed.\r\n   */\r\n  anchorEpoch: CalendarYMD;\r\n\r\n  /** ISO date of the first day of this era */\r\n  isoEpoch: ISODate;\r\n\r\n  /**\r\n   * If present, then this era counts years backwards like BC\r\n   * and this property points to the forward era. This must be\r\n   * the last (oldest) era in the array.\r\n   * */\r\n  reverseOf?: Era;\r\n\r\n  /**\r\n   * If true, the era's years are 0-based. If omitted or false,\r\n   * then the era's years are 1-based.\r\n   * */\r\n  hasYearZero?: boolean;\r\n\r\n  /**\r\n   * Override if this era is the anchor. Not normally used because\r\n   * anchor eras are inferred.\r\n   * */\r\n  isAnchor?: boolean;\r\n}\r\n\r\n/**\r\n * This function adds additional metadata that makes it easier to work with\r\n * eras. Note that it mutates and normalizes the original era objects, which is\r\n * OK because this is non-observable, internal-only metadata.\r\n *\r\n * The result is an array of eras with the shape defined above.\r\n * */\r\nfunction adjustEras(erasParam: InputEra[]): { eras: Era[]; anchorEra: Era } {\r\n  let eras: (InputEra | Era)[] = erasParam;\r\n  if (eras.length === 0) {\r\n    throw new RangeError('Invalid era data: eras are required');\r\n  }\r\n  if (eras.length === 1 && eras[0].reverseOf) {\r\n    throw new RangeError('Invalid era data: anchor era cannot count years backwards');\r\n  }\r\n  if (eras.length === 1 && !eras[0].code) {\r\n    throw new RangeError('Invalid era data: at least one named era is required');\r\n  }\r\n  if (eras.filter((e) => e.reverseOf != null).length > 1) {\r\n    throw new RangeError('Invalid era data: only one era can count years backwards');\r\n  }\r\n\r\n  // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\r\n  // eras can never be anchors. The era without an `anchorEpoch` property is the\r\n  // anchor.\r\n  let anchorEra: Era | InputEra | undefined;\r\n  eras.forEach((e) => {\r\n    if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\r\n      if (anchorEra) throw new RangeError('Invalid era data: cannot have multiple anchor eras');\r\n      anchorEra = e;\r\n      e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\r\n    } else if (!e.code) {\r\n      throw new RangeError('If era name is blank, it must be the anchor era');\r\n    }\r\n  });\r\n\r\n  // If the era name is undefined, then it's an anchor that doesn't interact\r\n  // with eras at all. For example, Japanese `year` is always the same as ISO\r\n  // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\r\n  // Strip it from the list that's returned.\r\n  eras = eras.filter((e) => e.code);\r\n\r\n  eras.forEach((e) => {\r\n    // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\r\n    // Replace the string-valued \"reverseOf\" property with the actual era object\r\n    // that's reversed.\r\n    const { reverseOf } = e;\r\n    if (reverseOf) {\r\n      const reversedEra = eras.find((era) => era.code === reverseOf);\r\n      if (reversedEra === undefined) {\r\n        throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\r\n      }\r\n      e.reverseOf = reversedEra as Era; // genericName property added later\r\n      e.anchorEpoch = reversedEra.anchorEpoch;\r\n      e.isoEpoch = reversedEra.isoEpoch;\r\n    }\r\n    type YMD = {\r\n      year: number;\r\n      month: number;\r\n      day: number;\r\n    };\r\n    if ((e.anchorEpoch as YMD).month === undefined) (e.anchorEpoch as YMD).month = 1;\r\n    if ((e.anchorEpoch as YMD).day === undefined) (e.anchorEpoch as YMD).day = 1;\r\n  });\r\n\r\n  // Ensure that the latest epoch is first in the array. This lets us try to\r\n  // match eras in index order, with the last era getting the remaining older\r\n  // years. Any reverse-signed era must be at the end.\r\n  eras.sort((e1, e2) => {\r\n    if (e1.reverseOf) return 1;\r\n    if (e2.reverseOf) return -1;\r\n    if (!e1.isoEpoch || !e2.isoEpoch) throw new RangeError('Invalid era data: missing ISO epoch');\r\n    return e2.isoEpoch.year - e1.isoEpoch.year;\r\n  });\r\n\r\n  // If there's a reversed era, then the one before it must be the era that's\r\n  // being reversed.\r\n  const lastEraReversed = eras[eras.length - 1].reverseOf;\r\n  if (lastEraReversed) {\r\n    if (lastEraReversed !== eras[eras.length - 2]) {\r\n      throw new RangeError('Invalid era data: invalid reverse-sign era');\r\n    }\r\n  }\r\n\r\n  // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\r\n  // zero-based index, with the oldest era being zero. This format is used by\r\n  // older versions of ICU data.\r\n  eras.forEach((e, i) => {\r\n    (e as Era).genericName = `era${eras.length - 1 - i}`;\r\n  });\r\n\r\n  return { eras: eras as Era[], anchorEra: (anchorEra || eras[0]) as Era };\r\n}\r\n\r\nfunction isGregorianLeapYear(year: number) {\r\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\r\n}\r\n\r\n/** Base for all Gregorian-like calendars. */\r\nabstract class GregorianBaseHelperFixedEpoch extends HelperBase {\r\n  id: BuiltinCalendarId;\r\n  isoEpoch: ISODate;\r\n\r\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\r\n    super();\r\n    this.id = id;\r\n    this.isoEpoch = isoEpoch;\r\n  }\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\r\n    return isGregorianLeapYear(year);\r\n  }\r\n  monthsInYear(/* calendarDate */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM): number {\r\n    const { month } = calendarDate;\r\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\r\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM): number {\r\n    return this.minimumMonthLength(calendarDate);\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\r\n  }\r\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\r\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\r\n    return ES.RegulateISODate(\r\n      calendarDate.year + this.isoEpoch.year,\r\n      calendarDate.month + this.isoEpoch.month,\r\n      calendarDate.day + this.isoEpoch.day,\r\n      'constrain'\r\n    );\r\n  }\r\n}\r\n\r\n/** Base for Gregorian-like calendars with eras. */\r\nabstract class GregorianBaseHelper extends HelperBase {\r\n  id: BuiltinCalendarId;\r\n  anchorEra: Era;\r\n\r\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\r\n    super();\r\n    this.id = id;\r\n    const { eras, anchorEra } = adjustEras(originalEras);\r\n    this.anchorEra = anchorEra;\r\n    this.eras = eras;\r\n  }\r\n  override hasEra = true;\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    // Calendars that don't override this method use the same months and leap\r\n    // years as Gregorian. Once we know the ISO year corresponding to the\r\n    // calendar year, we'll know if it's a leap year or not.\r\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\r\n    return isGregorianLeapYear(year);\r\n  }\r\n  monthsInYear(/* calendarDate */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM): number {\r\n    const { month } = calendarDate;\r\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\r\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM): number {\r\n    return this.minimumMonthLength(calendarDate);\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\r\n  }\r\n  /** Fill in missing parts of the (year, era, eraYear) tuple */\r\n  completeEraYear(\r\n    calendarDate: FullCalendarDate\r\n  ): FullCalendarDate & Required<Pick<FullCalendarDate, 'era' | 'eraYear'>> {\r\n    const checkField = (property: keyof FullCalendarDate, value: string | number | undefined, names?: string[]) => {\r\n      const currentValue = calendarDate[property];\r\n      if (currentValue != null && currentValue != value && !((names || []) as unknown[]).includes(currentValue)) {\r\n        // Prefer displaying an era alias, instead of \"gregory-inverse\"\r\n        const preferredName = names?.[0];\r\n        const expected = preferredName ? `${value} (also called ${preferredName})` : value;\r\n        throw new RangeError(`Input ${property} ${currentValue} doesn't match calculated value ${expected}`);\r\n      }\r\n    };\r\n    const eraFromYear = (year: number) => {\r\n      let eraYear;\r\n      const adjustedCalendarDate = { ...calendarDate, year };\r\n      const matchingEra = this.eras.find((e, i) => {\r\n        if (i === this.eras.length - 1) {\r\n          if (e.reverseOf) {\r\n            // This is a reverse-sign era (like BCE) which must be the oldest\r\n            // era. Count years backwards.\r\n            if (year > 0) throw new RangeError(`Signed year ${year} is invalid for era ${e.code}`);\r\n            eraYear = e.anchorEpoch.year - year;\r\n            return true;\r\n          }\r\n          // last era always gets all \"leftover\" (older than epoch) years,\r\n          // so no need for a comparison like below.\r\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\r\n          return true;\r\n        }\r\n        const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\r\n        if (comparison >= 0) {\r\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n      if (!matchingEra) throw new RangeError(`Year ${year} was not matched by any era`);\r\n      return { eraYear: eraYear as unknown as number, era: matchingEra.code, eraNames: matchingEra.names };\r\n    };\r\n\r\n    let { year, eraYear, era } = calendarDate;\r\n    if (year != null) {\r\n      const matchData = eraFromYear(year);\r\n      ({ eraYear, era } = matchData);\r\n      checkField('era', era, matchData?.eraNames);\r\n      checkField('eraYear', eraYear);\r\n    } else if (eraYear != null) {\r\n      if (era === undefined) throw new RangeError('era and eraYear must be provided together');\r\n      // TS limitation: https://github.com/microsoft/TypeScript/issues/11498\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      const matchingEra = this.eras.find(({ code, names = [] }) => code === era || names.includes(era!));\r\n      if (!matchingEra) throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\r\n      if (matchingEra.reverseOf) {\r\n        year = matchingEra.anchorEpoch.year - eraYear;\r\n      } else {\r\n        year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\r\n      }\r\n      checkField('year', year);\r\n      // We'll accept dates where the month/day is earlier than the start of\r\n      // the era or after its end as long as it's in the same year. If that\r\n      // happens, we'll adjust the era/eraYear pair to be the correct era for\r\n      // the `year`.\r\n      ({ eraYear, era } = eraFromYear(year));\r\n    } else {\r\n      throw new RangeError('Either year or eraYear and era are required');\r\n    }\r\n    return { ...calendarDate, year, eraYear, era };\r\n  }\r\n  override adjustCalendarDate(\r\n    calendarDateParam: Partial<FullCalendarDate>,\r\n    cache?: OneObjectCache,\r\n    overflow: Overflow = 'constrain'\r\n  ): FullCalendarDate {\r\n    let calendarDate = calendarDateParam;\r\n    // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\r\n    const { month, monthCode } = calendarDate;\r\n    if (month === undefined) calendarDate = { ...calendarDate, month: nonLeapMonthCodeNumberPart(monthCode as string) };\r\n    this.validateCalendarDate(calendarDate);\r\n    calendarDate = this.completeEraYear(calendarDate);\r\n    return super.adjustCalendarDate(calendarDate, cache, overflow);\r\n  }\r\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\r\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\r\n    const { year, month, day } = calendarDate;\r\n    const { anchorEra } = this;\r\n    const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\r\n    return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\r\n  }\r\n}\r\n\r\n/**\r\n * Some calendars are identical to Gregorian except era and year. For these\r\n * calendars, we can avoid using Intl.DateTimeFormat and just calculate the\r\n * year, era, and eraYear. This is faster (because Intl.DateTimeFormat is slow\r\n * and uses a huge amount of RAM), and it avoids ICU bugs like\r\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\r\n */\r\nabstract class SameMonthDayAsGregorianBaseHelper extends GregorianBaseHelper {\r\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\r\n    super(id, originalEras);\r\n  }\r\n  override isoToCalendarDate(isoDate: ISODate): FullCalendarDate {\r\n    // Month and day are same as ISO, so bypass Intl.DateTimeFormat and\r\n    // calculate the year, era, and eraYear here.\r\n    const { year: isoYear, month, day } = isoDate;\r\n    const monthCode = buildMonthCode(month);\r\n    const year = isoYear - this.anchorEra.isoEpoch.year + 1;\r\n    return this.completeEraYear({ year, month, monthCode, day });\r\n  }\r\n}\r\nconst OrthodoxOps = {\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    // Leap years happen one year before the Julian leap year. Note that this\r\n    // calendar is based on the Julian calendar which has a leap year every 4\r\n    // years, unlike the Gregorian calendar which doesn't have leap years on\r\n    // years divisible by 100 except years divisible by 400.\r\n    //\r\n    // Note that we're assuming that leap years in before-epoch times match\r\n    // how leap years are defined now. This is probably not accurate but I'm\r\n    // not sure how better to do it.\r\n    const { year } = calendarDate;\r\n    return (year + 1) % 4 === 0;\r\n  },\r\n  monthsInYear(/* calendarDate */) {\r\n    return 13;\r\n  },\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\r\n    if (month === 13) return this.inLeapYear(calendarDate) ? 6 : 5;\r\n    return 30;\r\n  },\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    return this.minimumMonthLength(calendarDate);\r\n  },\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    return monthCode === 'M13' ? 6 : 30;\r\n  }\r\n};\r\nabstract class OrthodoxBaseHelperFixedEpoch extends GregorianBaseHelperFixedEpoch {\r\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\r\n    super(id, isoEpoch);\r\n  }\r\n  override inLeapYear = OrthodoxOps.inLeapYear;\r\n  override monthsInYear = OrthodoxOps.monthsInYear;\r\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\r\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\r\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\r\n}\r\nabstract class OrthodoxBaseHelper extends GregorianBaseHelper {\r\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\r\n    super(id, originalEras);\r\n  }\r\n  override inLeapYear = OrthodoxOps.inLeapYear;\r\n  override monthsInYear = OrthodoxOps.monthsInYear;\r\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\r\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\r\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\r\n}\r\n\r\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\r\n// with the following differences:\r\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\r\n//   two use negative year numbers before epoch)\r\n// - Coptic has a different epoch date\r\n// - Ethiopic has an additional second era that starts at the same date as the\r\n//   zero era of ethioaa.\r\nclass EthioaaHelper extends OrthodoxBaseHelperFixedEpoch {\r\n  constructor() {\r\n    super('ethioaa', { year: -5492, month: 7, day: 17 });\r\n  }\r\n}\r\nclass CopticHelper extends OrthodoxBaseHelper {\r\n  constructor() {\r\n    super('coptic', [\r\n      { code: 'coptic', isoEpoch: { year: 284, month: 8, day: 29 } },\r\n      { code: 'coptic-inverse', reverseOf: 'coptic' }\r\n    ]);\r\n  }\r\n}\r\n\r\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\r\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\r\nclass EthiopicHelper extends OrthodoxBaseHelper {\r\n  constructor() {\r\n    super('ethiopic', [\r\n      { code: 'ethioaa', names: ['ethiopic-amete-alem', 'mundi'], isoEpoch: { year: -5492, month: 7, day: 17 } },\r\n      { code: 'ethiopic', names: ['incar'], isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\r\n    ]);\r\n  }\r\n}\r\n\r\nclass RocHelper extends SameMonthDayAsGregorianBaseHelper {\r\n  constructor() {\r\n    super('roc', [\r\n      { code: 'roc', names: ['minguo'], isoEpoch: { year: 1912, month: 1, day: 1 } },\r\n      { code: 'roc-inverse', names: ['before-roc'], reverseOf: 'roc' }\r\n    ]);\r\n  }\r\n}\r\n\r\nclass BuddhistHelper extends GregorianBaseHelperFixedEpoch {\r\n  constructor() {\r\n    super('buddhist', { year: -543, month: 1, day: 1 });\r\n  }\r\n}\r\n\r\nclass GregoryHelper extends SameMonthDayAsGregorianBaseHelper {\r\n  constructor() {\r\n    super('gregory', [\r\n      { code: 'gregory', names: ['ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\r\n      { code: 'gregory-inverse', names: ['be', 'bce'], reverseOf: 'gregory' }\r\n    ]);\r\n  }\r\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T /*, isoDate: IsoDate*/): T {\r\n    let { era, eraYear } = calendarDate;\r\n    // Firefox 96 introduced a bug where the `'short'` format of the era\r\n    // option mistakenly returns the one-letter (narrow) format instead. The\r\n    // code below handles either the correct or Firefox-buggy format. See\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\r\n    if (era === 'b') era = 'gregory-inverse';\r\n    if (era === 'a') era = 'gregory';\r\n    return { era, eraYear } as T;\r\n  }\r\n}\r\n\r\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\r\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\r\n// eras include:\r\n// - Start/end dates of older eras are not precisely defined, which is\r\n//   challenging given Temporal's need for precision\r\n// - Some era dates and/or names are disputed by historians\r\n// - As historical research proceeds, new eras are discovered and existing era\r\n//   dates are modified, leading to considerable churn which is not good for\r\n//   Temporal use.\r\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\r\n//    on future historical scholarship\r\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\r\n//    that's not reflected in the ICU implementation.\r\n//\r\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\r\n//\r\n// Here's a full list of CLDR/ICU eras:\r\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\r\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\r\n//\r\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\r\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\r\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\r\n// Japanese calendar doesn't seem to take this into account, so neither do we:\r\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\r\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\r\n// '1 1, 6 Meiji, 12:00:00 PM'\r\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\r\n// '12 31, 5 Meiji, 12:00:00 PM'\r\nclass JapaneseHelper extends SameMonthDayAsGregorianBaseHelper {\r\n  constructor() {\r\n    super('japanese', [\r\n      // The Japanese calendar `year` is just the ISO year, because (unlike other\r\n      // ICU calendars) there's no obvious \"default era\", we use the ISO year.\r\n      { code: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\r\n      { code: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\r\n      { code: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\r\n      { code: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\r\n      { code: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\r\n      { code: 'japanese', names: ['japanese', 'gregory', 'ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\r\n      { code: 'japanese-inverse', names: ['japanese-inverse', 'gregory-inverse', 'bc', 'bce'], reverseOf: 'japanese' }\r\n    ]);\r\n  }\r\n\r\n  override erasBeginMidYear = true;\r\n\r\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T {\r\n    const { era, eraYear } = calendarDate;\r\n    const { year: isoYear } = isoDate;\r\n    if (this.eras.find((e) => e.code === era)) return { era, eraYear } as T;\r\n    return (\r\n      isoYear < 1 ? { era: 'japanese-inverse', eraYear: 1 - isoYear } : { era: 'japanese', eraYear: isoYear }\r\n    ) as T;\r\n  }\r\n}\r\n\r\ninterface ChineseMonthInfo {\r\n  [key: string]: { monthIndex: number; daysInMonth: number };\r\n}\r\ninterface ChineseDraftMonthInfo {\r\n  [key: string]: { monthIndex: number; daysInMonth?: number };\r\n}\r\n\r\nabstract class ChineseBaseHelper extends HelperBase {\r\n  abstract override id: BuiltinCalendarId;\r\n  calendarType = 'lunisolar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    const months = this.getMonthList(calendarDate.year, cache);\r\n    return Object.entries(months).length === 13;\r\n  }\r\n  monthsInYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    return this.inLeapYear(calendarDate, cache) ? 13 : 12;\r\n  }\r\n  minimumMonthLength(/* calendarDate */) {\r\n    return 29;\r\n  }\r\n  maximumMonthLength(/* calendarDate */) {\r\n    return 30;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    // See note below about ICU4C vs ICU4X. It is possible this override should\r\n    // always return 30.\r\n    return ['M01L', 'M09L', 'M10L', 'M11L', 'M12L'].includes(monthCode) ? 29 : 30;\r\n  }\r\n  override monthDaySearchStartYear(monthCode: string, day: number) {\r\n    // Note that ICU4C actually has _no_ years in which leap months M01L and\r\n    // M09L through M12L have 30 days. The values marked with (*) here are years\r\n    // in which the leap month occurs with 29 days. ICU4C disagrees with ICU4X\r\n    // here and it is not clear which is correct.\r\n    const monthMap: Record<string, [number, number]> = {\r\n      M01L: [1651, 1651], // *\r\n      M02L: [1947, 1765],\r\n      M03L: [1966, 1955],\r\n      M04L: [1963, 1944],\r\n      M05L: [1971, 1952],\r\n      M06L: [1960, 1941],\r\n      M07L: [1968, 1938],\r\n      M08L: [1957, 1718],\r\n      M09L: [1832, 1832], // *\r\n      M10L: [1870, 1870], // *\r\n      M11L: [1814, 1814], // *\r\n      M12L: [1890, 1890] // *\r\n    };\r\n    const years = monthMap[monthCode] ?? [1972, 1972];\r\n    return day < 30 ? years[0] : years[1];\r\n  }\r\n  getMonthList(calendarYear: number, cache: OneObjectCache): ChineseMonthInfo {\r\n    if (calendarYear === undefined) {\r\n      throw new TypeError('Missing year');\r\n    }\r\n    const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\r\n    const cached = cache.get(key);\r\n    if (cached) return cached;\r\n    const dateTimeFormat = this.getFormatter();\r\n    const getCalendarDate = (isoYear: number, daysPastFeb1: number) => {\r\n      const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\r\n      const legacyDate = new Date(isoStringFeb1);\r\n      // Now add the requested number of days, which may wrap to the next month.\r\n      legacyDate.setUTCDate(daysPastFeb1 + 1);\r\n      const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\r\n      // The 'month' and 'day' parts are guaranteed to be present because the\r\n      // formatter was created with month and day options.\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month')!.value;\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      const calendarDay = +newYearGuess.find((tv) => tv.type === 'day')!.value;\r\n      const calendarYearPartToVerify = newYearGuess.find((tv) => (tv.type as string) === 'relatedYear');\r\n      let calendarYearToVerify: number | undefined;\r\n      if (calendarYearPartToVerify !== undefined) {\r\n        calendarYearToVerify = +calendarYearPartToVerify.value;\r\n      } else {\r\n        // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\r\n        // output of Intl.DateTimeFormat.formatToParts.\r\n        throw new RangeError(\r\n          `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\r\n        );\r\n      }\r\n      return { calendarMonthString, calendarDay, calendarYearToVerify };\r\n    };\r\n\r\n    // First, find a date close to Chinese New Year. Feb 17 will either be in\r\n    // the first month or near the end of the last month of the previous year.\r\n    let isoDaysDelta = 17;\r\n    let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\r\n\r\n    // If we didn't guess the first month correctly, add (almost in some months)\r\n    // a lunar month\r\n    if (calendarMonthString !== '1') {\r\n      isoDaysDelta += 29;\r\n      ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\r\n    }\r\n\r\n    // Now back up to near the start of the first month, but not too near that\r\n    // off-by-one issues matter.\r\n    isoDaysDelta -= calendarDay - 5;\r\n    const result = {} as ChineseDraftMonthInfo;\r\n    let monthIndex = 1;\r\n    let oldCalendarDay: number | undefined;\r\n    let oldMonthString: string | undefined;\r\n    let done = false;\r\n    do {\r\n      ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\r\n      if (oldCalendarDay) {\r\n        result[oldMonthString as string].daysInMonth = oldCalendarDay + 30 - calendarDay;\r\n      }\r\n      if (calendarYearToVerify !== calendarYear) {\r\n        done = true;\r\n      } else {\r\n        result[calendarMonthString] = { monthIndex: monthIndex++ };\r\n        // Move to the next month. Because months are sometimes 29 days, the day of the\r\n        // calendar month will move forward slowly but not enough to flip over to a new\r\n        // month before the loop ends at 12-13 months.\r\n        isoDaysDelta += 30;\r\n      }\r\n      oldCalendarDay = calendarDay;\r\n      oldMonthString = calendarMonthString;\r\n    } while (!done);\r\n    result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\r\n\r\n    cache.set(key, result);\r\n    return result as ChineseMonthInfo;\r\n  }\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year, month } = calendarDate;\r\n    return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\r\n  }\r\n  override adjustCalendarDate(\r\n    calendarDate: Partial<FullCalendarDate>,\r\n    cache: OneObjectCache,\r\n    overflow: Overflow = 'constrain',\r\n    fromLegacyDate = false\r\n  ): FullCalendarDate {\r\n    let { year, month, monthExtra, day, monthCode } = calendarDate;\r\n    if (year === undefined) throw new TypeError('Missing property: year');\r\n    if (fromLegacyDate) {\r\n      // Legacy Date output returns a string that's an integer with an optional\r\n      // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\r\n      // month. Below we'll normalize the output.\r\n      if (monthExtra && monthExtra !== 'bis') throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\r\n      const monthCode = buildMonthCode(month as number, monthExtra !== undefined);\r\n      const monthString = `${month}${monthExtra || ''}`;\r\n      const months = this.getMonthList(year, cache);\r\n      const monthInfo = months[monthString];\r\n      if (monthInfo === undefined) throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\r\n      month = monthInfo.monthIndex;\r\n      return { year, month, day: day as number, monthCode };\r\n    } else {\r\n      // When called without input coming from legacy Date output,\r\n      // simply ensure that all fields are present.\r\n      this.validateCalendarDate(calendarDate);\r\n      if (month === undefined) {\r\n        ES.assertExists(monthCode);\r\n        const months = this.getMonthList(year, cache);\r\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\r\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\r\n        let monthInfo = months[numberPart];\r\n        month = monthInfo && monthInfo.monthIndex;\r\n\r\n        // If this leap month isn't present in this year, constrain to the same\r\n        // day of the previous month.\r\n        if (month === undefined && monthCode.endsWith('L') && monthCode != 'M13L' && overflow === 'constrain') {\r\n          const withoutML = +monthCode.replace(/^M0?|L$/g, '');\r\n          monthInfo = months[withoutML];\r\n          if (monthInfo) {\r\n            month = monthInfo.monthIndex;\r\n            monthCode = buildMonthCode(withoutML);\r\n          }\r\n        }\r\n        if (month === undefined) {\r\n          throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\r\n        }\r\n      } else if (monthCode === undefined) {\r\n        const months = this.getMonthList(year, cache);\r\n        const monthEntries = Object.entries(months);\r\n        const largestMonth = monthEntries.length;\r\n        if (overflow === 'reject') {\r\n          ES.RejectToRange(month, 1, largestMonth);\r\n          ES.RejectToRange(day as number, 1, this.maximumMonthLength());\r\n        } else {\r\n          month = ES.ConstrainToRange(month, 1, largestMonth);\r\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\r\n        }\r\n        const matchingMonthEntry = monthEntries.find((entry) => entry[1].monthIndex === month);\r\n        if (matchingMonthEntry === undefined) {\r\n          throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\r\n        }\r\n        monthCode = buildMonthCode(\r\n          +matchingMonthEntry[0].replace('bis', ''),\r\n          matchingMonthEntry[0].indexOf('bis') !== -1\r\n        );\r\n      } else {\r\n        // Both month and monthCode are present. Make sure they don't conflict.\r\n        const months = this.getMonthList(year, cache);\r\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\r\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\r\n        const monthInfo = months[numberPart];\r\n        if (!monthInfo) throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\r\n        if (month !== monthInfo.monthIndex) {\r\n          throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\r\n        }\r\n      }\r\n      return { ...calendarDate, year, month, monthCode, day: day as number };\r\n    }\r\n  }\r\n}\r\n\r\nclass ChineseHelper extends ChineseBaseHelper {\r\n  id = 'chinese' as const;\r\n}\r\n\r\n// Dangi (Korean) calendar has same implementation as Chinese\r\nclass DangiHelper extends ChineseBaseHelper {\r\n  id = 'dangi' as const;\r\n}\r\n\r\n/**\r\n * Common implementation of all non-ISO calendars.\r\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\r\n * This split allowed an easy separation between code that was similar between\r\n * ISO and non-ISO implementations vs. code that was very different.\r\n */\r\nclass NonIsoCalendar implements CalendarImpl {\r\n  constructor(private readonly helper: HelperBase) {}\r\n  extraFields(fields: FieldKey[]): FieldKey[] {\r\n    if (this.helper.hasEra && fields.includes('year')) {\r\n      return ['era', 'eraYear'];\r\n    }\r\n    return [];\r\n  }\r\n  resolveFields(fields: CalendarFieldsRecord /* , type */) {\r\n    if (this.helper.calendarType !== 'lunisolar') {\r\n      const cache = new OneObjectCache();\r\n      const largestMonth = this.helper.monthsInYear({ year: fields.year ?? 1972 }, cache);\r\n      resolveNonLunisolarMonth(fields, undefined, largestMonth);\r\n    }\r\n  }\r\n  dateToISO(fields: CalendarDateFields, overflow: Overflow) {\r\n    const cache = new OneObjectCache();\r\n    const result = this.helper.calendarToIsoDate(fields, overflow, cache);\r\n    cache.setObject(result);\r\n    return result;\r\n  }\r\n  monthDayToISOReferenceDate(fields: MonthDayFromFieldsObject, overflow: Overflow) {\r\n    const cache = new OneObjectCache();\r\n    const result = this.helper.monthDayFromFields(fields, overflow, cache);\r\n    // result.year is a reference year where this month/day exists in this calendar\r\n    cache.setObject(result);\r\n    return result;\r\n  }\r\n  fieldKeysToIgnore(\r\n    keys: Exclude<keyof Temporal.PlainDateLike, 'calendar'>[]\r\n  ): Exclude<keyof Temporal.PlainDateLike, 'calendar'>[] {\r\n    const result = new Set<(typeof keys)[number]>();\r\n    for (let ix = 0; ix < keys.length; ix++) {\r\n      const key = keys[ix];\r\n      result.add(key);\r\n      switch (key) {\r\n        case 'era':\r\n          result.add('eraYear');\r\n          result.add('year');\r\n          break;\r\n        case 'eraYear':\r\n          result.add('era');\r\n          result.add('year');\r\n          break;\r\n        case 'year':\r\n          result.add('era');\r\n          result.add('eraYear');\r\n          break;\r\n        case 'month':\r\n          result.add('monthCode');\r\n          // See https://github.com/tc39/proposal-temporal/issues/1784\r\n          if (this.helper.erasBeginMidYear) {\r\n            result.add('era');\r\n            result.add('eraYear');\r\n          }\r\n          break;\r\n        case 'monthCode':\r\n          result.add('month');\r\n          if (this.helper.erasBeginMidYear) {\r\n            result.add('era');\r\n            result.add('eraYear');\r\n          }\r\n          break;\r\n        case 'day':\r\n          if (this.helper.erasBeginMidYear) {\r\n            result.add('era');\r\n            result.add('eraYear');\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    return arrayFromSet(result);\r\n  }\r\n  dateAdd(isoDate: ISODate, { years, months, weeks, days }: DateDuration, overflow: Overflow) {\r\n    const cache = OneObjectCache.getCacheForObject(isoDate);\r\n    const calendarDate = this.helper.isoToCalendarDate(isoDate, cache);\r\n    const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\r\n    const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\r\n    // The new object's cache starts with the cache of the old object\r\n    if (!OneObjectCache.getCacheForObject(isoAdded)) {\r\n      const newCache = new OneObjectCache(cache);\r\n      newCache.setObject(isoAdded);\r\n    }\r\n    return isoAdded;\r\n  }\r\n  dateUntil(one: ISODate, two: ISODate, largestUnit: Temporal.DateUnit) {\r\n    const cacheOne = OneObjectCache.getCacheForObject(one);\r\n    const cacheTwo = OneObjectCache.getCacheForObject(two);\r\n    const calendarOne = this.helper.isoToCalendarDate(one, cacheOne);\r\n    const calendarTwo = this.helper.isoToCalendarDate(two, cacheTwo);\r\n    const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\r\n    return result;\r\n  }\r\n  isoToDate<\r\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\r\n    T extends {\r\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\r\n    }\r\n  >(isoDate: ISODate, requestedFields: Request): T {\r\n    const cache = OneObjectCache.getCacheForObject(isoDate);\r\n    const calendarDate: Partial<CalendarDateRecord> & FullCalendarDate = this.helper.isoToCalendarDate(isoDate, cache);\r\n    if (requestedFields.dayOfWeek) {\r\n      calendarDate.dayOfWeek = impl['iso8601'].isoToDate(isoDate, { dayOfWeek: true }).dayOfWeek;\r\n    }\r\n    if (requestedFields.dayOfYear) {\r\n      const startOfYear = this.helper.startOfCalendarYear(calendarDate);\r\n      const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\r\n      calendarDate.dayOfYear = diffDays + 1;\r\n    }\r\n    if (requestedFields.weekOfYear) calendarDate.weekOfYear = calendarDateWeekOfYear(this.helper.id, isoDate);\r\n    calendarDate.daysInWeek = 7;\r\n    if (requestedFields.daysInMonth) calendarDate.daysInMonth = this.helper.daysInMonth(calendarDate, cache);\r\n    if (requestedFields.daysInYear) {\r\n      const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\r\n      const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\r\n      calendarDate.daysInYear = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\r\n    }\r\n    if (requestedFields.monthsInYear) calendarDate.monthsInYear = this.helper.monthsInYear(calendarDate, cache);\r\n    if (requestedFields.inLeapYear) calendarDate.inLeapYear = this.helper.inLeapYear(calendarDate, cache);\r\n    return calendarDate as T;\r\n  }\r\n  getFirstDayOfWeek(): number | undefined {\r\n    return this.helper.getFirstDayOfWeek();\r\n  }\r\n  getMinimalDaysInFirstWeek(): number | undefined {\r\n    return this.helper.getMinimalDaysInFirstWeek();\r\n  }\r\n}\r\n\r\nfor (const Helper of [\r\n  HebrewHelper,\r\n  PersianHelper,\r\n  EthiopicHelper,\r\n  EthioaaHelper,\r\n  CopticHelper,\r\n  ChineseHelper,\r\n  DangiHelper,\r\n  RocHelper,\r\n  IndianHelper,\r\n  BuddhistHelper,\r\n  GregoryHelper,\r\n  JapaneseHelper,\r\n  IslamicHelper,\r\n  IslamicUmalquraHelper,\r\n  IslamicTblaHelper,\r\n  IslamicCivilHelper,\r\n  IslamicRgsaHelper,\r\n  IslamicCcHelper\r\n]) {\r\n  const helper = new Helper();\r\n  // Construct a new NonIsoCalendar instance with the given Helper implementation that contains\r\n  // per-calendar logic.\r\n  impl[helper.id] = new NonIsoCalendar(helper);\r\n}\r\n\r\nfunction calendarImpl(calendar: BuiltinCalendarId) {\r\n  return impl[calendar];\r\n}\r\n// Probably not what the intrinsics mechanism was intended for, but view this as\r\n// an export of calendarImpl while avoiding circular dependencies\r\nDefineIntrinsic('calendarImpl', calendarImpl);\r\n","import { assert } from './assert';\r\nimport * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport {\r\n  CAL_ID,\r\n  CALENDAR,\r\n  CreateSlots,\r\n  DATE,\r\n  DATETIME,\r\n  DAYS,\r\n  EPOCHNANOSECONDS,\r\n  GetSlot,\r\n  HasSlot,\r\n  HOURS,\r\n  INST,\r\n  ISO_DATE,\r\n  ISO_DATE_TIME,\r\n  LOCALE,\r\n  MD,\r\n  MICROSECONDS,\r\n  MILLISECONDS,\r\n  MINUTES,\r\n  MONTHS,\r\n  NANOSECONDS,\r\n  OPTIONS,\r\n  ORIGINAL,\r\n  ResetSlot,\r\n  SECONDS,\r\n  SetSlot,\r\n  TIME,\r\n  TIME_FMT,\r\n  TZ_CANONICAL,\r\n  TZ_ORIGINAL,\r\n  WEEKS,\r\n  YEARS,\r\n  YM\r\n} from './slots';\r\nimport type { Temporal } from '..';\r\nimport type { DateTimeFormatParams as Params, DateTimeFormatReturn as Return } from './internaltypes';\r\n\r\n// Save the original Intl.DateTimeFormat, it will likely be overwritten\r\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\r\n\r\ntype LazySlot = typeof DATE | typeof YM | typeof MD | typeof TIME_FMT | typeof DATETIME | typeof INST;\r\n\r\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\r\n// so we'll only create those instances when we need them.\r\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\r\nfunction getSlotLazy(obj: DateTimeFormatImpl, slot: LazySlot) {\r\n  let val = GetSlot(obj, slot);\r\n  if (typeof val === 'function') {\r\n    // If we get here, `val` is an \"amender function\". It will take the user's\r\n    // options and transform them into suitable options to be passed into the\r\n    // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\r\n    // will vary depending on the Temporal type, so that's why we store separate\r\n    // formatters in separate props on the polyfill's DateTimeFormat instances.\r\n    // The efficiency happens because we don't create an (expensive) formatter\r\n    // until the user calls toLocaleString for that Temporal type.\r\n    val = new OriginalIntlDateTimeFormat(GetSlot(obj, LOCALE), val(GetSlot(obj, OPTIONS)));\r\n    ResetSlot(obj, slot, val);\r\n  }\r\n  return val;\r\n}\r\n\r\nfunction createDateTimeFormat(\r\n  dtf: DateTimeFormatImpl,\r\n  locale: Params['constructor'][0],\r\n  optionsParam: Params['constructor'][1]\r\n) {\r\n  const hasOptions = typeof optionsParam !== 'undefined';\r\n  let options: Intl.DateTimeFormatOptions;\r\n  if (hasOptions) {\r\n    // Read all the options in the expected order and copy them to a\r\n    // null-prototype object with which we can do further operations\r\n    // unobservably\r\n    const props: (keyof Intl.DateTimeFormatOptions)[] = [\r\n      'localeMatcher',\r\n      'calendar',\r\n      'numberingSystem',\r\n      'hour12',\r\n      'hourCycle',\r\n      'timeZone',\r\n      'weekday',\r\n      'era',\r\n      'year',\r\n      'month',\r\n      'day',\r\n      'dayPeriod',\r\n      'hour',\r\n      'minute',\r\n      'second',\r\n      'fractionalSecondDigits',\r\n      'timeZoneName',\r\n      'formatMatcher',\r\n      'dateStyle',\r\n      'timeStyle'\r\n    ];\r\n    options = ES.ToObject(optionsParam);\r\n    const newOptions = Object.create(null);\r\n    for (let i = 0; i < props.length; i++) {\r\n      const prop = props[i];\r\n      if (Object.prototype.hasOwnProperty.call(options, prop)) {\r\n        newOptions[prop] = options[prop];\r\n      }\r\n    }\r\n    options = newOptions;\r\n  } else {\r\n    options = Object.create(null);\r\n  }\r\n  const original = new OriginalIntlDateTimeFormat(locale, options);\r\n  const ro = original.resolvedOptions();\r\n\r\n  CreateSlots(dtf);\r\n\r\n  // DateTimeFormat instances are very expensive to create. Therefore, they will\r\n  // be lazily created only when needed, using the locale and options provided.\r\n  // But it's possible for callers to mutate those inputs before lazy creation\r\n  // happens. For this reason, we clone the inputs instead of caching the\r\n  // original objects. To avoid the complexity of deep cloning any inputs that\r\n  // are themselves objects (e.g. the locales array, or options property values\r\n  // that will be coerced to strings), we rely on `resolvedOptions()` to do the\r\n  // coercion and cloning for us. Unfortunately, we can't just use the resolved\r\n  // options as-is because our options-amending logic adds additional fields if\r\n  // the user doesn't supply any unit fields like year, month, day, hour, etc.\r\n  // Therefore, we limit the properties in the clone to properties that were\r\n  // present in the original input.\r\n  if (hasOptions) {\r\n    const clonedResolved = Object.assign(Object.create(null), ro);\r\n    for (const prop in clonedResolved) {\r\n      if (!Object.prototype.hasOwnProperty.call(options, prop)) {\r\n        delete clonedResolved[prop as keyof typeof clonedResolved];\r\n      }\r\n    }\r\n    // hour12/hourCycle don't show up in resolvedOptions() unless the chosen\r\n    // format includes an hour component, so copy them explicitly in case they\r\n    // would otherwise be lost\r\n    clonedResolved.hour12 = options.hour12;\r\n    clonedResolved.hourCycle = options.hourCycle;\r\n    SetSlot(dtf, OPTIONS, clonedResolved);\r\n  } else {\r\n    SetSlot(dtf, OPTIONS, options);\r\n  }\r\n\r\n  SetSlot(dtf, LOCALE, ro.locale);\r\n  SetSlot(dtf, ORIGINAL, original);\r\n  SetSlot(dtf, TZ_CANONICAL, ro.timeZone);\r\n  SetSlot(dtf, CAL_ID, ro.calendar);\r\n  SetSlot(dtf, DATE, dateAmend);\r\n  SetSlot(dtf, YM, yearMonthAmend);\r\n  SetSlot(dtf, MD, monthDayAmend);\r\n  SetSlot(dtf, TIME_FMT, timeAmend);\r\n  SetSlot(dtf, DATETIME, datetimeAmend);\r\n  SetSlot(dtf, INST, instantAmend);\r\n\r\n  // Save the original time zone, for a few reasons:\r\n  // - Clearer error messages\r\n  // - More clearly follows the spec for InitializeDateTimeFormat\r\n  // - Because it follows the spec more closely, will make it easier to integrate\r\n  //   support of offset strings and other potential changes like proposal-canonical-tz.\r\n  const timeZoneOption = hasOptions ? options.timeZone : undefined;\r\n  if (timeZoneOption === undefined) {\r\n    SetSlot(dtf, TZ_ORIGINAL, ro.timeZone);\r\n  } else {\r\n    const id = ES.ToString(timeZoneOption);\r\n    if (id.startsWith('−')) {\r\n      // The initial (Node 23) implementation of offset time zones allowed use\r\n      // of the Unicode minus sign, which was disallowed by a later spec change.\r\n      throw new RangeError('Unicode minus (U+2212) is not supported in time zone offsets');\r\n    }\r\n    // store a normalized identifier\r\n    SetSlot(dtf, TZ_ORIGINAL, ES.ToTemporalTimeZoneIdentifier(id));\r\n  }\r\n  return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\r\n}\r\n\r\nfunction IsPatchedDateTimeFormat(item: unknown): item is DateTimeFormatImpl {\r\n  return HasSlot(item, ORIGINAL);\r\n}\r\n\r\nclass DateTimeFormatImpl {\r\n  constructor(locales: Params['constructor'][0] = undefined, options: Params['constructor'][1] = undefined) {\r\n    createDateTimeFormat(this, locales, options);\r\n  }\r\n\r\n  get format() {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    const boundFormat = format.bind(this);\r\n    Object.defineProperties(boundFormat, {\r\n      length: { value: 1, enumerable: false, writable: false, configurable: true },\r\n      name: { value: '', enumerable: false, writable: false, configurable: true }\r\n    });\r\n    return boundFormat;\r\n  }\r\n\r\n  formatRange(a: Params['formatRange'][0], b: Params['formatRange'][1]): Return['formatRange'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return formatRange.call(this, a, b);\r\n  }\r\n\r\n  formatToParts?<P extends readonly unknown[]>(\r\n    datetime: Params['formatToParts'][0],\r\n    ...rest: P\r\n  ): Return['formatToParts'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return formatToParts.call(this, datetime, ...rest);\r\n  }\r\n\r\n  formatRangeToParts?(\r\n    a: Params['formatRangeToParts'][0],\r\n    b: Params['formatRangeToParts'][1]\r\n  ): Return['formatRangeToParts'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return formatRangeToParts.call(this, a, b);\r\n  }\r\n\r\n  resolvedOptions(): Return['resolvedOptions'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return resolvedOptions.call(this);\r\n  }\r\n}\r\n\r\nif (!('formatToParts' in OriginalIntlDateTimeFormat.prototype)) {\r\n  delete DateTimeFormatImpl.prototype.formatToParts;\r\n}\r\n\r\nif (!('formatRangeToParts' in OriginalIntlDateTimeFormat.prototype)) {\r\n  delete DateTimeFormatImpl.prototype.formatRangeToParts;\r\n}\r\nexport type { DateTimeFormatImpl };\r\n\r\ninterface DateTimeFormatInterface {\r\n  (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\r\n  new (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\r\n  supportedLocalesOf: typeof Intl.DateTimeFormat.supportedLocalesOf;\r\n}\r\n\r\n// A non-class constructor is needed because Intl.DateTimeFormat must be able to\r\n// be called without 'new'\r\nexport const DateTimeFormat = function (\r\n  locales: Params['constructor'][0] = undefined,\r\n  options: Params['constructor'][1] = undefined\r\n): DateTimeFormatImpl {\r\n  return new DateTimeFormatImpl(locales, options);\r\n} as unknown as DateTimeFormatInterface;\r\nDateTimeFormatImpl.prototype.constructor = DateTimeFormat;\r\n\r\nObject.defineProperty(DateTimeFormat, 'prototype', {\r\n  value: DateTimeFormatImpl.prototype,\r\n  writable: false,\r\n  enumerable: false,\r\n  configurable: false\r\n});\r\nDateTimeFormat.supportedLocalesOf = OriginalIntlDateTimeFormat.supportedLocalesOf;\r\nMakeIntrinsicClass(DateTimeFormat as unknown as typeof Intl.DateTimeFormat, 'Intl.DateTimeFormat');\r\n\r\nfunction resolvedOptions(this: DateTimeFormatImpl): Return['resolvedOptions'] {\r\n  const resolved = GetSlot(this, ORIGINAL).resolvedOptions();\r\n  resolved.timeZone = GetSlot(this, TZ_ORIGINAL);\r\n  return resolved;\r\n}\r\n\r\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\r\n// And if so, why doesn't formatRange also accept extra params?\r\nfunction format<P extends readonly unknown[]>(\r\n  this: DateTimeFormatImpl,\r\n  datetime: Params['format'][0],\r\n  ...rest: P\r\n): Return['format'] {\r\n  let overrides = extractOverrides(datetime, this);\r\n  let formatter, formatArgs: [Params['format'][0], ...unknown[]];\r\n  if (overrides.formatter) {\r\n    formatter = overrides.formatter;\r\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\r\n  } else {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n    formatArgs = [datetime, ...rest];\r\n  }\r\n  return formatter.format(...(formatArgs as [number | Date | undefined]));\r\n}\r\n\r\nfunction formatToParts<P extends readonly unknown[]>(\r\n  this: DateTimeFormatImpl,\r\n  datetime: Params['formatToParts'][0],\r\n  ...rest: P\r\n): Return['formatToParts'] {\r\n  let overrides = extractOverrides(datetime, this);\r\n  let formatter, formatArgs;\r\n  if (overrides.formatter) {\r\n    formatter = overrides.formatter;\r\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\r\n  } else {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n    formatArgs = [datetime, ...rest];\r\n  }\r\n  return formatter.formatToParts(...(formatArgs as [number | Date | undefined]));\r\n}\r\n\r\nfunction formatRange(this: DateTimeFormatImpl, aParam: Params['formatRange'][0], bParam: Params['formatRange'][1]) {\r\n  if (aParam === undefined || bParam === undefined) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\r\n  }\r\n  const a = toDateTimeFormattable(aParam);\r\n  const b = toDateTimeFormattable(bParam);\r\n  let formatArgs = [a, b] as const;\r\n  let formatter;\r\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\r\n  }\r\n  if (isTemporalObject(a)) {\r\n    if (!sameTemporalType(a, b)) {\r\n      throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\r\n    }\r\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\r\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\r\n    if (aformatter) {\r\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\r\n      formatter = aformatter;\r\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\r\n    }\r\n  }\r\n  if (!formatter) {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n  }\r\n  return formatter.formatRange(...(formatArgs as [number, number]));\r\n}\r\n\r\nfunction formatRangeToParts(\r\n  this: DateTimeFormatImpl,\r\n  aParam: Params['formatRangeToParts'][0],\r\n  bParam: Params['formatRangeToParts'][1]\r\n) {\r\n  if (aParam === undefined || bParam === undefined) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\r\n  }\r\n  const a = toDateTimeFormattable(aParam);\r\n  const b = toDateTimeFormattable(bParam);\r\n  let formatArgs = [a, b] as const;\r\n  let formatter;\r\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\r\n  }\r\n  if (isTemporalObject(a)) {\r\n    if (!sameTemporalType(a, b)) {\r\n      throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\r\n    }\r\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\r\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\r\n    if (aformatter) {\r\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\r\n      formatter = aformatter;\r\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\r\n    }\r\n  }\r\n  if (!formatter) {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n  }\r\n  return formatter.formatRangeToParts(...(formatArgs as [number, number]));\r\n}\r\n\r\n// \"false\" is a signal to delete this option\r\ntype MaybeFalseOptions = {\r\n  [K in keyof Intl.DateTimeFormatOptions]?: Intl.DateTimeFormatOptions[K] | false;\r\n};\r\n\r\nfunction amend(optionsParam: Intl.DateTimeFormatOptions = {}, amended: MaybeFalseOptions = {}) {\r\n  const options = Object.assign({}, optionsParam);\r\n  const props = [\r\n    'year',\r\n    'month',\r\n    'day',\r\n    'hour',\r\n    'minute',\r\n    'second',\r\n    'weekday',\r\n    'dayPeriod',\r\n    'timeZoneName',\r\n    'dateStyle',\r\n    'timeStyle'\r\n  ] as const;\r\n  for (let i = 0; i < props.length; i++) {\r\n    const opt = props[i];\r\n    // TODO: can this be typed more cleanly?\r\n    type OptionMaybeFalse = (typeof options)[typeof opt] | false;\r\n    (options[opt] as OptionMaybeFalse) = opt in amended ? amended[opt] : options[opt];\r\n    if ((options[opt] as OptionMaybeFalse) === false || options[opt] === undefined) delete options[opt];\r\n  }\r\n  return options;\r\n}\r\n\r\ntype OptionsType<T extends TypesWithToLocaleString> = NonNullable<Parameters<T['toLocaleString']>[1]>;\r\n\r\nfunction timeAmend(originalOptions: OptionsType<Temporal.PlainTime>) {\r\n  const options = amend(originalOptions, {\r\n    year: false,\r\n    month: false,\r\n    day: false,\r\n    weekday: false,\r\n    timeZoneName: false,\r\n    dateStyle: false\r\n  });\r\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\r\n    // Try to fake what timeStyle should do if not printing the time zone name\r\n    delete options.timeStyle;\r\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\r\n  }\r\n  if (!hasTimeOptions(options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format Temporal.PlainTime with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, {\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction yearMonthAmend(originalOptions: OptionsType<Temporal.PlainYearMonth>) {\r\n  // Try to fake what dateStyle should do for dates without a day. This is not\r\n  // accurate for locales that always print the era\r\n  const dateStyleHacks = {\r\n    short: { year: '2-digit', month: 'numeric' },\r\n    medium: { year: 'numeric', month: 'short' },\r\n    long: { year: 'numeric', month: 'long' },\r\n    full: { year: 'numeric', month: 'long' }\r\n  };\r\n  const options = amend(originalOptions, {\r\n    day: false,\r\n    hour: false,\r\n    minute: false,\r\n    second: false,\r\n    weekday: false,\r\n    dayPeriod: false,\r\n    timeZoneName: false,\r\n    timeStyle: false\r\n  });\r\n  if ('dateStyle' in options && options.dateStyle) {\r\n    const style = options.dateStyle;\r\n    delete options.dateStyle;\r\n    Object.assign(options, dateStyleHacks[style]);\r\n  }\r\n  if (!('year' in options || 'month' in options || 'era' in options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainYearMonth with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, { year: 'numeric', month: 'numeric' });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction monthDayAmend(originalOptions: OptionsType<Temporal.PlainMonthDay>) {\r\n  // Try to fake what dateStyle should do for dates without a day\r\n  const dateStyleHacks = {\r\n    short: { month: 'numeric', day: 'numeric' },\r\n    medium: { month: 'short', day: 'numeric' },\r\n    long: { month: 'long', day: 'numeric' },\r\n    full: { month: 'long', day: 'numeric' }\r\n  };\r\n  const options = amend(originalOptions, {\r\n    year: false,\r\n    hour: false,\r\n    minute: false,\r\n    second: false,\r\n    weekday: false,\r\n    dayPeriod: false,\r\n    timeZoneName: false,\r\n    timeStyle: false\r\n  });\r\n  if ('dateStyle' in options && options.dateStyle) {\r\n    const style = options.dateStyle;\r\n    delete options.dateStyle;\r\n    Object.assign(options, dateStyleHacks[style]);\r\n  }\r\n  if (!('month' in options || 'day' in options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainMonthDay with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, { month: 'numeric', day: 'numeric' });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction dateAmend(originalOptions: OptionsType<Temporal.PlainDate>) {\r\n  const options = amend(originalOptions, {\r\n    hour: false,\r\n    minute: false,\r\n    second: false,\r\n    dayPeriod: false,\r\n    timeZoneName: false,\r\n    timeStyle: false\r\n  });\r\n  if (!hasDateOptions(options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainDate with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, {\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction datetimeAmend(originalOptions: OptionsType<Temporal.PlainDateTime>) {\r\n  const options = amend(originalOptions, { timeZoneName: false });\r\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\r\n    // Try to fake what timeStyle should do if not printing the time zone name\r\n    delete options.timeStyle;\r\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\r\n\r\n    // If moving to a fake timeStyle while dateStyle is present, we also have to\r\n    // move to a fake dateStyle. dateStyle is mutually exclusive with hour etc.\r\n    if (options.dateStyle) {\r\n      const dateStyleHacks = {\r\n        short: { year: 'numeric', month: 'numeric', day: 'numeric' },\r\n        medium: { year: 'numeric', month: 'short', day: 'numeric' },\r\n        long: { year: 'numeric', month: 'long', day: 'numeric' },\r\n        full: { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' }\r\n      };\r\n      Object.assign(options, dateStyleHacks[options.dateStyle]);\r\n      delete options.dateStyle;\r\n    }\r\n  }\r\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainDateTime with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, {\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction instantAmend(optionsParam: OptionsType<Temporal.Instant>) {\r\n  let options = optionsParam;\r\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\r\n    options = Object.assign({}, options, {\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction hasDateOptions(options: OptionsType<TypesWithToLocaleString>) {\r\n  return (\r\n    'year' in options ||\r\n    'month' in options ||\r\n    'day' in options ||\r\n    'weekday' in options ||\r\n    'dateStyle' in options ||\r\n    'era' in options\r\n  );\r\n}\r\n\r\nfunction hasTimeOptions(options: OptionsType<TypesWithToLocaleString>) {\r\n  return (\r\n    'hour' in options ||\r\n    'minute' in options ||\r\n    'second' in options ||\r\n    'timeStyle' in options ||\r\n    'dayPeriod' in options ||\r\n    'fractionalSecondDigits' in options\r\n  );\r\n}\r\n\r\nfunction hasAnyDateTimeOptions(originalOptions: OptionsType<TypesWithToLocaleString>) {\r\n  return (\r\n    hasDateOptions(originalOptions) ||\r\n    hasTimeOptions(originalOptions) ||\r\n    'dateStyle' in originalOptions ||\r\n    'timeStyle' in originalOptions ||\r\n    'timeZoneName' in originalOptions\r\n  );\r\n}\r\n\r\nfunction isTemporalObject(\r\n  obj: unknown\r\n): obj is\r\n  | Temporal.PlainDate\r\n  | Temporal.PlainTime\r\n  | Temporal.PlainDateTime\r\n  | Temporal.ZonedDateTime\r\n  | Temporal.PlainYearMonth\r\n  | Temporal.PlainMonthDay\r\n  | Temporal.Instant {\r\n  return (\r\n    ES.IsTemporalDate(obj) ||\r\n    ES.IsTemporalTime(obj) ||\r\n    ES.IsTemporalDateTime(obj) ||\r\n    ES.IsTemporalZonedDateTime(obj) ||\r\n    ES.IsTemporalYearMonth(obj) ||\r\n    ES.IsTemporalMonthDay(obj) ||\r\n    ES.IsTemporalInstant(obj)\r\n  );\r\n}\r\n\r\nfunction toDateTimeFormattable(value: unknown) {\r\n  if (isTemporalObject(value)) return value;\r\n  return ES.ToNumber(value);\r\n}\r\n\r\nfunction sameTemporalType(x: unknown, y: unknown) {\r\n  if (!isTemporalObject(x) || !isTemporalObject(y)) return false;\r\n  if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y)) return false;\r\n  if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y)) return false;\r\n  if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y)) return false;\r\n  if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y)) return false;\r\n  if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y)) return false;\r\n  if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y)) return false;\r\n  if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y)) return false;\r\n  return true;\r\n}\r\n\r\ntype TypesWithToLocaleString =\r\n  | Temporal.PlainDateTime\r\n  | Temporal.PlainDate\r\n  | Temporal.PlainTime\r\n  | Temporal.PlainYearMonth\r\n  | Temporal.PlainMonthDay\r\n  | Temporal.ZonedDateTime\r\n  | Temporal.Instant;\r\n\r\nfunction extractOverrides(temporalObj: Params['format'][0], main: DateTimeFormatImpl) {\r\n  if (ES.IsTemporalTime(temporalObj)) {\r\n    const isoDateTime = {\r\n      isoDate: { year: 1970, month: 1, day: 1 },\r\n      time: GetSlot(temporalObj, TIME)\r\n    };\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, TIME_FMT)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalYearMonth(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== mainCalendar) {\r\n      throw new RangeError(\r\n        `cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${mainCalendar}`\r\n      );\r\n    }\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, YM)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalMonthDay(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== mainCalendar) {\r\n      throw new RangeError(\r\n        `cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${mainCalendar}`\r\n      );\r\n    }\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, MD)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalDate(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\r\n      throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${mainCalendar}`);\r\n    }\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, DATE)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalDateTime(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\r\n      throw new RangeError(\r\n        `cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${mainCalendar}`\r\n      );\r\n    }\r\n    const isoDateTime = GetSlot(temporalObj, ISO_DATE_TIME);\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, DATETIME)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalZonedDateTime(temporalObj)) {\r\n    throw new TypeError(\r\n      'Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.'\r\n    );\r\n  }\r\n\r\n  if (ES.IsTemporalInstant(temporalObj)) {\r\n    return {\r\n      epochNs: GetSlot(temporalObj, EPOCHNANOSECONDS),\r\n      formatter: getSlotLazy(main, INST)\r\n    };\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\nfunction temporalDurationToCompatibilityRecord(duration: Temporal.Duration) {\r\n  const record = Object.create(null);\r\n  record.years = GetSlot(duration, YEARS);\r\n  record.months = GetSlot(duration, MONTHS);\r\n  record.weeks = GetSlot(duration, WEEKS);\r\n  record.days = GetSlot(duration, DAYS);\r\n  record.hours = GetSlot(duration, HOURS);\r\n  record.minutes = GetSlot(duration, MINUTES);\r\n  record.seconds = GetSlot(duration, SECONDS);\r\n  record.milliseconds = GetSlot(duration, MILLISECONDS);\r\n  record.microseconds = GetSlot(duration, MICROSECONDS);\r\n  record.nanoseconds = GetSlot(duration, NANOSECONDS);\r\n  return record;\r\n}\r\n\r\nconst { format: IntlDurationFormatPrototypeFormat, formatToParts: IntlDurationFormatPrototypeFormatToParts } =\r\n  Intl.DurationFormat?.prototype ?? Object.create(null);\r\n\r\nexport function ModifiedIntlDurationFormatPrototypeFormat(\r\n  this: Intl.DurationFormat,\r\n  durationLike: Temporal.DurationLike\r\n) {\r\n  Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\r\n  const duration = ES.ToTemporalDuration(durationLike);\r\n  const record = temporalDurationToCompatibilityRecord(duration);\r\n  return IntlDurationFormatPrototypeFormat.call(this, record);\r\n}\r\n\r\nif (Intl.DurationFormat?.prototype) {\r\n  Intl.DurationFormat.prototype.format = ModifiedIntlDurationFormatPrototypeFormat;\r\n  Intl.DurationFormat.prototype.formatToParts = function formatToParts(durationLike: Temporal.DurationLike) {\r\n    Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\r\n    const duration = ES.ToTemporalDuration(durationLike);\r\n    const record = temporalDurationToCompatibilityRecord(duration);\r\n    return IntlDurationFormatPrototypeFormatToParts.call(this, record);\r\n  };\r\n}\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { EPOCHNANOSECONDS, GetSlot } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { InstantParams as Params, InstantReturn as Return } from './internaltypes';\r\n\r\nimport JSBI from 'jsbi';\r\n\r\nexport class Instant implements Temporal.Instant {\r\n  constructor(epochNanoseconds: bigint | JSBI) {\r\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\r\n    //       to improve the error message.\r\n    if (arguments.length < 1) {\r\n      throw new TypeError('missing argument: epochNanoseconds is required');\r\n    }\r\n\r\n    const ns = ES.ToBigInt(epochNanoseconds);\r\n    ES.CreateTemporalInstantSlots(this, ns);\r\n  }\r\n\r\n  get epochMilliseconds(): Return['epochMilliseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const value = GetSlot(this, EPOCHNANOSECONDS);\r\n    return ES.epochNsToMs(value, 'floor');\r\n  }\r\n  get epochNanoseconds(): Return['epochNanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\r\n  }\r\n\r\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.AddDurationToInstant('add', this, temporalDurationLike);\r\n  }\r\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.AddDurationToInstant('subtract', this, temporalDurationLike);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.DifferenceTemporalInstant('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.DifferenceTemporalInstant('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\r\n    const maximumIncrements = {\r\n      hour: 24,\r\n      minute: 1440,\r\n      second: 86400,\r\n      millisecond: 86400e3,\r\n      microsecond: 86400e6,\r\n      nanosecond: 86400e9\r\n    };\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximumIncrements[smallestUnit], true);\r\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\r\n    const roundedNs = ES.RoundTemporalInstant(ns, roundingIncrement, smallestUnit, roundingMode);\r\n    return ES.CreateTemporalInstant(roundedNs);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const other = ES.ToTemporalInstant(otherParam);\r\n    const one = GetSlot(this, EPOCHNANOSECONDS);\r\n    const two = GetSlot(other, EPOCHNANOSECONDS);\r\n    return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    let timeZone = resolvedOptions.timeZone;\r\n    if (timeZone !== undefined) timeZone = ES.ToTemporalTimeZoneIdentifier(timeZone);\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\r\n    const roundedNs = ES.RoundTemporalInstant(ns, increment, unit, roundingMode);\r\n    const roundedInstant = ES.CreateTemporalInstant(roundedNs);\r\n    return ES.TemporalInstantToString(roundedInstant, timeZone, precision);\r\n  }\r\n  toJSON(): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.TemporalInstantToString(this, undefined, 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('Instant');\r\n  }\r\n  toZonedDateTimeISO(timeZoneParam: Params['toZonedDateTimeISO'][0]): Return['toZonedDateTimeISO'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\r\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, 'iso8601');\r\n  }\r\n\r\n  static fromEpochMilliseconds(epochMilliseconds: Params['fromEpochMilliseconds'][0]): Return['fromEpochMilliseconds'] {\r\n    const epochNanoseconds = ES.epochMsToNs(ES.ToNumber(epochMilliseconds));\r\n    return ES.CreateTemporalInstant(epochNanoseconds);\r\n  }\r\n  static fromEpochNanoseconds(\r\n    epochNanosecondsParam: Params['fromEpochNanoseconds'][0]\r\n  ): Return['fromEpochNanoseconds'] {\r\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\r\n    return ES.CreateTemporalInstant(epochNanoseconds);\r\n  }\r\n  static from(item: Params['from'][0]): Return['from'] {\r\n    return ES.ToTemporalInstant(item);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalInstant(oneParam);\r\n    const two = ES.ToTemporalInstant(twoParam);\r\n    const oneNs = GetSlot(one, EPOCHNANOSECONDS);\r\n    const twoNs = GetSlot(two, EPOCHNANOSECONDS);\r\n    if (JSBI.lessThan(oneNs, twoNs)) return -1;\r\n    if (JSBI.greaterThan(oneNs, twoNs)) return 1;\r\n    return 0;\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.Instant';\r\n}\r\n\r\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, GetSlot, ISO_DATE, TIME } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { CalendarDateRecord, PlainDateParams as Params, PlainDateReturn as Return } from './internaltypes';\r\n\r\nexport class PlainDate implements Temporal.PlainDate {\r\n  constructor(\r\n    isoYear: Params['constructor'][0],\r\n    isoMonth: Params['constructor'][1],\r\n    isoDay: Params['constructor'][2],\r\n    calendarParam: Params['constructor'][3] = 'iso8601'\r\n  ) {\r\n    const year = ES.ToIntegerWithTruncation(isoYear);\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const day = ES.ToIntegerWithTruncation(isoDay);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n    ES.RejectISODate(year, month, day);\r\n\r\n    ES.CreateTemporalDateSlots(this, { year, month, day }, calendar);\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get dayOfWeek(): Return['dayOfWeek'] {\r\n    return getCalendarProperty(this, 'dayOfWeek');\r\n  }\r\n  get dayOfYear(): Return['dayOfYear'] {\r\n    return getCalendarProperty(this, 'dayOfYear');\r\n  }\r\n  get weekOfYear(): Return['weekOfYear'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.week;\r\n  }\r\n  get yearOfWeek(): Return['yearOfWeek'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.year;\r\n  }\r\n  get daysInWeek(): Return['daysInWeek'] {\r\n    return getCalendarProperty(this, 'daysInWeek');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  with(temporalDateLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    if (!ES.IsObject(temporalDateLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalDateLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\r\n    const partialDate = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalDateLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      [],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialDate);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const isoDate = ES.CalendarDateFromFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalDate(isoDate, calendar);\r\n  }\r\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\r\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE), calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.AddDurationToDate('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.AddDurationToDate('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.DifferenceTemporalPlainDate('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.DifferenceTemporalPlainDate('since', this, other, options);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const other = ES.ToTemporalDate(otherParam);\r\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    return ES.TemporalDateToString(this, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.TemporalDateToString(this);\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainDate');\r\n  }\r\n  toPlainDateTime(temporalTime: Params['toPlainDateTime'][0] = undefined): Return['toPlainDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE), time);\r\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\r\n  }\r\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n\r\n    let timeZone, temporalTime;\r\n    if (ES.IsObject(item)) {\r\n      const timeZoneLike = item.timeZone;\r\n      if (timeZoneLike === undefined) {\r\n        timeZone = ES.ToTemporalTimeZoneIdentifier(item);\r\n      } else {\r\n        timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneLike);\r\n        temporalTime = item.plainTime;\r\n      }\r\n    } else {\r\n      timeZone = ES.ToTemporalTimeZoneIdentifier(item);\r\n    }\r\n\r\n    const isoDate = GetSlot(this, ISO_DATE);\r\n    let epochNs;\r\n    if (temporalTime === undefined) {\r\n      epochNs = ES.GetStartOfDay(timeZone, isoDate);\r\n    } else {\r\n      temporalTime = ES.ToTemporalTime(temporalTime);\r\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoDate, GetSlot(temporalTime, TIME));\r\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, isoDateTime, 'compatible');\r\n    }\r\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\r\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, 'constrain');\r\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\r\n  }\r\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\r\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, 'constrain');\r\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalDate(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalDate(oneParam);\r\n    const two = ES.ToTemporalDate(twoParam);\r\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainDate';\r\n}\r\n\r\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  date: Temporal.PlainDate,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(date, ES.IsTemporalDate);\r\n  const isoDate = GetSlot(date, ISO_DATE);\r\n  return ES.calendarImplForObj(date).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\n\r\nimport { CALENDAR, GetSlot, ISO_DATE_TIME } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { CalendarDateRecord, PlainDateTimeParams as Params, PlainDateTimeReturn as Return } from './internaltypes';\r\n\r\nexport class PlainDateTime implements Temporal.PlainDateTime {\r\n  constructor(\r\n    isoYear: Params['constructor'][0],\r\n    isoMonth: Params['constructor'][1],\r\n    isoDay: Params['constructor'][2],\r\n    hourParam: Params['constructor'][3] = 0,\r\n    minuteParam: Params['constructor'][4] = 0,\r\n    secondParam: Params['constructor'][5] = 0,\r\n    millisecondParam: Params['constructor'][6] = 0,\r\n    microsecondParam: Params['constructor'][7] = 0,\r\n    nanosecondParam: Params['constructor'][8] = 0,\r\n    calendarParam: Params['constructor'][9] = 'iso8601'\r\n  ) {\r\n    const year = ES.ToIntegerWithTruncation(isoYear);\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const day = ES.ToIntegerWithTruncation(isoDay);\r\n    const hour = hourParam === undefined ? 0 : ES.ToIntegerWithTruncation(hourParam);\r\n    const minute = minuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(minuteParam);\r\n    const second = secondParam === undefined ? 0 : ES.ToIntegerWithTruncation(secondParam);\r\n    const millisecond = millisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(millisecondParam);\r\n    const microsecond = microsecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(microsecondParam);\r\n    const nanosecond = nanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(nanosecondParam);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n\r\n    ES.RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\r\n\r\n    ES.CreateTemporalDateTimeSlots(\r\n      this,\r\n      { isoDate: { year, month, day }, time: { hour, minute, second, millisecond, microsecond, nanosecond } },\r\n      calendar\r\n    );\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get hour(): Return['hour'] {\r\n    return getTimeProperty(this, 'hour');\r\n  }\r\n  get minute(): Return['minute'] {\r\n    return getTimeProperty(this, 'minute');\r\n  }\r\n  get second(): Return['second'] {\r\n    return getTimeProperty(this, 'second');\r\n  }\r\n  get millisecond(): Return['millisecond'] {\r\n    return getTimeProperty(this, 'millisecond');\r\n  }\r\n  get microsecond(): Return['microsecond'] {\r\n    return getTimeProperty(this, 'microsecond');\r\n  }\r\n  get nanosecond(): Return['nanosecond'] {\r\n    return getTimeProperty(this, 'nanosecond');\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get dayOfWeek(): Return['dayOfWeek'] {\r\n    return getCalendarProperty(this, 'dayOfWeek');\r\n  }\r\n  get dayOfYear(): Return['dayOfYear'] {\r\n    return getCalendarProperty(this, 'dayOfYear');\r\n  }\r\n  get weekOfYear(): Return['weekOfYear'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.week;\r\n  }\r\n  get yearOfWeek(): Return['yearOfWeek'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.year;\r\n  }\r\n  get daysInWeek(): Return['daysInWeek'] {\r\n    return getCalendarProperty(this, 'daysInWeek');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  with(temporalDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    if (!ES.IsObject(temporalDateTimeLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalDateTimeLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\r\n    let fields = {\r\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\r\n      ...isoDateTime.time\r\n    };\r\n    const partialDateTime = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalDateTimeLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialDateTime);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalDateTime(newDateTime, calendar);\r\n  }\r\n  withPlainTime(temporalTime: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE_TIME).isoDate, time);\r\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\r\n  }\r\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\r\n    return ES.CreateTemporalDateTime(GetSlot(this, ISO_DATE_TIME), calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.AddDurationToDateTime('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.AddDurationToDateTime('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.DifferenceTemporalPlainDateTime('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.DifferenceTemporalPlainDateTime('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\r\n    const maximumIncrements = {\r\n      day: 1,\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    };\r\n    const maximum = maximumIncrements[smallestUnit];\r\n    const inclusive = maximum === 1;\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\r\n\r\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\r\n    if (roundingIncrement === 1 && smallestUnit === 'nanosecond') {\r\n      return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\r\n    }\r\n    const result = ES.RoundISODateTime(isoDateTime, roundingIncrement, smallestUnit, roundingMode);\r\n\r\n    return ES.CreateTemporalDateTime(result, GetSlot(this, CALENDAR));\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const other = ES.ToTemporalDateTime(otherParam);\r\n    if (ES.CompareISODateTime(GetSlot(this, ISO_DATE_TIME), GetSlot(other, ISO_DATE_TIME)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    const result = ES.RoundISODateTime(GetSlot(this, ISO_DATE_TIME), increment, unit, roundingMode);\r\n    ES.RejectDateTimeRange(result);\r\n    return ES.ISODateTimeToString(result, GetSlot(this, CALENDAR), precision, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.ISODateTimeToString(GetSlot(this, ISO_DATE_TIME), GetSlot(this, CALENDAR), 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainDateTime');\r\n  }\r\n\r\n  toZonedDateTime(\r\n    temporalTimeZoneLike: Params['toZonedDateTime'][0],\r\n    options: Params['toZonedDateTime'][1] = undefined\r\n  ): Return['toZonedDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\r\n    const epochNs = ES.GetEpochNanosecondsFor(timeZone, GetSlot(this, ISO_DATE_TIME), disambiguation);\r\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainDate(): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE_TIME).isoDate, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainTime(): Return['toPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.CreateTemporalTime(GetSlot(this, ISO_DATE_TIME).time);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalDateTime(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalDateTime(oneParam);\r\n    const two = ES.ToTemporalDateTime(twoParam);\r\n    return ES.CompareISODateTime(GetSlot(one, ISO_DATE_TIME), GetSlot(two, ISO_DATE_TIME));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainDateTime';\r\n}\r\n\r\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  dt: Temporal.PlainDateTime,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\r\n  const isoDate = GetSlot(dt, ISO_DATE_TIME).isoDate;\r\n  return ES.calendarImplForObj(dt).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n\r\nfunction getTimeProperty(dt: Temporal.PlainDateTime, prop: Temporal.TimeUnit) {\r\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\r\n  return GetSlot(dt, ISO_DATE_TIME).time[prop];\r\n}\r\n","import { DEBUG } from './debug';\r\nimport { assert } from './assert';\r\nimport * as ES from './ecmascript';\r\nimport { ModifiedIntlDurationFormatPrototypeFormat } from './intl';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport {\r\n  YEARS,\r\n  MONTHS,\r\n  WEEKS,\r\n  DAYS,\r\n  HOURS,\r\n  MINUTES,\r\n  SECONDS,\r\n  MILLISECONDS,\r\n  MICROSECONDS,\r\n  NANOSECONDS,\r\n  CALENDAR,\r\n  EPOCHNANOSECONDS,\r\n  CreateSlots,\r\n  GetSlot,\r\n  ISO_DATE,\r\n  SetSlot,\r\n  TIME_ZONE\r\n} from './slots';\r\nimport { TimeDuration } from './timeduration';\r\nimport type { Temporal } from '..';\r\nimport type { DurationParams as Params, DurationReturn as Return } from './internaltypes';\r\nimport JSBI from 'jsbi';\r\n\r\nexport class Duration implements Temporal.Duration {\r\n  constructor(\r\n    yearsParam: Params['constructor'][0] = 0,\r\n    monthsParam: Params['constructor'][1] = 0,\r\n    weeksParam: Params['constructor'][2] = 0,\r\n    daysParam: Params['constructor'][3] = 0,\r\n    hoursParam: Params['constructor'][4] = 0,\r\n    minutesParam: Params['constructor'][5] = 0,\r\n    secondsParam: Params['constructor'][6] = 0,\r\n    millisecondsParam: Params['constructor'][7] = 0,\r\n    microsecondsParam: Params['constructor'][8] = 0,\r\n    nanosecondsParam: Params['constructor'][9] = 0\r\n  ) {\r\n    const years = yearsParam === undefined ? 0 : ES.ToIntegerIfIntegral(yearsParam);\r\n    const months = monthsParam === undefined ? 0 : ES.ToIntegerIfIntegral(monthsParam);\r\n    const weeks = weeksParam === undefined ? 0 : ES.ToIntegerIfIntegral(weeksParam);\r\n    const days = daysParam === undefined ? 0 : ES.ToIntegerIfIntegral(daysParam);\r\n    const hours = hoursParam === undefined ? 0 : ES.ToIntegerIfIntegral(hoursParam);\r\n    const minutes = minutesParam === undefined ? 0 : ES.ToIntegerIfIntegral(minutesParam);\r\n    const seconds = secondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(secondsParam);\r\n    const milliseconds = millisecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(millisecondsParam);\r\n    const microseconds = microsecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(microsecondsParam);\r\n    const nanoseconds = nanosecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(nanosecondsParam);\r\n\r\n    ES.RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n\r\n    CreateSlots(this);\r\n    SetSlot(this, YEARS, years);\r\n    SetSlot(this, MONTHS, months);\r\n    SetSlot(this, WEEKS, weeks);\r\n    SetSlot(this, DAYS, days);\r\n    SetSlot(this, HOURS, hours);\r\n    SetSlot(this, MINUTES, minutes);\r\n    SetSlot(this, SECONDS, seconds);\r\n    SetSlot(this, MILLISECONDS, milliseconds);\r\n    SetSlot(this, MICROSECONDS, microseconds);\r\n    SetSlot(this, NANOSECONDS, nanoseconds);\r\n\r\n    if (DEBUG) {\r\n      Object.defineProperty(this, '_repr_', {\r\n        value: `Temporal.Duration <${ES.TemporalDurationToString(this, 'auto')}>`,\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: false\r\n      });\r\n    }\r\n  }\r\n  get years(): Return['years'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, YEARS);\r\n  }\r\n  get months(): Return['months'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MONTHS);\r\n  }\r\n  get weeks(): Return['weeks'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, WEEKS);\r\n  }\r\n  get days(): Return['days'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, DAYS);\r\n  }\r\n  get hours(): Return['hours'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, HOURS);\r\n  }\r\n  get minutes(): Return['minutes'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MINUTES);\r\n  }\r\n  get seconds(): Return['seconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, SECONDS);\r\n  }\r\n  get milliseconds(): Return['milliseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MILLISECONDS);\r\n  }\r\n  get microseconds(): Return['microseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MICROSECONDS);\r\n  }\r\n  get nanoseconds(): Return['nanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, NANOSECONDS);\r\n  }\r\n  get sign(): Return['sign'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.DurationSign(this);\r\n  }\r\n  get blank(): Return['blank'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.DurationSign(this) === 0;\r\n  }\r\n  with(durationLike: Params['with'][0]): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    const partialDuration = ES.ToTemporalPartialDurationRecord(durationLike);\r\n    const {\r\n      years = GetSlot(this, YEARS),\r\n      months = GetSlot(this, MONTHS),\r\n      weeks = GetSlot(this, WEEKS),\r\n      days = GetSlot(this, DAYS),\r\n      hours = GetSlot(this, HOURS),\r\n      minutes = GetSlot(this, MINUTES),\r\n      seconds = GetSlot(this, SECONDS),\r\n      milliseconds = GetSlot(this, MILLISECONDS),\r\n      microseconds = GetSlot(this, MICROSECONDS),\r\n      nanoseconds = GetSlot(this, NANOSECONDS)\r\n    } = partialDuration;\r\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n  }\r\n  negated(): Return['negated'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.CreateNegatedTemporalDuration(this);\r\n  }\r\n  abs(): Return['abs'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return new Duration(\r\n      Math.abs(GetSlot(this, YEARS)),\r\n      Math.abs(GetSlot(this, MONTHS)),\r\n      Math.abs(GetSlot(this, WEEKS)),\r\n      Math.abs(GetSlot(this, DAYS)),\r\n      Math.abs(GetSlot(this, HOURS)),\r\n      Math.abs(GetSlot(this, MINUTES)),\r\n      Math.abs(GetSlot(this, SECONDS)),\r\n      Math.abs(GetSlot(this, MILLISECONDS)),\r\n      Math.abs(GetSlot(this, MICROSECONDS)),\r\n      Math.abs(GetSlot(this, NANOSECONDS))\r\n    );\r\n  }\r\n  add(other: Params['add'][0]): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.AddDurations('add', this, other);\r\n  }\r\n  subtract(other: Params['subtract'][0]): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.AddDurations('subtract', this, other);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n\r\n    const existingLargestUnit = ES.DefaultTemporalLargestUnit(this);\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n\r\n    let largestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'largestUnit', 'datetime', undefined, ['auto']);\r\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(roundTo);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    let smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'datetime', undefined);\r\n\r\n    let smallestUnitPresent = true;\r\n    if (!smallestUnit) {\r\n      smallestUnitPresent = false;\r\n      smallestUnit = 'nanosecond';\r\n    }\r\n    const defaultLargestUnit = ES.LargerOfTwoTemporalUnits(existingLargestUnit, smallestUnit);\r\n    let largestUnitPresent = true;\r\n    if (!largestUnit) {\r\n      largestUnitPresent = false;\r\n      largestUnit = defaultLargestUnit;\r\n    }\r\n    if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\r\n    if (!smallestUnitPresent && !largestUnitPresent) {\r\n      throw new RangeError('at least one of smallestUnit or largestUnit is required');\r\n    }\r\n    if (ES.LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\r\n      throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\r\n    }\r\n\r\n    const maximumIncrements = {\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    } as { [k in Temporal.DateTimeUnit]?: number };\r\n    const maximum = maximumIncrements[smallestUnit];\r\n    if (maximum !== undefined) ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\r\n    if (roundingIncrement > 1 && ES.TemporalUnitCategory(smallestUnit) === 'date' && largestUnit !== smallestUnit) {\r\n      throw new RangeError('For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit');\r\n    }\r\n\r\n    if (zonedRelativeTo) {\r\n      let duration = ES.ToInternalDurationRecord(this);\r\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\r\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\r\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\r\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\r\n      duration = ES.DifferenceZonedDateTimeWithRounding(\r\n        relativeEpochNs,\r\n        targetEpochNs,\r\n        timeZone,\r\n        calendar,\r\n        largestUnit,\r\n        roundingIncrement,\r\n        smallestUnit,\r\n        roundingMode\r\n      );\r\n      if (ES.TemporalUnitCategory(largestUnit) === 'date') largestUnit = 'hour';\r\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\r\n    }\r\n\r\n    if (plainRelativeTo) {\r\n      let duration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n      const targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\r\n\r\n      // Delegate the date part addition to the calendar\r\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\r\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\r\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\r\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\r\n\r\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\r\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\r\n      duration = ES.DifferencePlainDateTimeWithRounding(\r\n        isoDateTime,\r\n        targetDateTime,\r\n        calendar,\r\n        largestUnit,\r\n        roundingIncrement,\r\n        smallestUnit,\r\n        roundingMode\r\n      );\r\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\r\n    }\r\n\r\n    // No reference date to calculate difference relative to\r\n    if (ES.IsCalendarUnit(existingLargestUnit)) {\r\n      throw new RangeError(`a starting point is required for ${existingLargestUnit}s balancing`);\r\n    }\r\n    if (ES.IsCalendarUnit(largestUnit)) {\r\n      throw new RangeError(`a starting point is required for ${largestUnit}s balancing`);\r\n    }\r\n    assert(!ES.IsCalendarUnit(smallestUnit), 'smallestUnit was larger than largestUnit');\r\n    let internalDuration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n    if (smallestUnit === 'day') {\r\n      // First convert time units up to days\r\n      const { quotient, remainder } = internalDuration.time.divmod(ES.DAY_NANOS);\r\n      let days = internalDuration.date.days + quotient + ES.TotalTimeDuration(remainder, 'day');\r\n      days = ES.RoundNumberToIncrement(days, roundingIncrement, roundingMode);\r\n      const dateDuration = { years: 0, months: 0, weeks: 0, days };\r\n      internalDuration = ES.CombineDateAndTimeDuration(dateDuration, TimeDuration.ZERO);\r\n    } else {\r\n      const timeDuration = ES.RoundTimeDuration(internalDuration.time, roundingIncrement, smallestUnit, roundingMode);\r\n      internalDuration = ES.CombineDateAndTimeDuration(ES.ZeroDateDuration(), timeDuration);\r\n    }\r\n    return ES.TemporalDurationFromInternal(internalDuration, largestUnit);\r\n  }\r\n  total(optionsParam: Params['total'][0]): Return['total'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n\r\n    if (optionsParam === undefined) throw new TypeError('options argument is required');\r\n    const options =\r\n      typeof optionsParam === 'string'\r\n        ? (ES.CreateOnePropObject('unit', optionsParam) as Exclude<typeof optionsParam, string>)\r\n        : ES.GetOptionsObject(optionsParam);\r\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(options);\r\n    const unit = ES.GetTemporalUnitValuedOption(options, 'unit', 'datetime', ES.REQUIRED);\r\n\r\n    if (zonedRelativeTo) {\r\n      const duration = ES.ToInternalDurationRecord(this);\r\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\r\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\r\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\r\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\r\n      return ES.DifferenceZonedDateTimeWithTotal(relativeEpochNs, targetEpochNs, timeZone, calendar, unit);\r\n    }\r\n\r\n    if (plainRelativeTo) {\r\n      const duration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n      let targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\r\n\r\n      // Delegate the date part addition to the calendar\r\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\r\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\r\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\r\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\r\n\r\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\r\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\r\n      return ES.DifferencePlainDateTimeWithTotal(isoDateTime, targetDateTime, calendar, unit);\r\n    }\r\n\r\n    // No reference date to calculate difference relative to\r\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\r\n    if (ES.IsCalendarUnit(largestUnit)) {\r\n      throw new RangeError(`a starting point is required for ${largestUnit}s total`);\r\n    }\r\n    if (ES.IsCalendarUnit(unit)) {\r\n      throw new RangeError(`a starting point is required for ${unit}s total`);\r\n    }\r\n    const duration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n    return ES.TotalTimeDuration(duration.time, unit);\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour' || smallestUnit === 'minute') {\r\n      throw new RangeError('smallestUnit must be a time unit other than \"hours\" or \"minutes\"');\r\n    }\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    ES.uncheckedAssertNarrowedType<Exclude<typeof precision, 'minute'>>(\r\n      precision,\r\n      'Precision cannot be \"minute\" because of RangeError above'\r\n    );\r\n\r\n    if (unit === 'nanosecond' && increment === 1) return ES.TemporalDurationToString(this, precision);\r\n\r\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\r\n    let internalDuration = ES.ToInternalDurationRecord(this);\r\n    const timeDuration = ES.RoundTimeDuration(internalDuration.time, increment, unit, roundingMode);\r\n    internalDuration = ES.CombineDateAndTimeDuration(internalDuration.date, timeDuration);\r\n    const roundedDuration = ES.TemporalDurationFromInternal(\r\n      internalDuration,\r\n      ES.LargerOfTwoTemporalUnits(largestUnit, 'second')\r\n    );\r\n    return ES.TemporalDurationToString(roundedDuration, precision);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.TemporalDurationToString(this, 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    if (typeof Intl.DurationFormat === 'function') {\r\n      const formatter = new Intl.DurationFormat(locales, options as Intl.DurationFormatOptions);\r\n      return ModifiedIntlDurationFormatPrototypeFormat.call(formatter, this);\r\n    }\r\n    console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\r\n    return ES.TemporalDurationToString(this, 'auto');\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('Duration');\r\n  }\r\n  static from(item: Params['from'][0]): Return['from'] {\r\n    return ES.ToTemporalDuration(item);\r\n  }\r\n  static compare(\r\n    oneParam: Params['compare'][0],\r\n    twoParam: Params['compare'][1],\r\n    options: Params['compare'][2] = undefined\r\n  ): Return['compare'] {\r\n    const one = ES.ToTemporalDuration(oneParam);\r\n    const two = ES.ToTemporalDuration(twoParam);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(resolvedOptions);\r\n\r\n    if (\r\n      GetSlot(one, YEARS) === GetSlot(two, YEARS) &&\r\n      GetSlot(one, MONTHS) === GetSlot(two, MONTHS) &&\r\n      GetSlot(one, WEEKS) === GetSlot(two, WEEKS) &&\r\n      GetSlot(one, DAYS) === GetSlot(two, DAYS) &&\r\n      GetSlot(one, HOURS) === GetSlot(two, HOURS) &&\r\n      GetSlot(one, MINUTES) === GetSlot(two, MINUTES) &&\r\n      GetSlot(one, SECONDS) === GetSlot(two, SECONDS) &&\r\n      GetSlot(one, MILLISECONDS) === GetSlot(two, MILLISECONDS) &&\r\n      GetSlot(one, MICROSECONDS) === GetSlot(two, MICROSECONDS) &&\r\n      GetSlot(one, NANOSECONDS) === GetSlot(two, NANOSECONDS)\r\n    ) {\r\n      return 0;\r\n    }\r\n\r\n    const largestUnit1 = ES.DefaultTemporalLargestUnit(one);\r\n    const largestUnit2 = ES.DefaultTemporalLargestUnit(two);\r\n    const duration1 = ES.ToInternalDurationRecord(one);\r\n    const duration2 = ES.ToInternalDurationRecord(two);\r\n\r\n    if (\r\n      zonedRelativeTo &&\r\n      (ES.TemporalUnitCategory(largestUnit1) === 'date' || ES.TemporalUnitCategory(largestUnit2) === 'date')\r\n    ) {\r\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\r\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\r\n      const epochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\r\n\r\n      const after1 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration1);\r\n      const after2 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration2);\r\n      return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(after1, after2)));\r\n    }\r\n\r\n    let d1 = duration1.date.days;\r\n    let d2 = duration2.date.days;\r\n    if (ES.IsCalendarUnit(largestUnit1) || ES.IsCalendarUnit(largestUnit2)) {\r\n      if (!plainRelativeTo) {\r\n        throw new RangeError('A starting point is required for years, months, or weeks comparison');\r\n      }\r\n      d1 = ES.DateDurationDays(duration1.date, plainRelativeTo);\r\n      d2 = ES.DateDurationDays(duration2.date, plainRelativeTo);\r\n    }\r\n    const timeDuration1 = duration1.time.add24HourDays(d1);\r\n    const timeDuration2 = duration2.time.add24HourDays(d2);\r\n    return timeDuration1.cmp(timeDuration2);\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.Duration';\r\n}\r\n\r\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { CalendarDateRecord, PlainMonthDayParams as Params, PlainMonthDayReturn as Return } from './internaltypes';\r\n\r\nexport class PlainMonthDay implements Temporal.PlainMonthDay {\r\n  constructor(\r\n    isoMonth: Params['constructor'][0],\r\n    isoDay: Params['constructor'][0],\r\n    calendarParam = 'iso8601',\r\n    referenceISOYear = 1972\r\n  ) {\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const day = ES.ToIntegerWithTruncation(isoDay);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n    const year = ES.ToIntegerWithTruncation(referenceISOYear);\r\n\r\n    ES.RejectISODate(year, month, day);\r\n    ES.CreateTemporalMonthDaySlots(this, { year, month, day }, calendar);\r\n  }\r\n\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n\r\n  with(temporalMonthDayLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    if (!ES.IsObject(temporalMonthDayLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalMonthDayLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\r\n    const partialMonthDay = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalMonthDayLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      [],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialMonthDay);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    const other = ES.ToTemporalMonthDay(otherParam);\r\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    return ES.TemporalMonthDayToString(this, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    return ES.TemporalMonthDayToString(this);\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainMonthDay');\r\n  }\r\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\r\n    const calendar = GetSlot(this, CALENDAR);\r\n\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\r\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['year'], [], []);\r\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\r\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\r\n    return ES.CreateTemporalDate(isoDate, calendar);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalMonthDay(item, options);\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainMonthDay';\r\n}\r\n\r\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  md: Temporal.PlainMonthDay,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(md, ES.IsTemporalMonthDay);\r\n  const isoDate = GetSlot(md, ISO_DATE);\r\n  return ES.calendarImplForObj(md).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n","import * as ES from './ecmascript';\r\nimport type { Temporal } from '..';\r\n\r\nfunction SystemDateTime(timeZone: string) {\r\n  return ES.GetISODateTimeFor(timeZone, ES.SystemUTCEpochNanoSeconds());\r\n}\r\n\r\nconst instant: (typeof Temporal.Now)['instant'] = () => {\r\n  return ES.CreateTemporalInstant(ES.SystemUTCEpochNanoSeconds());\r\n};\r\nconst plainDateTimeISO: (typeof Temporal.Now)['plainDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  const isoDateTime = SystemDateTime(timeZone);\r\n  return ES.CreateTemporalDateTime(isoDateTime, 'iso8601');\r\n};\r\nconst zonedDateTimeISO: (typeof Temporal.Now)['zonedDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), timeZone, 'iso8601');\r\n};\r\nconst plainDateISO: (typeof Temporal.Now)['plainDateISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  const isoDateTime = SystemDateTime(timeZone);\r\n  return ES.CreateTemporalDate(isoDateTime.isoDate, 'iso8601');\r\n};\r\nconst plainTimeISO: (typeof Temporal.Now)['plainTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  const isoDateTime = SystemDateTime(timeZone);\r\n  return ES.CreateTemporalTime(isoDateTime.time);\r\n};\r\nconst timeZoneId: (typeof Temporal.Now)['timeZoneId'] = () => {\r\n  return ES.DefaultTimeZone();\r\n};\r\n\r\nexport const Now: typeof Temporal.Now = {\r\n  instant,\r\n  plainDateTimeISO,\r\n  plainDateISO,\r\n  plainTimeISO,\r\n  timeZoneId,\r\n  zonedDateTimeISO,\r\n  [Symbol.toStringTag]: 'Temporal.Now'\r\n};\r\nObject.defineProperty(Now, Symbol.toStringTag, {\r\n  value: 'Temporal.Now',\r\n  writable: false,\r\n  enumerable: false,\r\n  configurable: true\r\n});\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\n\r\nimport { GetSlot, TIME } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { PlainTimeParams as Params, PlainTimeReturn as Return } from './internaltypes';\r\n\r\nexport class PlainTime implements Temporal.PlainTime {\r\n  constructor(isoHour = 0, isoMinute = 0, isoSecond = 0, isoMillisecond = 0, isoMicrosecond = 0, isoNanosecond = 0) {\r\n    const hour = isoHour === undefined ? 0 : ES.ToIntegerWithTruncation(isoHour);\r\n    const minute = isoMinute === undefined ? 0 : ES.ToIntegerWithTruncation(isoMinute);\r\n    const second = isoSecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoSecond);\r\n    const millisecond = isoMillisecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMillisecond);\r\n    const microsecond = isoMicrosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMicrosecond);\r\n    const nanosecond = isoNanosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoNanosecond);\r\n\r\n    ES.RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n    const time = { hour, minute, second, millisecond, microsecond, nanosecond };\r\n\r\n    ES.CreateTemporalTimeSlots(this, time);\r\n  }\r\n\r\n  get hour(): Return['hour'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).hour;\r\n  }\r\n  get minute(): Return['minute'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).minute;\r\n  }\r\n  get second(): Return['second'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).second;\r\n  }\r\n  get millisecond(): Return['millisecond'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).millisecond;\r\n  }\r\n  get microsecond(): Return['microsecond'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).microsecond;\r\n  }\r\n  get nanosecond(): Return['nanosecond'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).nanosecond;\r\n  }\r\n\r\n  with(temporalTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    if (!ES.IsObject(temporalTimeLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalTimeLike);\r\n\r\n    const partialTime = ES.ToTemporalTimeRecord(temporalTimeLike, 'partial');\r\n\r\n    const fields = ES.ToTemporalTimeRecord(this);\r\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = Object.assign(fields, partialTime);\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(\r\n      hour,\r\n      minute,\r\n      second,\r\n      millisecond,\r\n      microsecond,\r\n      nanosecond,\r\n      overflow\r\n    ));\r\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.AddDurationToTime('add', this, temporalDurationLike);\r\n  }\r\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.AddDurationToTime('subtract', this, temporalDurationLike);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.DifferenceTemporalPlainTime('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.DifferenceTemporalPlainTime('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\r\n    const MAX_INCREMENTS = {\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    };\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, MAX_INCREMENTS[smallestUnit], false);\r\n\r\n    const time = ES.RoundTime(GetSlot(this, TIME), roundingIncrement, smallestUnit, roundingMode);\r\n    return ES.CreateTemporalTime(time);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    const other = ES.ToTemporalTime(otherParam);\r\n    return ES.CompareTimeRecord(GetSlot(this, TIME), GetSlot(other, TIME)) === 0;\r\n  }\r\n\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    const time = ES.RoundTime(GetSlot(this, TIME), increment, unit, roundingMode);\r\n    return ES.TimeRecordToString(time, precision);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.TimeRecordToString(GetSlot(this, TIME), 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainTime');\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalTime(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalTime(oneParam);\r\n    const two = ES.ToTemporalTime(twoParam);\r\n    return ES.CompareTimeRecord(GetSlot(one, TIME), GetSlot(two, TIME));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainTime';\r\n}\r\n\r\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type {\r\n  CalendarDateRecord,\r\n  PlainYearMonthParams as Params,\r\n  PlainYearMonthReturn as Return\r\n} from './internaltypes';\r\n\r\nexport class PlainYearMonth implements Temporal.PlainYearMonth {\r\n  constructor(\r\n    isoYear: Params['constructor'][0],\r\n    isoMonth: Params['constructor'][1],\r\n    calendarParam: Params['constructor'][2] = 'iso8601',\r\n    referenceISODay: Params['constructor'][3] = 1\r\n  ) {\r\n    const year = ES.ToIntegerWithTruncation(isoYear);\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n    const day = ES.ToIntegerWithTruncation(referenceISODay);\r\n\r\n    ES.RejectISODate(year, month, day);\r\n    ES.CreateTemporalYearMonthSlots(this, { year, month, day }, calendar);\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  with(temporalYearMonthLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    if (!ES.IsObject(temporalYearMonthLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalYearMonthLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\r\n    const partialYearMonth = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalYearMonthLike,\r\n      ['year', 'month', 'monthCode'],\r\n      [],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialYearMonth);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.AddDurationToYearMonth('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.AddDurationToYearMonth('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.DifferenceTemporalPlainYearMonth('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.DifferenceTemporalPlainYearMonth('since', this, other, options);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    const other = ES.ToTemporalYearMonth(otherParam);\r\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    return ES.TemporalYearMonthToString(this, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.TemporalYearMonthToString(this);\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainYearMonth');\r\n  }\r\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\r\n    const calendar = GetSlot(this, CALENDAR);\r\n\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\r\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['day'], [], []);\r\n    const mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\r\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\r\n    return ES.CreateTemporalDate(isoDate, calendar);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalYearMonth(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalYearMonth(oneParam);\r\n    const two = ES.ToTemporalYearMonth(twoParam);\r\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainYearMonth';\r\n}\r\n\r\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  ym: Temporal.PlainYearMonth,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(ym, ES.IsTemporalYearMonth);\r\n  const isoDate = GetSlot(ym, ISO_DATE);\r\n  return ES.calendarImplForObj(ym).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n","import { assert } from './assert';\r\nimport * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, EPOCHNANOSECONDS, TIME, TIME_ZONE, GetSlot } from './slots';\r\nimport { TimeDuration } from './timeduration';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type {\r\n  BuiltinCalendarId,\r\n  CalendarDateRecord,\r\n  ZonedDateTimeParams as Params,\r\n  ZonedDateTimeReturn as Return\r\n} from './internaltypes';\r\n\r\nimport JSBI from 'jsbi';\r\n\r\nconst customResolvedOptions = DateTimeFormat.prototype.resolvedOptions as Intl.DateTimeFormat['resolvedOptions'];\r\n\r\nexport class ZonedDateTime implements Temporal.ZonedDateTime {\r\n  constructor(epochNanosecondsParam: bigint | JSBI, timeZoneParam: string, calendarParam = 'iso8601') {\r\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\r\n    //       to improve the error message.\r\n    if (arguments.length < 1) {\r\n      throw new TypeError('missing argument: epochNanoseconds is required');\r\n    }\r\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\r\n    let timeZone = ES.RequireString(timeZoneParam);\r\n    const { tzName, offsetMinutes } = ES.ParseTimeZoneIdentifier(timeZone);\r\n    if (offsetMinutes === undefined) {\r\n      // if offsetMinutes is undefined, then tzName must be present\r\n      const record = ES.GetAvailableNamedTimeZoneIdentifier(tzName);\r\n      if (!record) throw new RangeError(`unknown time zone ${tzName}`);\r\n      timeZone = record.identifier;\r\n    } else {\r\n      timeZone = ES.FormatOffsetTimeZoneIdentifier(offsetMinutes);\r\n    }\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n\r\n    ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get timeZoneId(): Return['timeZoneId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return GetSlot(this, TIME_ZONE);\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get hour(): Return['hour'] {\r\n    return getTimeProperty(this, 'hour');\r\n  }\r\n  get minute(): Return['minute'] {\r\n    return getTimeProperty(this, 'minute');\r\n  }\r\n  get second(): Return['second'] {\r\n    return getTimeProperty(this, 'second');\r\n  }\r\n  get millisecond(): Return['millisecond'] {\r\n    return getTimeProperty(this, 'millisecond');\r\n  }\r\n  get microsecond(): Return['microsecond'] {\r\n    return getTimeProperty(this, 'microsecond');\r\n  }\r\n  get nanosecond(): Return['nanosecond'] {\r\n    return getTimeProperty(this, 'nanosecond');\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get epochMilliseconds(): Return['epochMilliseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const value = GetSlot(this, EPOCHNANOSECONDS);\r\n    return ES.epochNsToMs(value, 'floor');\r\n  }\r\n  get epochNanoseconds(): Return['epochNanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\r\n  }\r\n  get dayOfWeek(): Return['dayOfWeek'] {\r\n    return getCalendarProperty(this, 'dayOfWeek');\r\n  }\r\n  get dayOfYear(): Return['dayOfYear'] {\r\n    return getCalendarProperty(this, 'dayOfYear');\r\n  }\r\n  get weekOfYear(): Return['weekOfYear'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.week;\r\n  }\r\n  get yearOfWeek(): Return['yearOfWeek'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.year;\r\n  }\r\n  get hoursInDay(): Return['hoursInDay'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const today = dateTime(this).isoDate;\r\n    const tomorrow = ES.BalanceISODate(today.year, today.month, today.day + 1);\r\n    const todayNs = ES.GetStartOfDay(timeZone, today);\r\n    const tomorrowNs = ES.GetStartOfDay(timeZone, tomorrow);\r\n    const diff = TimeDuration.fromEpochNsDiff(tomorrowNs, todayNs);\r\n    return ES.TotalTimeDuration(diff, 'hour');\r\n  }\r\n  get daysInWeek(): Return['daysInWeek'] {\r\n    return getCalendarProperty(this, 'daysInWeek');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  get offset(): Return['offset'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const offsetNs = ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\r\n    return ES.FormatUTCOffsetNanoseconds(offsetNs);\r\n  }\r\n  get offsetNanoseconds(): Return['offsetNanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\r\n  }\r\n  with(temporalZonedDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    if (!ES.IsObject(temporalZonedDateTimeLike)) {\r\n      throw new TypeError('invalid zoned-date-time-like');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalZonedDateTimeLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const epochNs = GetSlot(this, EPOCHNANOSECONDS);\r\n    const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, epochNs);\r\n    const isoDateTime = dateTime(this);\r\n    let fields = {\r\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\r\n      ...isoDateTime.time,\r\n      offset: ES.FormatUTCOffsetNanoseconds(offsetNs)\r\n    };\r\n    const partialZonedDateTime = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalZonedDateTimeLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset'],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialZonedDateTime);\r\n\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\r\n    const offset = ES.GetTemporalOffsetOption(resolvedOptions, 'prefer');\r\n    const overflow = ES.GetTemporalOverflowOption(resolvedOptions);\r\n\r\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\r\n    const newOffsetNs = ES.ParseDateTimeUTCOffset(fields.offset);\r\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\r\n      newDateTime.isoDate,\r\n      newDateTime.time,\r\n      'option',\r\n      newOffsetNs,\r\n      timeZone,\r\n      disambiguation,\r\n      offset,\r\n      /* matchMinute = */ false\r\n    );\r\n\r\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\r\n  }\r\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const iso = dateTime(this).isoDate;\r\n\r\n    let epochNs;\r\n    if (temporalTimeParam === undefined) {\r\n      epochNs = ES.GetStartOfDay(timeZone, iso);\r\n    } else {\r\n      const temporalTime = ES.ToTemporalTime(temporalTimeParam);\r\n      const dt = ES.CombineISODateAndTimeRecord(iso, GetSlot(temporalTime, TIME));\r\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, dt, 'compatible');\r\n    }\r\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, calendar);\r\n  }\r\n  withTimeZone(timeZoneParam: Params['withTimeZone'][0]): Return['withTimeZone'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\r\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\r\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.AddDurationToZonedDateTime('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.AddDurationToZonedDateTime('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.DifferenceTemporalZonedDateTime('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.DifferenceTemporalZonedDateTime('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\r\n    const maximumIncrements = {\r\n      day: 1,\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    };\r\n    const maximum = maximumIncrements[smallestUnit];\r\n    const inclusive = maximum === 1;\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\r\n\r\n    if (smallestUnit === 'nanosecond' && roundingIncrement === 1) {\r\n      return ES.CreateTemporalZonedDateTime(\r\n        GetSlot(this, EPOCHNANOSECONDS),\r\n        GetSlot(this, TIME_ZONE),\r\n        GetSlot(this, CALENDAR)\r\n      );\r\n    }\r\n\r\n    // first, round the underlying DateTime fields\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const thisNs = GetSlot(this, EPOCHNANOSECONDS);\r\n    const iso = dateTime(this);\r\n    let epochNanoseconds;\r\n\r\n    if (smallestUnit === 'day') {\r\n      // Compute Instants for start-of-day and end-of-day\r\n      // Determine how far the current instant has progressed through this span.\r\n      const dateStart = iso.isoDate;\r\n      const dateEnd = ES.BalanceISODate(dateStart.year, dateStart.month, dateStart.day + 1);\r\n\r\n      const startNs = ES.GetStartOfDay(timeZone, dateStart);\r\n      assert(\r\n        JSBI.greaterThanOrEqual(thisNs, startNs),\r\n        'cannot produce an instant during a day that occurs before start-of-day instant'\r\n      );\r\n\r\n      const endNs = ES.GetStartOfDay(timeZone, dateEnd);\r\n      assert(\r\n        JSBI.lessThan(thisNs, endNs),\r\n        'cannot produce an instant during a day that occurs on or after end-of-day instant'\r\n      );\r\n\r\n      const dayLengthNs = JSBI.subtract(endNs, startNs);\r\n      const dayProgressNs = TimeDuration.fromEpochNsDiff(thisNs, startNs);\r\n      const roundedDayNs = dayProgressNs.round(dayLengthNs, roundingMode);\r\n      epochNanoseconds = roundedDayNs.addToEpochNs(startNs);\r\n    } else {\r\n      // smallestUnit < day\r\n      // Round based on ISO-calendar time units\r\n      const roundedDateTime = ES.RoundISODateTime(iso, roundingIncrement, smallestUnit, roundingMode);\r\n\r\n      // Now reset all DateTime fields but leave the TimeZone. The offset will\r\n      // also be retained if the new date/time values are still OK with the old\r\n      // offset. Otherwise the offset will be changed to be compatible with the\r\n      // new date/time values. If DST disambiguation is required, the `compatible`\r\n      // disambiguation algorithm will be used.\r\n      const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, thisNs);\r\n      epochNanoseconds = ES.InterpretISODateTimeOffset(\r\n        roundedDateTime.isoDate,\r\n        roundedDateTime.time,\r\n        'option',\r\n        offsetNs,\r\n        timeZone,\r\n        'compatible',\r\n        'prefer',\r\n        /* matchMinute = */ false\r\n      );\r\n    }\r\n\r\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const other = ES.ToTemporalZonedDateTime(otherParam);\r\n    const one = GetSlot(this, EPOCHNANOSECONDS);\r\n    const two = GetSlot(other, EPOCHNANOSECONDS);\r\n    if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two))) return false;\r\n    if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE))) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const showOffset = ES.GetTemporalShowOffsetOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    const showTimeZone = ES.GetTemporalShowTimeZoneNameOption(resolvedOptions);\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\r\n      unit,\r\n      increment,\r\n      roundingMode\r\n    });\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n\r\n    // This is not quite per specification, but this polyfill's DateTimeFormat\r\n    // already doesn't match the InitializeDateTimeFormat operation, and the\r\n    // access order might change anyway;\r\n    // see https://github.com/tc39/ecma402/issues/747\r\n    const optionsCopy = Object.create(null);\r\n    ES.CopyDataProperties(optionsCopy, resolvedOptions, ['timeZone']);\r\n\r\n    if (resolvedOptions.timeZone !== undefined) {\r\n      throw new TypeError('ZonedDateTime toLocaleString does not accept a timeZone option');\r\n    }\r\n\r\n    if (\r\n      optionsCopy.year === undefined &&\r\n      optionsCopy.month === undefined &&\r\n      optionsCopy.day === undefined &&\r\n      optionsCopy.era === undefined &&\r\n      optionsCopy.weekday === undefined &&\r\n      optionsCopy.dateStyle === undefined &&\r\n      optionsCopy.hour === undefined &&\r\n      optionsCopy.minute === undefined &&\r\n      optionsCopy.second === undefined &&\r\n      optionsCopy.fractionalSecondDigits === undefined &&\r\n      optionsCopy.timeStyle === undefined &&\r\n      optionsCopy.dayPeriod === undefined &&\r\n      optionsCopy.timeZoneName === undefined\r\n    ) {\r\n      optionsCopy.timeZoneName = 'short';\r\n      // The rest of the defaults will be filled in by formatting the Instant\r\n    }\r\n\r\n    optionsCopy.timeZone = GetSlot(this, TIME_ZONE);\r\n    if (ES.IsOffsetTimeZoneIdentifier(optionsCopy.timeZone)) {\r\n      // Note: https://github.com/tc39/ecma402/issues/683 will remove this\r\n      throw new RangeError('toLocaleString does not currently support offset time zones');\r\n    }\r\n\r\n    const formatter = new DateTimeFormat(locales, optionsCopy);\r\n\r\n    const localeCalendarIdentifier = customResolvedOptions.call(formatter).calendar as BuiltinCalendarId;\r\n    const calendarIdentifier = GetSlot(this, CALENDAR);\r\n    if (\r\n      calendarIdentifier !== 'iso8601' &&\r\n      localeCalendarIdentifier !== 'iso8601' &&\r\n      !ES.CalendarEquals(localeCalendarIdentifier, calendarIdentifier)\r\n    ) {\r\n      throw new RangeError(\r\n        `cannot format ZonedDateTime with calendar ${calendarIdentifier}` +\r\n          ` in locale with calendar ${localeCalendarIdentifier}`\r\n      );\r\n    }\r\n\r\n    return formatter.format(ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS)));\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.TemporalZonedDateTimeToString(this, 'auto');\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('ZonedDateTime');\r\n  }\r\n  startOfDay(): Return['startOfDay'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const isoDate = dateTime(this).isoDate;\r\n    const epochNanoseconds = ES.GetStartOfDay(timeZone, isoDate);\r\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  getTimeZoneTransition(directionParam: Params['getTimeZoneTransition'][0]): Return['getTimeZoneTransition'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n\r\n    if (directionParam === undefined) throw new TypeError('options parameter is required');\r\n    const direction = ES.GetDirectionOption(\r\n      typeof directionParam === 'string'\r\n        ? (ES.CreateOnePropObject('direction', directionParam) as Exclude<typeof directionParam, string>)\r\n        : ES.GetOptionsObject(directionParam)\r\n    );\r\n    if (direction === undefined) throw new TypeError('direction option is required');\r\n\r\n    // Offset time zones or UTC have no transitions\r\n    if (ES.IsOffsetTimeZoneIdentifier(timeZone) || timeZone === 'UTC') {\r\n      return null;\r\n    }\r\n\r\n    const thisEpochNanoseconds = GetSlot(this, EPOCHNANOSECONDS);\r\n    const epochNanoseconds =\r\n      direction === 'next'\r\n        ? ES.GetNamedTimeZoneNextTransition(timeZone, thisEpochNanoseconds)\r\n        : ES.GetNamedTimeZonePreviousTransition(timeZone, thisEpochNanoseconds);\r\n    return epochNanoseconds === null\r\n      ? null\r\n      : ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  toInstant(): Return['toInstant'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\r\n  }\r\n  toPlainDate(): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalDate(dateTime(this).isoDate, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainTime(): Return['toPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalTime(dateTime(this).time);\r\n  }\r\n  toPlainDateTime(): Return['toPlainDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalDateTime(dateTime(this), GetSlot(this, CALENDAR));\r\n  }\r\n\r\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalZonedDateTime(item, optionsParam);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalZonedDateTime(oneParam);\r\n    const two = ES.ToTemporalZonedDateTime(twoParam);\r\n    const ns1 = GetSlot(one, EPOCHNANOSECONDS);\r\n    const ns2 = GetSlot(two, EPOCHNANOSECONDS);\r\n    if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return -1;\r\n    if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return 1;\r\n    return 0;\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.ZonedDateTime';\r\n}\r\n\r\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\r\n\r\nfunction dateTime(zdt: Temporal.ZonedDateTime) {\r\n  return ES.GetISODateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, EPOCHNANOSECONDS));\r\n}\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  zdt: Temporal.ZonedDateTime,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\r\n  const isoDate = dateTime(zdt).isoDate;\r\n  return ES.calendarImplForObj(zdt).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n\r\nfunction getTimeProperty(zdt: Temporal.ZonedDateTime, prop: Temporal.TimeUnit) {\r\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\r\n  return dateTime(zdt).time[prop];\r\n}\r\n","import * as ES from './ecmascript';\r\n\r\n// By default, a plain function can be called as a constructor. A method such as\r\n// Date.prototype.toTemporalInstant should not be able to. We could check\r\n// new.target in the body of toTemporalInstant, but that is not sufficient for\r\n// preventing construction when passing it as the newTarget parameter of\r\n// Reflect.construct. So we create it as a method of an otherwise unused class,\r\n// and monkeypatch it onto Date.prototype.\r\n\r\nclass LegacyDateImpl {\r\n  toTemporalInstant(this: Date) {\r\n    const epochNanoseconds = ES.epochMsToNs(Date.prototype.valueOf.call(this));\r\n    return ES.CreateTemporalInstant(epochNanoseconds);\r\n  }\r\n}\r\n\r\nexport const toTemporalInstant = LegacyDateImpl.prototype.toTemporalInstant;\r\n","// This entry point treats Temporal as a library, and does not polyfill it onto\r\n// the global object.\r\n// This is in order to avoid breaking the web in the future, if the polyfill\r\n// gains wide adoption before the API is finalized. We do not want checks such\r\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\r\n// shipping the finalized API.\r\n\r\nimport * as Temporal from './temporal';\r\nimport * as Intl from './intl';\r\nimport { toTemporalInstant } from './legacydate';\r\n\r\n// Work around https://github.com/babel/babel/issues/2025.\r\nconst types = [\r\n  Temporal.Instant,\r\n  Temporal.PlainDate,\r\n  Temporal.PlainDateTime,\r\n  Temporal.Duration,\r\n  Temporal.PlainMonthDay,\r\n  // Temporal.Now, // plain object (not a constructor), so no `prototype`\r\n  Temporal.PlainTime,\r\n  Temporal.PlainYearMonth,\r\n  Temporal.ZonedDateTime\r\n];\r\nfor (const type of types) {\r\n  const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype') as PropertyDescriptor;\r\n  if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\r\n    descriptor.configurable = false;\r\n    descriptor.enumerable = false;\r\n    descriptor.writable = false;\r\n    Object.defineProperty(type, 'prototype', descriptor);\r\n  }\r\n}\r\n\r\nexport { Temporal, Intl, toTemporalInstant };\r\n"],"names":["assert","condition","message","Error","assertNotReached","reason","ZERO","ONE","TWO","TEN","TWENTY_FOUR","SIXTY","THOUSAND","MILLION","BILLION","HOUR_SECONDS","HOUR_NANOS","BigInt","MINUTE_NANOS_JSBI","DAY_NANOS_JSBI","ensureJSBI","value","toString","isEven","abs","x","compare","y","EPOCHNANOSECONDS","ISO_DATE","ISO_DATE_TIME","TIME","CALENDAR","DATE_BRAND","YEAR_MONTH_BRAND","MONTH_DAY_BRAND","TIME_ZONE","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","SECONDS","MILLISECONDS","MICROSECONDS","NANOSECONDS","DATE","YM","MD","INST","ORIGINAL","TZ_CANONICAL","TZ_ORIGINAL","CAL_ID","OPTIONS","INTRINSICS","Intl.DateTimeFormat","depth","options","inspect","GetSlot","Temporal.Duration","descr","stylize","_repr_","props","i","length","prop","TruncatingDivModByPowerOf10","xParam","p","div","mod","sign","Math","xDigits","trunc","log10","xStr","toPrecision","Number","parseInt","slice","FMAPowerOf10","zParam","z","repeat","zStr","resStr","padStart","GetUnsignedRoundingMode","isNegative","mode","TimeDuration","totalNs","MAX","sec","subsec","isSafeInteger","validateNew","operation","RangeError","fromEpochNsDiff","epochNs2","diff","epochNs1","fromComponents","h","min","s","ms","µs","ns","add","other","add24HourDays","days","isInteger","addToEpochNs","epochNs","cmp","divmod","n","q","r","remainder","offsetIdentifierNoCapture","tzComponent","timeZoneID","RegExp","source","yearpart","monthpart","daypart","datesplit","timesplit","offsetWithParts","offset","offsetpart","offsetIdentifier","annotation","zoneddatetime","join","time","DAY_MS","DAY_NANOS","MINUTE_NANOS","MS_MAX","NS_MAX","epochMsToNs","NS_MIN","DATETIME_NS_MIN","DATETIME_NS_MAX","BUILTIN_CALENDAR_IDS","ICU_LEGACY_TIME_ZONE_IDS","Set","assertExists","arg","castExists","IsObject","ToNumber","TypeError","IsIntegralNumber","argument","isNaN","Infinity","absValue","ToString","String","ToIntegerWithTruncation","number","integer","ToPositiveIntegerWithTruncation","valueParam","property","undefined","ToIntegerIfIntegral","ToZeroPaddedDecimalString","minLength","RequireString","ToSyntacticallyValidMonthCode","ToPrimitive","indexOf","ToOffsetString","ParseDateTimeUTCOffset","preferredType","result","CALENDAR_FIELD_KEYS","BUILTIN_CASTS","era","eraYear","year","month","monthCode","day","hour","minute","millisecond","microsecond","nanosecond","timeZone","ToTemporalTimeZoneIdentifier","BUILTIN_DEFAULTS","second","SINGULAR_FOR","Object","fromEntries","TEMPORAL_UNITS","map","e","PLURAL_FOR","UNITS_DESCENDING","NS_PER_TIME_UNIT","DURATION_FIELDS","OriginalIntlDateTimeFormat","Intl","DateTimeFormat","IntlDateTimeFormatEnUsCache","Map","getIntlDateTimeFormatEnUsForTimeZone","timeZoneIdentifier","lowercaseIdentifier","ASCIILowercase","instance","get","hour12","set","ToObject","CopyDataProperties","excludedKeys","excludedValues","keys","Reflect","ownKeys","index","nextKey","some","is","propertyIsEnumerable","call","propValue","target","IsTemporalInstant","item","HasSlot","IsTemporalDuration","IsTemporalDate","IsTemporalTime","IsTemporalDateTime","IsTemporalYearMonth","IsTemporalMonthDay","IsTemporalZonedDateTime","CheckReceiver","test","RejectTemporalLikeObject","calendar","FormatCalendarAnnotation","id","showCalendar","flag","processAnnotations","annotations","PARSE","lastIndex","match","exec","critical","key","calendarWasCritical","ParseISODateTime","isoString","yearString","hasTime","fraction","tzAnnotation","RejectDateTime","ParseTemporalInstantString","ParseTemporalZonedDateTimeString","ParseTemporalDateTimeString","ParseTemporalDateString","ParseTemporalTimeString","RejectTime","ParseTemporalMonthDayString","RejectISODate","ParseTemporalYearMonthString","referenceISODay","referenceISOYear","TIMEZONE_IDENTIFIER","OFFSET_IDENTIFIER","throwBadTimeZoneStringError","timeZoneString","msg","OFFSET","ParseTimeZoneIdentifier","identifier","offsetNanoseconds","offsetMinutes","tzName","ParseTemporalTimeZoneStringRaw","stringIdent","ParseTemporalDurationStringRaw","every","part","years","months","weeks","hours","fHours","minutesStr","fMinutes","secondsStr","fSeconds","excessNanoseconds","seconds","nanoseconds","milliseconds","minutes","RejectDuration","microseconds","ParseTemporalDurationString","TemporalDuration","GetIntrinsic","RegulateISODate","yearParam","monthParam","dayParam","overflow","ConstrainISODate","RegulateTime","minuteParam","secondParam","millisecondParam","microsecondParam","nanosecondParam","ConstrainToRange","ToTemporalPartialDurationRecord","temporalDurationLike","any","AdjustDateDurationRecord","newDays","newWeeks","newMonths","ZeroDateDuration","CombineISODateAndTimeRecord","isoDate","MidnightTimeRecord","deltaDays","NoonTimeRecord","GetTemporalOverflowOption","GetOption","GetTemporalDisambiguationOption","GetRoundingModeOption","fallback","NegateRoundingMode","roundingMode","GetTemporalOffsetOption","GetTemporalShowCalendarNameOption","GetTemporalShowTimeZoneNameOption","GetTemporalShowOffsetOption","GetDirectionOption","REQUIRED","GetTemporalRoundingIncrementOption","increment","roundingIncrement","integerIncrement","ValidateTemporalRoundingIncrement","dividend","inclusive","maximum","GetTemporalFractionalSecondDigitsOption","normalizedOptions","digitsValue","fractionalSecondDigits","digitCount","floor","ToSecondsStringPrecisionRecord","smallestUnit","precision","unit","Symbol","GetTemporalUnitValuedOption","unitGroup","allowedSingular","unitInfo","singular","category","defaultVal","requiredOrDefault","push","allowedValues","concat","plural","retval","GetTemporalRelativeToOption","relativeTo","offsetBehaviour","matchMinutes","zonedRelativeTo","plainRelativeTo","CreateTemporalDate","GetTemporalCalendarIdentifierWithISODefault","fields","PrepareCalendarFields","InterpretTemporalDateTimeFields","CanonicalizeCalendar","offsetNs","epochNanoseconds","InterpretISODateTimeOffset","CreateTemporalZonedDateTime","DefaultTemporalLargestUnit","duration","LargerOfTwoTemporalUnits","unit1","i1","i2","unit2","IsCalendarUnit","TemporalUnitCategory","calendarImplForID","calendarImplForObj","temporalObj","ISODateToFields","type","create","calendarImpl","calendarDate","isoToDate","bag","extraFieldNames","extraFields","calendarFieldNames","nonCalendarFieldNames","sort","requiredFields","includes","ToTemporalTimeRecord","field","ToTemporalDate","GetOptionsObject","isoDateTime","GetISODateTimeFor","CalendarDateFromFields","ToTemporalDateTime","CreateTemporalDateTime","ToTemporalDuration","partial","ToTemporalInstant","itemParam","CreateTemporalInstant","balanced","CheckISODaysRange","GetUTCEpochNanoseconds","ToTemporalMonthDay","CreateTemporalMonthDay","CalendarMonthDayFromFields","isoCalendarReferenceYear","ToTemporalTime","CreateTemporalTime","ToTimeRecordOrMidnight","ToTemporalYearMonth","CreateTemporalYearMonth","CalendarYearMonthFromFields","RejectYearMonthRange","disambiguation","offsetOpt","matchMinute","GetStartOfDay","dt","GetEpochNanosecondsFor","BalanceISODateTime","ValidateEpochNanoseconds","utcEpochNs","possibleEpochNs","candidate","candidateOffset","roundedCandidateOffset","RoundNumberToIncrement","offsetStr","FormatUTCOffsetNanoseconds","dtStr","ISODateTimeToString","DisambiguatePossibleEpochNanoseconds","ToTemporalZonedDateTime","resolvedOptions","CreateTemporalDateSlots","CreateSlots","SetSlot","repr","writable","enumerable","configurable","TemporalPlainDate","prototype","CreateTemporalDateTimeSlots","defineProperty","TemporalPlainDateTime","CreateTemporalMonthDaySlots","RejectDateRange","TemporalPlainMonthDay","CreateTemporalTimeSlots","TemporalPlainTime","CreateTemporalYearMonthSlots","TemporalYearMonthToString","TemporalPlainYearMonth","CreateTemporalInstantSlots","GetISOPartsFromEpoch","toStringTag","TemporalInstant","CreateTemporalZonedDateTimeSlots","TemporalZonedDateTimeToString","TemporalZonedDateTime","CalendarFieldKeysPresent","filter","CalendarMergeFields","additionalKeys","additionalFields","overriddenKeys","fieldKeysToIgnore","merged","fieldsKeys","ix","CalendarDateAdd","dateAdd","dateDuration","CalendarDateUntil","dateUntil","isoOtherDate","largestUnit","ToTemporalCalendarIdentifier","calendarLike","CalendarEquals","one","two","resolveFields","dateToISO","monthDayToISOReferenceDate","temporalTimeZoneLike","ParseTemporalTimeZoneString","FormatOffsetTimeZoneIdentifier","record","GetAvailableNamedTimeZoneIdentifier","TimeZoneEquals","offsetMinutes1","offsetMinutes2","idRecord2","idRecord1","primaryIdentifier","GetOffsetNanosecondsFor","GetNamedTimeZoneOffsetNanoseconds","absoluteNs","subSecondNs","timeString","FormatTimeString","GetPossibleEpochNanoseconds","numInstants","utcns","dayBefore","dayAfter","offsetAfter","offsetBefore","AddTime","timeDuration","earlierDate","BalanceISODate","earlierTime","earlier","laterTime","laterDate","later","possible","GetNamedTimeZoneEpochNanoseconds","GetNamedTimeZoneNextTransition","ISOYearString","yearNumber","ISODateTimePartString","FormatFractionalSeconds","subSecondNanoseconds","fractionFullPrecision","replace","TemporalInstantToString","outputTimeZone","instant","iso","dateTimeString","FormatDateTimeUTCOffsetRounded","TemporalDurationToString","DurationSign","datePart","timePart","secondsDuration","isZero","secondsPart","subSecondsPart","TemporalDateToString","date","monthString","dayString","TimeRecordToString","calendarString","TemporalMonthDayToString","monthDay","resultString","yearMonth","zdt","showTimeZone","showOffset","RoundTemporalInstant","tz","IsOffsetTimeZoneIdentifier","string","OFFSET_WITH_PARTS","canonicalTimeZoneIdsCache","isTZIDSep","assign","canonicalTimeZoneIds","supportedValuesOf","lower","formatter","has","chars","c","toUpperCase","standardCase","segments","split","etcName","specialCases","GetNamedTimeZoneOffsetNanosecondsImpl","epochMilliseconds","GetFormatterParts","GetUTCEpochMilliseconds","epochNsToMs","absoluteMinutes","offsetNanosecondsParam","reducedYear","yearCycles","legacyDate","Date","setUTCHours","setUTCFullYear","getTime","subMs","nanos","getUTCFullYear","getUTCDate","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","GetNamedTimeZoneDateTimeParts","searchWindowForTransitions","BEFORE_FIRST_DST","now","base","max","uppercap","leftMs","rightOffsetNs","leftOffsetNs","rightMs","searchWindow","bisect","epochMs","GetNamedTimeZonePreviousTransition","lookahead","prevBeforeLookahead","UTC","lastPrecomputed","parseFromEnUsFormat","datetime","splits","isFinite","format","nsEarlier","nsLater","earlierOffsetNs","laterOffsetNs","found","candidates","parts","CompareISODateTime","LeapYear","isDiv4","isDiv100","isDiv400","ISODaysInMonth","DoM","standard","leapyear","DateDurationSign","fieldNames","InternalDurationSign","dateSign","BalanceISOYearMonth","daysIn400YearCycle","nCycles","testYear","daysInYear","BalanceTime","hourParam","DateDurationDays","yearsMonthsWeeksDuration","epochDaysEarlier","ISODateToEpochDays","epochDaysLater","yearsMonthsWeeksInDays","CreateNegatedTemporalDuration","RejectToRange","RejectDateTimeRange","AssertISODateTimeWithinLimits","YEAR_MIN","YEAR_MAX","w","d","mon","propSign","msResult","µsResult","nsResult","remainderSec","totalSec","ToInternalDurationRecord","ToInternalDurationRecordWith24HourDays","ToDateDurationRecordWithoutTime","internalDuration","TemporalDurationFromInternal","CombineDateAndTimeDuration","timeSign","DifferenceTime","time1","time2","DifferenceInstant","ns1","ns2","DifferenceISODateTime","isoDateTime1","isoDateTime2","CompareISODate","adjustedDate","dateLargestUnit","dateDifference","DifferenceZonedDateTime","nsDiff","isoDtStart","isoDtEnd","dayCorrection","intermediateDateTime","maxDayCorrection","intermediateDate","intermediateNs","NudgeToCalendarUnit","durationParam","r2","startDuration","endDuration","r1","yearsMonths","weeksStart","weeksEnd","untilResult","start","end","startEpochNs","startDateTime","endDateTime","endEpochNs","destEpochNs","numerator","denominator","unsignedRoundingMode","subtract","even","roundedUnit","ApplyUnsignedRoundingMode","fakeNumerator","total","fdiv","didExpandCalendarUnit","nudgeResult","nudgedEpochNs","NudgeToZonedTime","endDate","daySpan","arrayFromSet","src","calendarDateWeekOfYear","impl","yow","dayOfWeek","dayOfYear","fdow","getFirstDayOfWeek","mdow","getMinimalDaysInFirstWeek","relDow","relDowJan1","prevYearCalendar","prevDoy","woy","weekNumber","lastDoy","lastRelDow","week","y1","isoDate2","m1","resolveNonLunisolarMonth","ES","intermediate","candidateYears","ISODateSurpasses","candidateMonths","constrained","requestedFields","daysInWeek","monthsInYear","buildMonthCode","shiftedMonth","shiftedYear","century","yearInCentury","monthTerm","yearTerm","centuryTerm","dow","m","startsWith","leap","leapMarker","digitPart","monthsPerYear","numberPart","nonLeapMonthCodeNumberPart","firstDayOfWeek","minimalDaysInFirstWeek","desiredDay","periodStartDayOfWeek","weekNo","OneObjectCache","cacheToClone","calls","hits","entry","entries","MAX_CACHE_ENTRIES","report","misses","objectMap","obj","getCacheForObject","cache","WeakMap","toUtcIsoDateString","isoYear","isoMonth","isoDay","simpleDateDiff","HelperBase","constructor","getFormatter","getCalendarParts","dateTimeFormat","locale","isoToCalendarDate","JSON","stringify","func","cached","matches","hasEra","normalize","replacement","eras","find","genericName","code","reviseIntlEra","checkIcuBugs","adjustCalendarDate","keyReverse","forEach","cacheReverse","validateCalendarDate","monthExtra","fromLegacyDate","largestMonth","regulateMonthDayNaive","maximumMonthLength","calendarToIsoDate","originalDate","dateParam","keyOriginal","estimateIsoDate","diffDays","testIsoEstimate","addDaysIso","isoEstimate","minimumMonthLength","testCalendarDate","roundtripEstimate","diffTotalDaysEstimate","compareCalendarDates","oldRoundtripEstimate","calculateSameMonthResult","oldSign","order","date1","date2","regulateDate","added","addDaysCalendar","addedIso","addedCalendar","addMonthsCalendar","calendarDateParam","absMonths","oldCalendarDate","daysInPreviousMonth","daysInMonth","monthsInOldYear","addCalendar","addedYears","addedMonths","addedDays","initialDays","untilCalendar","calendarTwo","calendarDaysUntil","calendarOne","totalDays","diffYears","diffInYearSign","isOneFurtherInYear","yearsAdded","current","next","remainingDays","addedIsoDate","addedCalendarDate","endOfMonthIso","endOfMonthCalendar","previousMonthYear","previousMonthDate","previousMonth","lastDayOfPreviousMonthIso","lastDayOfPreviousMonthCalendar","startOfCalendarYear","startOfCalendarMonth","oneIso","twoIso","monthDaySearchStartYear","monthDayFromFields","closestCalendar","startDateIso","calendarYear","calendarOfStartDateIso","roundTripCalendarDate","maxDayForMonthCode","closestIso","HebrewHelper","regular","Kislev","Tevet","Nisan","Iyar","Sivan","Tamuz","Elul","inLeapYear","minMaxMonthLength","minOrMax","monthInfo","maxLengthOfMonthCodeInAnyYear","getMonthCode","endsWith","calculatedMonthCode","IslamicBaseHelper","DAYS_PER_ISLAMIC_YEAR","DAYS_PER_ISO_YEAR","startOfYearCalendar","startOfNextYearCalendar","IslamicHelper","IslamicUmalquraHelper","IslamicTblaHelper","IslamicCivilHelper","IslamicRgsaHelper","IslamicCcHelper","calendarType","IndianHelper","nextYear","vulnerableToBceBug","toLocaleDateString","isGregorianLeapYear","getMonthInfo","adjustEras","erasParam","reverseOf","anchorEra","isAnchor","anchorEpoch","hasYearZero","reversedEra","isoEpoch","e1","e2","lastEraReversed","GregorianBaseHelperFixedEpoch","GregorianBaseHelper","originalEras","completeEraYear","checkField","names","currentValue","preferredName","expected","eraFromYear","adjustedCalendarDate","matchingEra","comparison","eraNames","matchData","isoYearEstimate","SameMonthDayAsGregorianBaseHelper","OrthodoxBaseHelperFixedEpoch","OrthodoxOps","CopticHelper","EthiopicHelper","OrthodoxBaseHelper","BuddhistHelper","GregoryHelper","JapaneseHelper","ChineseBaseHelper","getMonthList","monthMap","M02L","M04L","M05L","M06L","M07L","M08L","M09L","M10L","M11L","M12L","getCalendarDate","daysPastFeb1","isoStringFeb1","setUTCDate","newYearGuess","formatToParts","calendarMonthString","tv","calendarDay","calendarYearPartToVerify","calendarYearToVerify","getSlotLazy","slot","val","LOCALE","ResetSlot","createDateTimeFormat","dtf","optionsParam","hasOptions","newOptions","hasOwnProperty","original","ro","clonedResolved","hourCycle","dateAmend","yearMonthAmend","monthDayAmend","TIME_FMT","timeAmend","DATETIME","datetimeAmend","instantAmend","timeZoneOption","IsPatchedDateTimeFormat","DateTimeFormatImpl","locales","boundFormat","bind","defineProperties","name","formatRange","a","b","rest","formatRangeToParts","supportedLocalesOf","MakeIntrinsicClass","resolved","overrides","extractOverrides","formatArgs","aParam","bParam","toDateTimeFormattable","isTemporalObject","sameTemporalType","aa","aformatter","bb","bformatter","amend","amended","opt","originalOptions","weekday","timeZoneName","dateStyle","timeStyle","hasTimeOptions","hasAnyDateTimeOptions","dateStyleHacks","short","medium","long","full","dayPeriod","style","hasDateOptions","Instant","arguments","until","since","roundToParam","roundTo","maximumIncrements","roundedNs","equals","otherParam","digits","roundedInstant","toJSON","toLocaleString","valueOf","toZonedDateTimeISO","timeZoneParam","fromEpochMilliseconds","fromEpochNanoseconds","epochNanosecondsParam","from","oneParam","twoParam","PlainDate","calendarParam","calendarId","getCalendarProperty","weekOfYear","yearOfWeek","temporalDateLike","partialDate","withCalendar","toPlainDateTime","temporalTime","toZonedDateTime","timeZoneLike","plainTime","toPlainYearMonth","toPlainMonthDay","PlainDateTime","getTimeProperty","with","temporalDateTimeLike","partialDateTime","newDateTime","withPlainTime","round","Duration","yearsParam","monthsParam","weeksParam","hoursParam","minutesParam","secondsParam","millisecondsParam","microsecondsParam","nanosecondsParam","daysParam","blank","durationLike","partialDuration","smallestUnitPresent","defaultLargestUnit","largestUnitPresent","relativeEpochNs","targetEpochNs","targetTime","isoRelativeToDate","targetDateTime","targetDate","existingLargestUnit","quotient","PlainMonthDay","temporalMonthDayLike","partialMonthDay","toPlainDate","SystemDateTime","plainDateTimeISO","zonedDateTimeISO","plainDateISO","plainTimeISO","timeZoneId","Now","PlainTime","isoHour","isoMinute","isoSecond","isoMillisecond","isoNanosecond","isoMicrosecond","temporalTimeLike","partialTime","MAX_INCREMENTS","PlainYearMonth","temporalYearMonthLike","partialYearMonth","ZonedDateTime","hoursInDay","today","dateTime","tomorrow","todayNs","tomorrowNs","temporalZonedDateTimeLike","partialZonedDateTime","newOffsetNs","temporalTimeParam","withTimeZone","thisNs","dateEnd","dateStart","startNs","endNs","dayLengthNs","dayProgressNs","roundedDayNs","roundedDateTime","optionsCopy","localeCalendarIdentifier","customResolvedOptions","calendarIdentifier","startOfDay","LegacyDateImpl","toTemporalInstant","types","Temporal","descriptor","getOwnPropertyDescriptor"],"mappings":"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"}