{"version":3,"file":"index.umd.js","sources":["../lib/assert.ts","../lib/bigintmath.ts","../lib/slots.ts","../lib/intrinsicclass.ts","../lib/math.ts","../lib/timeduration.ts","../lib/regex.ts","../lib/ecmascript.ts","../lib/calendar.ts","../lib/intl.ts","../lib/instant.ts","../lib/plaindate.ts","../lib/plaindatetime.ts","../lib/duration.ts","../lib/plainmonthday.ts","../lib/now.ts","../lib/plaintime.ts","../lib/plainyearmonth.ts","../lib/zoneddatetime.ts","../lib/legacydate.ts","../lib/index.ts"],"sourcesContent":["export function assert(condition: boolean, message: string): asserts condition {\r\n  if (!condition) throw new Error(`assertion failure: ${message}`);\r\n}\r\n\r\nexport function assertNotReached(message?: string): never {\r\n  const reason = message ? ` because ${message}` : '';\r\n  throw new Error(`assertion failure: code should not be reached${reason}`);\r\n}\r\n","import JSBI from 'jsbi';\r\n\r\nexport const ZERO = JSBI.BigInt(0);\r\nexport const ONE = JSBI.BigInt(1);\r\nexport const TWO = JSBI.BigInt(2);\r\nexport const TEN = JSBI.BigInt(10);\r\nconst TWENTY_FOUR = JSBI.BigInt(24);\r\nconst SIXTY = JSBI.BigInt(60);\r\nexport const THOUSAND = JSBI.BigInt(1e3);\r\nexport const MILLION = JSBI.BigInt(1e6);\r\nexport const BILLION = JSBI.BigInt(1e9);\r\nconst HOUR_SECONDS = 3600;\r\nexport const HOUR_NANOS = JSBI.multiply(JSBI.BigInt(HOUR_SECONDS), BILLION);\r\nexport const MINUTE_NANOS_JSBI = JSBI.multiply(SIXTY, BILLION);\r\nexport const DAY_NANOS_JSBI = JSBI.multiply(HOUR_NANOS, TWENTY_FOUR);\r\n\r\n/** Handle a JSBI or native BigInt. For user input, use ES.ToBigInt instead */\r\nexport function ensureJSBI(value: JSBI | bigint) {\r\n  return typeof value === 'bigint' ? JSBI.BigInt(value.toString(10)) : value;\r\n}\r\n\r\nexport function isEven(value: JSBI): boolean {\r\n  return JSBI.equal(JSBI.remainder(value, TWO), ZERO);\r\n}\r\n\r\nexport function abs(x: JSBI): JSBI {\r\n  if (JSBI.lessThan(x, ZERO)) return JSBI.unaryMinus(x);\r\n  return x;\r\n}\r\n\r\nexport function compare(x: JSBI, y: JSBI): -1 | 0 | 1 {\r\n  return JSBI.lessThan(x, y) ? -1 : JSBI.greaterThan(x, y) ? 1 : 0;\r\n}\r\n\r\nexport function divmod(x: JSBI, y: JSBI): { quotient: JSBI; remainder: JSBI } {\r\n  const quotient = JSBI.divide(x, y);\r\n  const remainder = JSBI.remainder(x, y);\r\n  return { quotient, remainder };\r\n}\r\n","import type JSBI from 'jsbi';\r\nimport type { Temporal } from '..';\r\nimport type {\r\n  BuiltinCalendarId,\r\n  AnySlottedType,\r\n  FormatterOrAmender,\r\n  ISODate,\r\n  ISODateTime,\r\n  TimeRecord\r\n} from './internaltypes';\r\nimport type { DateTimeFormatImpl } from './intl';\r\n\r\n// Instant\r\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\r\n\r\n// DateTime, Date, Time, YearMonth, MonthDay\r\nexport const ISO_DATE = 'slot-iso-date';\r\nexport const ISO_DATE_TIME = 'slot-iso-date-time';\r\nexport const TIME = 'slot-time';\r\nexport const CALENDAR = 'slot-calendar';\r\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\r\nexport const DATE_BRAND = 'slot-date-brand';\r\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\r\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\r\n\r\n// ZonedDateTime\r\nexport const TIME_ZONE = 'slot-time-zone';\r\n\r\n// Duration\r\nexport const YEARS = 'slot-years';\r\nexport const MONTHS = 'slot-months';\r\nexport const WEEKS = 'slot-weeks';\r\nexport const DAYS = 'slot-days';\r\nexport const HOURS = 'slot-hours';\r\nexport const MINUTES = 'slot-minutes';\r\nexport const SECONDS = 'slot-seconds';\r\nexport const MILLISECONDS = 'slot-milliseconds';\r\nexport const MICROSECONDS = 'slot-microseconds';\r\nexport const NANOSECONDS = 'slot-nanoseconds';\r\n\r\n// DateTimeFormatImpl\r\nexport const DATE = 'date';\r\nexport const YM = 'ym';\r\nexport const MD = 'md';\r\nexport const TIME_FMT = 'time';\r\nexport const DATETIME = 'datetime';\r\nexport const INST = 'instant';\r\nexport const ORIGINAL = 'original';\r\nexport const TZ_CANONICAL = 'timezone-canonical';\r\nexport const TZ_ORIGINAL = 'timezone-original';\r\nexport const CAL_ID = 'calendar-id';\r\nexport const LOCALE = 'locale';\r\nexport const OPTIONS = 'options';\r\n\r\ninterface SlotInfo<ValueType, UsedByType extends AnySlottedType> {\r\n  value: ValueType;\r\n  usedBy: UsedByType;\r\n}\r\n\r\ninterface SlotInfoRecord {\r\n  [k: string]: SlotInfo<unknown, AnySlottedType>;\r\n}\r\n\r\ninterface Slots extends SlotInfoRecord {\r\n  // Instant\r\n  [EPOCHNANOSECONDS]: SlotInfo<JSBI, Temporal.Instant | Temporal.ZonedDateTime>; // number? JSBI?\r\n\r\n  // DateTime, Date, Time, YearMonth, MonthDay\r\n  [ISO_DATE]: SlotInfo<ISODate, Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth>;\r\n  [ISO_DATE_TIME]: SlotInfo<ISODateTime, Temporal.PlainDateTime>;\r\n  [TIME]: SlotInfo<TimeRecord, Temporal.PlainTime>;\r\n  [CALENDAR]: SlotInfo<BuiltinCalendarId, TypesWithCalendarUnits>;\r\n\r\n  // Date, YearMonth, MonthDay common slots\r\n  [DATE_BRAND]: SlotInfo<true, Temporal.PlainDate>;\r\n  [YEAR_MONTH_BRAND]: SlotInfo<true, Temporal.PlainYearMonth>;\r\n  [MONTH_DAY_BRAND]: SlotInfo<true, Temporal.PlainMonthDay>;\r\n\r\n  // ZonedDateTime\r\n  [TIME_ZONE]: SlotInfo<string, Temporal.ZonedDateTime>;\r\n\r\n  // Duration\r\n  [YEARS]: SlotInfo<number, Temporal.Duration>;\r\n  [MONTHS]: SlotInfo<number, Temporal.Duration>;\r\n  [WEEKS]: SlotInfo<number, Temporal.Duration>;\r\n  [DAYS]: SlotInfo<number, Temporal.Duration>;\r\n  [HOURS]: SlotInfo<number, Temporal.Duration>;\r\n  [MINUTES]: SlotInfo<number, Temporal.Duration>;\r\n  [SECONDS]: SlotInfo<number, Temporal.Duration>;\r\n  [MILLISECONDS]: SlotInfo<number, Temporal.Duration>;\r\n  [MICROSECONDS]: SlotInfo<number, Temporal.Duration>;\r\n  [NANOSECONDS]: SlotInfo<number, Temporal.Duration>;\r\n\r\n  // DateTimeFormatImpl\r\n  [DATE]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [YM]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [MD]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [TIME_FMT]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [DATETIME]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [INST]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [ORIGINAL]: SlotInfo<globalThis.Intl.DateTimeFormat, DateTimeFormatImpl>;\r\n  [TZ_CANONICAL]: SlotInfo<string, DateTimeFormatImpl>;\r\n  [TZ_ORIGINAL]: SlotInfo<string, DateTimeFormatImpl>;\r\n  [CAL_ID]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['calendar'], DateTimeFormatImpl>;\r\n  [LOCALE]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['locale'], DateTimeFormatImpl>;\r\n  [OPTIONS]: SlotInfo<Intl.DateTimeFormatOptions, DateTimeFormatImpl>;\r\n}\r\n\r\ntype TypesWithCalendarUnits =\r\n  | Temporal.PlainDateTime\r\n  | Temporal.PlainDate\r\n  | Temporal.PlainYearMonth\r\n  | Temporal.PlainMonthDay\r\n  | Temporal.ZonedDateTime;\r\n\r\ninterface SlotsToTypes {\r\n  // Instant\r\n  [EPOCHNANOSECONDS]: Temporal.Instant;\r\n\r\n  // DateTime, Date, Time, YearMonth, MonthDay\r\n  [ISO_DATE]: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay;\r\n  [ISO_DATE_TIME]: Temporal.PlainDateTime;\r\n  [TIME]: Temporal.PlainTime;\r\n  [CALENDAR]: TypesWithCalendarUnits;\r\n\r\n  // Date, YearMonth, MonthDay common slots\r\n  [DATE_BRAND]: Temporal.PlainDate;\r\n  [YEAR_MONTH_BRAND]: Temporal.PlainYearMonth;\r\n  [MONTH_DAY_BRAND]: Temporal.PlainMonthDay;\r\n\r\n  // ZonedDateTime\r\n  [TIME_ZONE]: Temporal.ZonedDateTime;\r\n\r\n  // Duration\r\n  [YEARS]: Temporal.Duration;\r\n  [MONTHS]: Temporal.Duration;\r\n  [WEEKS]: Temporal.Duration;\r\n  [DAYS]: Temporal.Duration;\r\n  [HOURS]: Temporal.Duration;\r\n  [MINUTES]: Temporal.Duration;\r\n  [SECONDS]: Temporal.Duration;\r\n  [MILLISECONDS]: Temporal.Duration;\r\n  [MICROSECONDS]: Temporal.Duration;\r\n  [NANOSECONDS]: Temporal.Duration;\r\n\r\n  // DateTimeFormatImpl\r\n  [DATE]: DateTimeFormatImpl;\r\n  [YM]: DateTimeFormatImpl;\r\n  [MD]: DateTimeFormatImpl;\r\n  [TIME_FMT]: DateTimeFormatImpl;\r\n  [DATETIME]: DateTimeFormatImpl;\r\n  [INST]: DateTimeFormatImpl;\r\n  [ORIGINAL]: DateTimeFormatImpl;\r\n  [TZ_CANONICAL]: DateTimeFormatImpl;\r\n  [TZ_ORIGINAL]: DateTimeFormatImpl;\r\n  [CAL_ID]: DateTimeFormatImpl;\r\n  [LOCALE]: DateTimeFormatImpl;\r\n  [OPTIONS]: DateTimeFormatImpl;\r\n}\r\n\r\ntype SlotKey = keyof SlotsToTypes;\r\n\r\nconst globalSlots = new WeakMap<Slots[keyof Slots]['usedBy'], Record<keyof Slots, Slots[keyof Slots]['value']>>();\r\n\r\nfunction _GetSlots(container: Slots[keyof Slots]['usedBy']) {\r\n  return globalSlots.get(container);\r\n}\r\n\r\nconst GetSlotsSymbol = Symbol.for('@@Temporal__GetSlots');\r\n\r\n// expose GetSlots to avoid dual package hazards\r\n(globalThis as any)[GetSlotsSymbol] ||= _GetSlots;\r\n\r\nconst GetSlots = (globalThis as any)[GetSlotsSymbol] as typeof _GetSlots;\r\n\r\nfunction _CreateSlots(container: Slots[keyof Slots]['usedBy']): void {\r\n  globalSlots.set(container, Object.create(null));\r\n}\r\n\r\nconst CreateSlotsSymbol = Symbol.for('@@Temporal__CreateSlots');\r\n\r\n// expose CreateSlots to avoid dual package hazards\r\n(globalThis as any)[CreateSlotsSymbol] ||= _CreateSlots;\r\n\r\nexport const CreateSlots = (globalThis as any)[CreateSlotsSymbol] as typeof _CreateSlots;\r\n\r\n// TODO: is there a better way than 9 overloads to make HasSlot into a type\r\n// guard that takes a variable number of parameters?\r\nexport function HasSlot<ID1 extends SlotKey>(container: unknown, id1: ID1): container is Slots[ID1]['usedBy'];\r\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2\r\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'];\r\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3\r\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'] | Slots[ID3]['usedBy'];\r\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey, ID4 extends SlotKey>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4\r\n): container is Slots[ID1 | ID2 | ID3 | ID4]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey,\r\n  ID7 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6,\r\n  id7: ID7\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey,\r\n  ID7 extends SlotKey,\r\n  ID8 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6,\r\n  id7: ID7,\r\n  id8: ID8\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey,\r\n  ID7 extends SlotKey,\r\n  ID8 extends SlotKey,\r\n  ID9 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6,\r\n  id7: ID7,\r\n  id8: ID8,\r\n  id9: ID9\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8 | ID9]['usedBy'];\r\nexport function HasSlot(container: unknown, ...ids: (keyof Slots)[]): boolean {\r\n  if (!container || 'object' !== typeof container) return false;\r\n  const myslots = GetSlots(container as AnySlottedType);\r\n  return !!myslots && ids.every((id) => id in myslots);\r\n}\r\nexport function GetSlot<KeyT extends keyof Slots>(\r\n  container: Slots[typeof id]['usedBy'],\r\n  id: KeyT\r\n): Slots[KeyT]['value'] {\r\n  const value = GetSlots(container)?.[id];\r\n  if (value === undefined) throw new TypeError(`Missing internal slot ${id}`);\r\n  return value;\r\n}\r\nexport function SetSlot<KeyT extends SlotKey>(\r\n  container: Slots[KeyT]['usedBy'],\r\n  id: KeyT,\r\n  value: Slots[KeyT]['value']\r\n): void {\r\n  const slots = GetSlots(container);\r\n\r\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\r\n\r\n  const existingSlot = slots[id];\r\n\r\n  if (existingSlot) throw new TypeError(`${id} already has set`);\r\n\r\n  slots[id] = value;\r\n}\r\n\r\nexport function ResetSlot<KeyT extends SlotKey>(\r\n  container: DateTimeFormatImpl,\r\n  id: KeyT,\r\n  value: Slots[KeyT]['value']\r\n): void {\r\n  const slots = GetSlots(container);\r\n\r\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\r\n\r\n  const existingSlot = slots[id];\r\n\r\n  if (existingSlot === undefined) throw new TypeError(`tried to reset ${id} which was not set`);\r\n\r\n  slots[id] = value;\r\n}\r\n","import type JSBI from 'jsbi';\r\nimport type { Temporal } from '..';\r\nimport type { CalendarImpl } from './calendar';\r\nimport type { BuiltinCalendarId } from './internaltypes';\r\nimport type { DateTimeFormatImpl } from './intl';\r\n\r\nimport { DEBUG } from './debug';\r\nimport { GetSlot, ORIGINAL } from './slots';\r\n\r\ntype OmitConstructor<T> = { [P in keyof T as T[P] extends new (...args: any[]) => any ? P : never]: T[P] };\r\n\r\ntype TemporalIntrinsics = {\r\n  ['Intl.DateTimeFormat']: typeof globalThis.Intl.DateTimeFormat;\r\n  ['Temporal.Duration']: typeof Temporal.Duration;\r\n  ['Temporal.Instant']: OmitConstructor<Temporal.Instant> &\r\n    (new (epochNanoseconds: JSBI) => Temporal.Instant) & { prototype: typeof Temporal.Instant.prototype };\r\n  ['Temporal.PlainDate']: typeof Temporal.PlainDate;\r\n  ['Temporal.PlainDateTime']: typeof Temporal.PlainDateTime;\r\n  ['Temporal.PlainMonthDay']: typeof Temporal.PlainMonthDay;\r\n  ['Temporal.PlainTime']: typeof Temporal.PlainTime;\r\n  ['Temporal.PlainYearMonth']: typeof Temporal.PlainYearMonth;\r\n  ['Temporal.ZonedDateTime']: OmitConstructor<Temporal.ZonedDateTime> &\r\n    (new (epochNanoseconds: JSBI, timeZone: string, calendar?: string) => Temporal.ZonedDateTime) & {\r\n      prototype: typeof Temporal.ZonedDateTime.prototype;\r\n      from: typeof Temporal.ZonedDateTime.from;\r\n      compare: typeof Temporal.ZonedDateTime.compare;\r\n    };\r\n};\r\ntype TemporalIntrinsicRegistrations = {\r\n  [key in keyof TemporalIntrinsics]: TemporalIntrinsics[key];\r\n};\r\ntype TemporalIntrinsicPrototypeRegistrations = {\r\n  [key in keyof TemporalIntrinsics as `${key}.prototype`]: TemporalIntrinsics[key]['prototype'];\r\n};\r\ntype TemporalIntrinsicRegisteredKeys = {\r\n  [key in keyof TemporalIntrinsicRegistrations as `%${key}%`]: TemporalIntrinsicRegistrations[key];\r\n};\r\ntype TemporalIntrinsicPrototypeRegisteredKeys = {\r\n  [key in keyof TemporalIntrinsicPrototypeRegistrations as `%${key}%`]: TemporalIntrinsicPrototypeRegistrations[key];\r\n};\r\n\r\ntype OtherIntrinsics = {\r\n  calendarImpl: (id: BuiltinCalendarId) => CalendarImpl;\r\n};\r\ntype OtherIntrinsicKeys = { [key in keyof OtherIntrinsics as `%${key}%`]: OtherIntrinsics[key] };\r\n\r\nconst INTRINSICS = {} as TemporalIntrinsicRegisteredKeys &\r\n  TemporalIntrinsicPrototypeRegisteredKeys &\r\n  OtherIntrinsicKeys;\r\n\r\ntype StylizeOption = (value: unknown, type: 'number' | 'special') => string;\r\n\r\ntype customFormatFunction<T> = (\r\n  this: T & { _repr_: string }, // _repr_ is present if DEBUG\r\n  depth: number,\r\n  options: { stylize: StylizeOption },\r\n  inspect: (object: T, options?: { depth: number; stylize: StylizeOption }) => string\r\n) => string;\r\nconst customUtilInspectFormatters: Partial<{\r\n  [key in keyof TemporalIntrinsicRegistrations]: customFormatFunction<\r\n    InstanceType<TemporalIntrinsicRegistrations[key]>\r\n  >;\r\n}> = {\r\n  ['Intl.DateTimeFormat'](depth, options, inspect) {\r\n    return inspect(GetSlot(this as DateTimeFormatImpl, ORIGINAL), { depth, ...options });\r\n  },\r\n  ['Temporal.Duration'](depth, options) {\r\n    const descr = options.stylize(this._repr_, 'special');\r\n    if (depth < 1) return descr;\r\n    const entries: string[] = [];\r\n    const props = [\r\n      'years',\r\n      'months',\r\n      'weeks',\r\n      'days',\r\n      'hours',\r\n      'minutes',\r\n      'seconds',\r\n      'milliseconds',\r\n      'microseconds',\r\n      'nanoseconds'\r\n    ] as const;\r\n    for (let i = 0; i < props.length; i++) {\r\n      const prop = props[i];\r\n      if (this[prop] !== 0) {\r\n        entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\r\n      }\r\n    }\r\n    return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\r\n  }\r\n};\r\n\r\ntype InspectFormatterOptions = { stylize: (str: string, styleType: string) => string };\r\nfunction defaultUtilInspectFormatter(this: any, depth: number, options: InspectFormatterOptions) {\r\n  return options.stylize(this._repr_, 'special');\r\n}\r\n\r\nexport function MakeIntrinsicClass(\r\n  Class: TemporalIntrinsicRegistrations[typeof name],\r\n  name: keyof TemporalIntrinsicRegistrations\r\n) {\r\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\r\n    value: name,\r\n    writable: false,\r\n    enumerable: false,\r\n    configurable: true\r\n  });\r\n  if (DEBUG) {\r\n    Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\r\n      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: true\r\n    });\r\n  }\r\n  const staticNames = Object.getOwnPropertyNames(Class);\r\n  for (let i = 0; i < staticNames.length; i++) {\r\n    const prop = staticNames[i];\r\n    // we know that `prop` is present, so the descriptor is never undefined\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    const desc = Object.getOwnPropertyDescriptor(Class, prop)!;\r\n    if (!desc.configurable || !desc.enumerable) continue;\r\n    desc.enumerable = false;\r\n    Object.defineProperty(Class, prop, desc);\r\n  }\r\n  const protoNames = Object.getOwnPropertyNames(Class.prototype);\r\n  for (let i = 0; i < protoNames.length; i++) {\r\n    const prop = protoNames[i];\r\n    // we know that `prop` is present, so the descriptor is never undefined\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop)!;\r\n    if (!desc.configurable || !desc.enumerable) continue;\r\n    desc.enumerable = false;\r\n    Object.defineProperty(Class.prototype, prop, desc);\r\n  }\r\n\r\n  DefineIntrinsic(name, Class);\r\n  DefineIntrinsic(`${name}.prototype`, Class.prototype);\r\n}\r\n\r\ntype IntrinsicDefinitionKeys =\r\n  | keyof TemporalIntrinsicRegistrations\r\n  | keyof TemporalIntrinsicPrototypeRegistrations\r\n  | keyof OtherIntrinsics;\r\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicRegistrations>(\r\n  name: KeyT,\r\n  value: TemporalIntrinsicRegistrations[KeyT]\r\n): void;\r\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicPrototypeRegistrations>(\r\n  name: KeyT,\r\n  value: TemporalIntrinsicPrototypeRegistrations[KeyT]\r\n): void;\r\nexport function DefineIntrinsic<KeyT extends keyof OtherIntrinsics>(name: KeyT, value: OtherIntrinsics[KeyT]): void;\r\nexport function DefineIntrinsic<KeyT>(name: KeyT, value: never): void;\r\nexport function DefineIntrinsic<KeyT extends IntrinsicDefinitionKeys>(name: KeyT, value: unknown): void {\r\n  const key: `%${IntrinsicDefinitionKeys}%` = `%${name}%`;\r\n  if (INTRINSICS[key] !== undefined) throw new Error(`intrinsic ${name} already exists`);\r\n  INTRINSICS[key] = value;\r\n}\r\nexport function GetIntrinsic<KeyT extends keyof typeof INTRINSICS>(intrinsic: KeyT): (typeof INTRINSICS)[KeyT] {\r\n  return INTRINSICS[intrinsic];\r\n}\r\n","import type JSBI from 'jsbi';\r\nimport type { Temporal } from '..';\r\n\r\n// Computes trunc(x / 10**p) and x % 10**p, returning { div, mod }, with\r\n// precision loss only once in the quotient, by string manipulation. If the\r\n// quotient and remainder are safe integers, then they are exact. x must be an\r\n// integer. p must be a non-negative integer. Both div and mod have the sign of\r\n// x.\r\nexport function TruncatingDivModByPowerOf10(xParam: number, p: number) {\r\n  let x = xParam;\r\n  if (x === 0) return { div: x, mod: x }; // preserves signed zero\r\n\r\n  const sign = Math.sign(x);\r\n  x = Math.abs(x);\r\n\r\n  const xDigits = Math.trunc(1 + Math.log10(x));\r\n  if (p >= xDigits) return { div: sign * 0, mod: sign * x };\r\n  if (p === 0) return { div: sign * x, mod: sign * 0 };\r\n\r\n  // would perform nearest rounding if x was not an integer:\r\n  const xStr = x.toPrecision(xDigits);\r\n  const div = sign * Number.parseInt(xStr.slice(0, xDigits - p), 10);\r\n  const mod = sign * Number.parseInt(xStr.slice(xDigits - p), 10);\r\n\r\n  return { div, mod };\r\n}\r\n\r\n// Computes x * 10**p + z with precision loss only at the end, by string\r\n// manipulation. If the result is a safe integer, then it is exact. x must be\r\n// an integer. p must be a non-negative integer. z must have the same sign as\r\n// x and be less than 10**p.\r\nexport function FMAPowerOf10(xParam: number, p: number, zParam: number) {\r\n  let x = xParam;\r\n  let z = zParam;\r\n  if (x === 0) return z;\r\n\r\n  const sign = Math.sign(x) || Math.sign(z);\r\n  x = Math.abs(x);\r\n  z = Math.abs(z);\r\n\r\n  const xStr = x.toPrecision(Math.trunc(1 + Math.log10(x)));\r\n\r\n  if (z === 0) return sign * Number.parseInt(xStr + '0'.repeat(p), 10);\r\n\r\n  const zStr = z.toPrecision(Math.trunc(1 + Math.log10(z)));\r\n\r\n  const resStr = xStr + zStr.padStart(p, '0');\r\n  return sign * Number.parseInt(resStr, 10);\r\n}\r\n\r\ntype UnsignedRoundingMode = 'half-even' | 'half-infinity' | 'half-zero' | 'infinity' | 'zero';\r\n\r\nexport function GetUnsignedRoundingMode(\r\n  mode: Temporal.RoundingMode,\r\n  sign: 'positive' | 'negative'\r\n): UnsignedRoundingMode {\r\n  const isNegative = sign === 'negative';\r\n  switch (mode) {\r\n    case 'ceil':\r\n      return isNegative ? 'zero' : 'infinity';\r\n    case 'floor':\r\n      return isNegative ? 'infinity' : 'zero';\r\n    case 'expand':\r\n      return 'infinity';\r\n    case 'trunc':\r\n      return 'zero';\r\n    case 'halfCeil':\r\n      return isNegative ? 'half-zero' : 'half-infinity';\r\n    case 'halfFloor':\r\n      return isNegative ? 'half-infinity' : 'half-zero';\r\n    case 'halfExpand':\r\n      return 'half-infinity';\r\n    case 'halfTrunc':\r\n      return 'half-zero';\r\n    case 'halfEven':\r\n      return 'half-even';\r\n  }\r\n}\r\n\r\n// Omits first step from spec algorithm so that it can be used both for\r\n// RoundNumberToIncrement and RoundTimeDurationToIncrement\r\nexport function ApplyUnsignedRoundingMode<T extends number | JSBI>(\r\n  r1: T,\r\n  r2: T,\r\n  cmp: -1 | 0 | 1,\r\n  evenCardinality: boolean,\r\n  unsignedRoundingMode: UnsignedRoundingMode\r\n) {\r\n  if (unsignedRoundingMode === 'zero') return r1;\r\n  if (unsignedRoundingMode === 'infinity') return r2;\r\n  if (cmp < 0) return r1;\r\n  if (cmp > 0) return r2;\r\n  if (unsignedRoundingMode === 'half-zero') return r1;\r\n  if (unsignedRoundingMode === 'half-infinity') return r2;\r\n  return evenCardinality ? r1 : r2;\r\n}\r\n","import JSBI from 'jsbi';\r\n\r\nimport { assert } from './assert';\r\nimport {\r\n  abs,\r\n  BILLION,\r\n  compare,\r\n  DAY_NANOS_JSBI,\r\n  divmod,\r\n  ensureJSBI,\r\n  HOUR_NANOS,\r\n  isEven,\r\n  MILLION,\r\n  MINUTE_NANOS_JSBI,\r\n  ONE,\r\n  TEN,\r\n  THOUSAND,\r\n  TWO,\r\n  ZERO\r\n} from './bigintmath';\r\nimport { ApplyUnsignedRoundingMode, GetUnsignedRoundingMode } from './math';\r\nimport type { Temporal } from '..';\r\n\r\nexport class TimeDuration {\r\n  static MAX = JSBI.BigInt('9007199254740991999999999');\r\n  static ZERO = new TimeDuration(ZERO);\r\n\r\n  totalNs: JSBI;\r\n  sec: number;\r\n  subsec: number;\r\n\r\n  constructor(totalNs: bigint | JSBI) {\r\n    assert(typeof totalNs !== 'number', 'big integer required');\r\n    this.totalNs = ensureJSBI(totalNs);\r\n    assert(JSBI.lessThanOrEqual(abs(this.totalNs), TimeDuration.MAX), 'integer too big');\r\n\r\n    this.sec = JSBI.toNumber(JSBI.divide(this.totalNs, BILLION));\r\n    this.subsec = JSBI.toNumber(JSBI.remainder(this.totalNs, BILLION));\r\n    assert(Number.isSafeInteger(this.sec), 'seconds too big');\r\n    assert(Math.abs(this.subsec) <= 999_999_999, 'subseconds too big');\r\n  }\r\n\r\n  static validateNew(totalNs: JSBI, operation: string) {\r\n    if (JSBI.greaterThan(abs(totalNs), TimeDuration.MAX)) {\r\n      throw new RangeError(`${operation} of duration time units cannot exceed ${TimeDuration.MAX} s`);\r\n    }\r\n    return new TimeDuration(totalNs);\r\n  }\r\n\r\n  static fromEpochNsDiff(epochNs1: JSBI | bigint, epochNs2: JSBI | bigint) {\r\n    const diff = JSBI.subtract(ensureJSBI(epochNs1), ensureJSBI(epochNs2));\r\n    // No extra validate step. Should instead fail assertion if too big\r\n    return new TimeDuration(diff);\r\n  }\r\n\r\n  static fromComponents(h: number, min: number, s: number, ms: number, µs: number, ns: number) {\r\n    const totalNs = JSBI.add(\r\n      JSBI.add(\r\n        JSBI.add(\r\n          JSBI.add(\r\n            JSBI.add(JSBI.BigInt(ns), JSBI.multiply(JSBI.BigInt(µs), THOUSAND)),\r\n            JSBI.multiply(JSBI.BigInt(ms), MILLION)\r\n          ),\r\n          JSBI.multiply(JSBI.BigInt(s), BILLION)\r\n        ),\r\n        JSBI.multiply(JSBI.BigInt(min), MINUTE_NANOS_JSBI)\r\n      ),\r\n      JSBI.multiply(JSBI.BigInt(h), HOUR_NANOS)\r\n    );\r\n    return TimeDuration.validateNew(totalNs, 'total');\r\n  }\r\n\r\n  abs() {\r\n    return new TimeDuration(abs(this.totalNs));\r\n  }\r\n\r\n  add(other: TimeDuration) {\r\n    return TimeDuration.validateNew(JSBI.add(this.totalNs, other.totalNs), 'sum');\r\n  }\r\n\r\n  add24HourDays(days: number) {\r\n    assert(Number.isInteger(days), 'days must be an integer');\r\n    return TimeDuration.validateNew(JSBI.add(this.totalNs, JSBI.multiply(JSBI.BigInt(days), DAY_NANOS_JSBI)), 'sum');\r\n  }\r\n\r\n  addToEpochNs(epochNs: JSBI | bigint) {\r\n    return JSBI.add(ensureJSBI(epochNs), this.totalNs);\r\n  }\r\n\r\n  cmp(other: TimeDuration) {\r\n    return compare(this.totalNs, other.totalNs);\r\n  }\r\n\r\n  divmod(n: number) {\r\n    assert(n !== 0, 'division by zero');\r\n    const { quotient, remainder } = divmod(this.totalNs, JSBI.BigInt(n));\r\n    const q = JSBI.toNumber(quotient);\r\n    const r = new TimeDuration(remainder);\r\n    return { quotient: q, remainder: r };\r\n  }\r\n\r\n  fdiv(nParam: JSBI | bigint) {\r\n    const n = ensureJSBI(nParam);\r\n    assert(!JSBI.equal(n, ZERO), 'division by zero');\r\n    const nBigInt = JSBI.BigInt(n);\r\n    let { quotient, remainder } = divmod(this.totalNs, nBigInt);\r\n\r\n    // Perform long division to calculate the fractional part of the quotient\r\n    // remainder / n with more accuracy than 64-bit floating point division\r\n    const precision = 50;\r\n    const decimalDigits: number[] = [];\r\n    let digit;\r\n    const sign = (JSBI.lessThan(this.totalNs, ZERO) ? -1 : 1) * Math.sign(JSBI.toNumber(n));\r\n    while (!JSBI.equal(remainder, ZERO) && decimalDigits.length < precision) {\r\n      remainder = JSBI.multiply(remainder, TEN);\r\n      ({ quotient: digit, remainder } = divmod(remainder, nBigInt));\r\n      decimalDigits.push(Math.abs(JSBI.toNumber(digit)));\r\n    }\r\n    return sign * Number(abs(quotient).toString() + '.' + decimalDigits.join(''));\r\n  }\r\n\r\n  isZero() {\r\n    return JSBI.equal(this.totalNs, ZERO);\r\n  }\r\n\r\n  round(incrementParam: JSBI | bigint, mode: Temporal.RoundingMode) {\r\n    const increment = ensureJSBI(incrementParam);\r\n    if (JSBI.equal(increment, ONE)) return this;\r\n    const { quotient, remainder } = divmod(this.totalNs, increment);\r\n    const sign = JSBI.lessThan(this.totalNs, ZERO) ? 'negative' : 'positive';\r\n    const r1 = JSBI.multiply(abs(quotient), increment);\r\n    const r2 = JSBI.add(r1, increment);\r\n    const cmp = compare(abs(JSBI.multiply(remainder, TWO)), increment);\r\n    const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\r\n    const rounded = JSBI.equal(remainder, ZERO)\r\n      ? r1\r\n      : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(quotient), unsignedRoundingMode);\r\n    const result = sign === 'positive' ? rounded : JSBI.unaryMinus(rounded);\r\n    return TimeDuration.validateNew(result, 'rounding');\r\n  }\r\n\r\n  sign() {\r\n    return this.cmp(new TimeDuration(ZERO));\r\n  }\r\n\r\n  subtract(other: TimeDuration) {\r\n    return TimeDuration.validateNew(JSBI.subtract(this.totalNs, other.totalNs), 'difference');\r\n  }\r\n}\r\n","const offsetIdentifierNoCapture = /(?:[+-](?:[01][0-9]|2[0-3])(?::?[0-5][0-9])?)/;\r\nconst tzComponent = /[A-Za-z._][A-Za-z._0-9+-]*/;\r\nexport const timeZoneID = new RegExp(\r\n  `(?:${offsetIdentifierNoCapture.source}|(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*)`\r\n);\r\n\r\nconst yearpart = /(?:[+-]\\d{6}|\\d{4})/;\r\nconst monthpart = /(?:0[1-9]|1[0-2])/;\r\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\r\nconst datesplit = new RegExp(\r\n  `(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`\r\n);\r\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\r\nexport const offsetWithParts = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\r\nexport const offset = /((?:[+-])(?:[01][0-9]|2[0-3])(?::?(?:[0-5][0-9])(?::?(?:[0-5][0-9])(?:[.,](?:\\d{1,9}))?)?)?)/;\r\nconst offsetpart = new RegExp(`([zZ])|${offset.source}?`);\r\nexport const offsetIdentifier = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])?)?/;\r\nexport const annotation = /\\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\\]/g;\r\n\r\nexport const zoneddatetime = new RegExp(\r\n  [\r\n    `^${datesplit.source}`,\r\n    `(?:(?:[tT]|\\\\s+)${timesplit.source}(?:${offsetpart.source})?)?`,\r\n    `(?:\\\\[!?(${timeZoneID.source})\\\\])?`,\r\n    `((?:${annotation.source})*)$`\r\n  ].join('')\r\n);\r\n\r\nexport const time = new RegExp(\r\n  [\r\n    `^[tT]?${timesplit.source}`,\r\n    `(?:${offsetpart.source})?`,\r\n    `(?:\\\\[!?${timeZoneID.source}\\\\])?`,\r\n    `((?:${annotation.source})*)$`\r\n  ].join('')\r\n);\r\n\r\n// The short forms of YearMonth and MonthDay are only for the ISO calendar, but\r\n// annotations are still allowed, and will throw if the calendar annotation is\r\n// not ISO.\r\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\r\n// with the reference fields.\r\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\r\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\r\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\r\n// UTC offsets are not allowed, because they are not allowed with any date-only\r\n// format; also, YYYY-MM-UU is ambiguous with YYYY-MM-DD\r\nexport const yearmonth = new RegExp(\r\n  `^(${yearpart.source})-?(${monthpart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\r\n);\r\nexport const monthday = new RegExp(\r\n  `^(?:--)?(${monthpart.source})-?(${daypart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\r\n);\r\n\r\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\r\n\r\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\r\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\r\nexport const duration = new RegExp(`^([+-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\r\n","import { DEBUG, ENABLE_ASSERTS } from './debug';\r\nimport JSBI from 'jsbi';\r\n\r\nimport type { Temporal } from '..';\r\nimport { assert, assertNotReached } from './assert';\r\nimport { abs, compare, DAY_NANOS_JSBI, divmod, ensureJSBI, isEven, MILLION, ONE, TWO, ZERO } from './bigintmath';\r\nimport type { CalendarImpl } from './calendar';\r\nimport type {\r\n  AnyTemporalLikeType,\r\n  UnitSmallerThanOrEqualTo,\r\n  InstantParams,\r\n  PlainMonthDayParams,\r\n  ZonedDateTimeParams,\r\n  PlainDateParams,\r\n  PlainTimeParams,\r\n  DurationParams,\r\n  PlainDateTimeParams,\r\n  PlainYearMonthParams,\r\n  BuiltinCalendarId,\r\n  Keys,\r\n  AnyTemporalKey,\r\n  FieldKey,\r\n  InternalDuration,\r\n  ISODateTime,\r\n  ISODate,\r\n  TimeRecord,\r\n  ISODateToFieldsType,\r\n  DateDuration,\r\n  CalendarFieldsRecord,\r\n  MonthDayFromFieldsObject,\r\n  Overflow,\r\n  Resolve,\r\n  AnySlottedType\r\n} from './internaltypes';\r\nimport { GetIntrinsic } from './intrinsicclass';\r\nimport { ApplyUnsignedRoundingMode, FMAPowerOf10, GetUnsignedRoundingMode, TruncatingDivModByPowerOf10 } from './math';\r\nimport { TimeDuration } from './timeduration';\r\nimport {\r\n  CreateSlots,\r\n  GetSlot,\r\n  HasSlot,\r\n  SetSlot,\r\n  EPOCHNANOSECONDS,\r\n  ISO_DATE,\r\n  ISO_DATE_TIME,\r\n  TIME,\r\n  DATE_BRAND,\r\n  YEAR_MONTH_BRAND,\r\n  MONTH_DAY_BRAND,\r\n  TIME_ZONE,\r\n  CALENDAR,\r\n  YEARS,\r\n  MONTHS,\r\n  WEEKS,\r\n  DAYS,\r\n  HOURS,\r\n  MINUTES,\r\n  SECONDS,\r\n  MILLISECONDS,\r\n  MICROSECONDS,\r\n  NANOSECONDS\r\n} from './slots';\r\n\r\nconst DAY_MS = 86400_000;\r\nexport const DAY_NANOS = DAY_MS * 1e6;\r\nconst MINUTE_NANOS = 60e9;\r\n// Instant range is 100 million days (inclusive) before or after epoch.\r\nconst MS_MAX = DAY_MS * 1e8;\r\nconst NS_MAX = epochMsToNs(MS_MAX);\r\nconst NS_MIN = JSBI.unaryMinus(NS_MAX);\r\n// PlainDateTime range is 24 hours wider (exclusive) than the Instant range on\r\n// both ends, to allow for valid Instant=>PlainDateTime conversion for all\r\n// built-in time zones (whose offsets must have a magnitude less than 24 hours).\r\nconst DATETIME_NS_MIN = JSBI.add(JSBI.subtract(NS_MIN, DAY_NANOS_JSBI), ONE);\r\nconst DATETIME_NS_MAX = JSBI.subtract(JSBI.add(NS_MAX, DAY_NANOS_JSBI), ONE);\r\n// The pattern of leap years in the ISO 8601 calendar repeats every 400 years.\r\n// The constant below is the number of nanoseconds in 400 years. It is used to\r\n// avoid overflows when dealing with values at the edge legacy Date's range.\r\nconst MS_IN_400_YEAR_CYCLE = (400 * 365 + 97) * DAY_MS;\r\nconst YEAR_MIN = -271821;\r\nconst YEAR_MAX = 275760;\r\nconst BEFORE_FIRST_DST = Date.UTC(1847, 0, 1); // 1847-01-01T00:00:00Z\r\n\r\nconst BUILTIN_CALENDAR_IDS = [\r\n  'iso8601',\r\n  'hebrew',\r\n  'islamic',\r\n  'islamic-umalqura',\r\n  'islamic-tbla',\r\n  'islamic-civil',\r\n  'islamic-rgsa',\r\n  'islamicc',\r\n  'persian',\r\n  'ethiopic',\r\n  'ethioaa',\r\n  'ethiopic-amete-alem',\r\n  'coptic',\r\n  'chinese',\r\n  'dangi',\r\n  'roc',\r\n  'indian',\r\n  'buddhist',\r\n  'japanese',\r\n  'gregory'\r\n];\r\n\r\nconst ICU_LEGACY_TIME_ZONE_IDS = new Set([\r\n  'ACT',\r\n  'AET',\r\n  'AGT',\r\n  'ART',\r\n  'AST',\r\n  'BET',\r\n  'BST',\r\n  'CAT',\r\n  'CNT',\r\n  'CST',\r\n  'CTT',\r\n  'EAT',\r\n  'ECT',\r\n  'IET',\r\n  'IST',\r\n  'JST',\r\n  'MIT',\r\n  'NET',\r\n  'NST',\r\n  'PLT',\r\n  'PNT',\r\n  'PRT',\r\n  'PST',\r\n  'SST',\r\n  'VST'\r\n]);\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */\r\n/**\r\n * uncheckedAssertNarrowedType forces TypeScript to change the type of the argument to the one given in\r\n * the type parameter. This should only be used to help TS understand when variables change types,\r\n * but TS can't or won't infer this automatically. They should be used sparingly, because\r\n * if used incorrectly can lead to difficult-to-diagnose problems.\r\n * */\r\nexport function uncheckedAssertNarrowedType<T = unknown>(\r\n  arg: unknown,\r\n  justification: string\r\n): asserts arg is T extends typeof arg ? T : never {}\r\n/* eslint-enable */\r\n\r\n/**\r\n * In debug builds, this function verifies that the given argument \"exists\" (is not\r\n * null or undefined). This function becomes a no-op in the final bundles distributed via NPM.\r\n * @param arg\r\n */\r\nexport function assertExists<A>(arg: A): asserts arg is NonNullable<A> {\r\n  if (ENABLE_ASSERTS) {\r\n    if (arg == null) {\r\n      throw new Error('Expected arg to be set.');\r\n    }\r\n  }\r\n}\r\n\r\n/** Similar to assertExists, but returns the argument. */\r\nfunction castExists<A>(arg: A): NonNullable<A> {\r\n  assertExists(arg);\r\n  return arg;\r\n}\r\n\r\n// For unknown values, this narrows the result to a Record. But for union types\r\n// like `Temporal.DurationLike | string`, it'll strip the primitive types while\r\n// leaving the object type(s) unchanged.\r\nexport function IsObject<T>(\r\n  value: T\r\n): value is Exclude<T, string | null | undefined | number | bigint | symbol | boolean>;\r\nexport function IsObject(value: unknown): value is Record<string | number | symbol, unknown> {\r\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\r\n}\r\n\r\nexport function ToNumber(value: unknown): number {\r\n  // ES 2022's es-abstract made minor changes to ToNumber, but polyfilling these\r\n  // changes adds zero benefit to Temporal and brings in a lot of extra code. So\r\n  // we'll leave ToNumber as-is.\r\n  // See https://github.com/ljharb/es-abstract/blob/main/2022/ToNumber.js\r\n  if (typeof value === 'bigint') throw new TypeError('Cannot convert BigInt to number');\r\n  return Number(value);\r\n}\r\n\r\nfunction IsIntegralNumber(argument: unknown) {\r\n  if (typeof argument !== 'number' || Number.isNaN(argument) || argument === Infinity || argument === -Infinity) {\r\n    return false;\r\n  }\r\n  const absValue = Math.abs(argument);\r\n  return Math.floor(absValue) === absValue;\r\n}\r\n\r\nexport function ToString(value: unknown): string {\r\n  if (typeof value === 'symbol') {\r\n    throw new TypeError('Cannot convert a Symbol value to a String');\r\n  }\r\n  return String(value);\r\n}\r\n\r\nexport function ToIntegerWithTruncation(value: unknown): number {\r\n  const number = ToNumber(value);\r\n  if (number === 0) return 0;\r\n  if (Number.isNaN(number) || number === Infinity || number === -Infinity) {\r\n    throw new RangeError('invalid number value');\r\n  }\r\n  const integer = Math.trunc(number);\r\n  if (integer === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\r\n  return integer;\r\n}\r\n\r\nfunction ToPositiveIntegerWithTruncation(valueParam: unknown, property?: string): number {\r\n  const integer = ToIntegerWithTruncation(valueParam);\r\n  if (integer <= 0) {\r\n    if (property !== undefined) {\r\n      throw new RangeError(`property '${property}' cannot be a a number less than one`);\r\n    }\r\n    throw new RangeError('Cannot convert a number less than one to a positive integer');\r\n  }\r\n  return integer;\r\n}\r\n\r\nexport function ToIntegerIfIntegral(valueParam: unknown): number {\r\n  const number = ToNumber(valueParam);\r\n  if (Number.isNaN(number)) throw new RangeError('not a number');\r\n  if (number === Infinity || number === -Infinity) throw new RangeError('infinity is out of range');\r\n  if (!IsIntegralNumber(number)) throw new RangeError(`unsupported fractional value ${valueParam}`);\r\n  if (number === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\r\n  return number;\r\n}\r\n\r\nfunction ToZeroPaddedDecimalString(n: number, minLength: number) {\r\n  if (DEBUG) {\r\n    if (!IsIntegralNumber(n) || n < 0) {\r\n      throw new RangeError('Assertion failed: `${n}` must be a non-negative integer');\r\n    }\r\n  }\r\n  const s = String(n);\r\n  return s.padStart(minLength, '0');\r\n}\r\n\r\n// This convenience function isn't in the spec, but is useful in the polyfill\r\n// for DRY and better error messages.\r\nexport function RequireString(value: unknown): string {\r\n  if (typeof value !== 'string') {\r\n    // Use String() to ensure that Symbols won't throw\r\n    throw new TypeError(`expected a string, not ${String(value)}`);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction ToSyntacticallyValidMonthCode(valueParam: unknown) {\r\n  const value = RequireString(ToPrimitive(valueParam, String));\r\n  if (\r\n    value.length < 3 ||\r\n    value.length > 4 ||\r\n    value[0] !== 'M' ||\r\n    '0123456789'.indexOf(value[1]) === -1 ||\r\n    '0123456789'.indexOf(value[2]) === -1 ||\r\n    (value[1] + value[2] === '00' && value[3] !== 'L') ||\r\n    (value[3] !== 'L' && value[3] !== undefined)\r\n  ) {\r\n    throw new RangeError(`bad month code ${value}; must match M01-M99 or M00L-M99L`);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction ToOffsetString(valueParam: unknown) {\r\n  const value = RequireString(ToPrimitive(valueParam, String));\r\n  ParseDateTimeUTCOffset(value);\r\n  return value;\r\n}\r\n\r\n// Limited implementation of ToPrimitive that only handles the string case,\r\n// because that's all that's used in this polyfill.\r\nfunction ToPrimitive(value: unknown, preferredType: typeof String): string | number {\r\n  assertExists(preferredType === String);\r\n  if (IsObject(value)) {\r\n    const result = value?.toString();\r\n    if (typeof result === 'string' || typeof result === 'number') return result;\r\n    throw new TypeError('Cannot convert object to primitive value');\r\n  }\r\n  return value;\r\n}\r\n\r\nconst CALENDAR_FIELD_KEYS: readonly FieldKey[] = [\r\n  'era',\r\n  'eraYear',\r\n  'year',\r\n  'month',\r\n  'monthCode',\r\n  'day',\r\n  'hour',\r\n  'minute',\r\n  'second',\r\n  'millisecond',\r\n  'microsecond',\r\n  'nanosecond',\r\n  'offset',\r\n  'timeZone'\r\n] as const;\r\n\r\ntype BuiltinCastFunction = (v: unknown) => string | number;\r\nconst BUILTIN_CASTS: Partial<Record<FieldKey, BuiltinCastFunction>> = {\r\n  era: ToString,\r\n  eraYear: ToIntegerWithTruncation,\r\n  year: ToIntegerWithTruncation,\r\n  month: ToPositiveIntegerWithTruncation,\r\n  monthCode: ToSyntacticallyValidMonthCode,\r\n  day: ToPositiveIntegerWithTruncation,\r\n  hour: ToIntegerWithTruncation,\r\n  minute: ToIntegerWithTruncation,\r\n  second: ToIntegerWithTruncation,\r\n  millisecond: ToIntegerWithTruncation,\r\n  microsecond: ToIntegerWithTruncation,\r\n  nanosecond: ToIntegerWithTruncation,\r\n  offset: ToOffsetString,\r\n  timeZone: ToTemporalTimeZoneIdentifier\r\n};\r\n\r\nconst BUILTIN_DEFAULTS: Partial<Record<FieldKey, number>> = {\r\n  hour: 0,\r\n  minute: 0,\r\n  second: 0,\r\n  millisecond: 0,\r\n  microsecond: 0,\r\n  nanosecond: 0\r\n};\r\n\r\n// each item is [plural, singular, category, (length in ns)]\r\nconst TEMPORAL_UNITS = [\r\n  ['years', 'year', 'date'],\r\n  ['months', 'month', 'date'],\r\n  ['weeks', 'week', 'date'],\r\n  ['days', 'day', 'date'],\r\n  ['hours', 'hour', 'time'],\r\n  ['minutes', 'minute', 'time'],\r\n  ['seconds', 'second', 'time'],\r\n  ['milliseconds', 'millisecond', 'time'],\r\n  ['microseconds', 'microsecond', 'time'],\r\n  ['nanoseconds', 'nanosecond', 'time']\r\n] as const;\r\nconst SINGULAR_FOR = Object.fromEntries(TEMPORAL_UNITS.map((e) => [e[0], e[1]] as const));\r\nconst PLURAL_FOR = Object.fromEntries(TEMPORAL_UNITS.map(([p, s]) => [s, p] as const));\r\nconst UNITS_DESCENDING = TEMPORAL_UNITS.map(([, s]) => s);\r\ntype TimeUnitOrDay = Temporal.TimeUnit | 'day';\r\nconst NS_PER_TIME_UNIT = {\r\n  day: DAY_NANOS,\r\n  hour: 3600e9,\r\n  minute: 60e9,\r\n  second: 1e9,\r\n  millisecond: 1e6,\r\n  microsecond: 1e3,\r\n  nanosecond: 1\r\n};\r\n\r\nconst DURATION_FIELDS = [\r\n  'days',\r\n  'hours',\r\n  'microseconds',\r\n  'milliseconds',\r\n  'minutes',\r\n  'months',\r\n  'nanoseconds',\r\n  'seconds',\r\n  'weeks',\r\n  'years'\r\n] as const;\r\n\r\nimport * as PARSE from './regex';\r\n\r\n// Save the original Intl.DateTimeFormat, it will likely be overwritten with the\r\n// one from this polyfill. Caching the formatter below may be reentrant, so we\r\n// need to use the original one\r\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\r\nconst IntlDateTimeFormatEnUsCache = new Map<string, Intl.DateTimeFormat>();\r\n\r\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier: string) {\r\n  const lowercaseIdentifier = ASCIILowercase(timeZoneIdentifier);\r\n  let instance = IntlDateTimeFormatEnUsCache.get(lowercaseIdentifier);\r\n  if (instance === undefined) {\r\n    instance = new OriginalIntlDateTimeFormat('en-us', {\r\n      timeZone: lowercaseIdentifier,\r\n      hour12: false,\r\n      era: 'short',\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n    IntlDateTimeFormatEnUsCache.set(lowercaseIdentifier, instance);\r\n  }\r\n  return instance;\r\n}\r\n\r\nexport function ToObject<T>(value: T): T extends Record<string, unknown> ? T : Record<PropertyKey, unknown> {\r\n  if (typeof value === 'undefined' || value === null) {\r\n    throw new TypeError(`Expected object not ${value}`);\r\n  }\r\n  return Object(value);\r\n}\r\n\r\n// Adapted from https://github.com/ljharb/es-abstract/blob/main/2022/CopyDataProperties.js\r\n// but simplified (e.g. removed assertions) for this polyfill to reduce bundle size.\r\nexport function CopyDataProperties<K extends PropertyKey, T extends Record<K, unknown>>(\r\n  target: T,\r\n  source: T | undefined,\r\n  excludedKeys: K[],\r\n  excludedValues?: unknown[]\r\n) {\r\n  if (typeof source === 'undefined' || source === null) return;\r\n\r\n  const keys = Reflect.ownKeys(source) as (keyof T)[];\r\n  for (let index = 0; index < keys.length; index++) {\r\n    const nextKey = keys[index];\r\n    if (excludedKeys.some((e) => Object.is(e, nextKey))) continue;\r\n    if (Object.prototype.propertyIsEnumerable.call(source, nextKey)) {\r\n      const propValue = source[nextKey];\r\n      if (excludedValues && excludedValues.some((e) => Object.is(e, propValue))) continue;\r\n\r\n      target[nextKey] = propValue;\r\n    }\r\n  }\r\n}\r\n\r\nexport function IsTemporalInstant(item: unknown): item is Temporal.Instant {\r\n  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\r\n}\r\n\r\nexport function IsTemporalDuration(item: unknown): item is Temporal.Duration {\r\n  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\r\n}\r\nexport function IsTemporalDate(item: unknown): item is Temporal.PlainDate {\r\n  return HasSlot(item, DATE_BRAND);\r\n}\r\n\r\nexport function IsTemporalTime(item: unknown): item is Temporal.PlainTime {\r\n  return HasSlot(item, TIME);\r\n}\r\n\r\nexport function IsTemporalDateTime(item: unknown): item is Temporal.PlainDateTime {\r\n  return HasSlot(item, ISO_DATE_TIME);\r\n}\r\n\r\nexport function IsTemporalYearMonth(item: unknown): item is Temporal.PlainYearMonth {\r\n  return HasSlot(item, YEAR_MONTH_BRAND);\r\n}\r\nexport function IsTemporalMonthDay(item: unknown): item is Temporal.PlainMonthDay {\r\n  return HasSlot(item, MONTH_DAY_BRAND);\r\n}\r\nexport function IsTemporalZonedDateTime(item: unknown): item is Temporal.ZonedDateTime {\r\n  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\r\n}\r\n\r\nexport function CheckReceiver<T extends AnySlottedType>(\r\n  item: unknown,\r\n  test: (item: unknown) => item is T\r\n): asserts item is T {\r\n  if (!test(item)) throw new TypeError('invalid receiver: method called with the wrong type of this-object');\r\n}\r\n\r\nexport function RejectTemporalLikeObject(item: AnyTemporalLikeType) {\r\n  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\r\n    throw new TypeError('with() does not support a calendar or timeZone property');\r\n  }\r\n  if (IsTemporalTime(item)) {\r\n    throw new TypeError('with() does not accept Temporal.PlainTime, use withPlainTime() instead');\r\n  }\r\n  if ((item as { calendar: unknown }).calendar !== undefined) {\r\n    throw new TypeError('with() does not support a calendar property');\r\n  }\r\n  if ((item as { timeZone: unknown }).timeZone !== undefined) {\r\n    throw new TypeError('with() does not support a timeZone property');\r\n  }\r\n}\r\n\r\nfunction FormatCalendarAnnotation(id: BuiltinCalendarId, showCalendar: Temporal.ShowCalendarOption['calendarName']) {\r\n  if (showCalendar === 'never') return '';\r\n  if (showCalendar === 'auto' && id === 'iso8601') return '';\r\n  const flag = showCalendar === 'critical' ? '!' : '';\r\n  return `[${flag}u-ca=${id}]`;\r\n}\r\n\r\n// Not a separate abstract operation in the spec, because it only occurs in one\r\n// place: ParseISODateTime. In the code it's more convenient to split up\r\n// ParseISODateTime for the YYYY-MM, MM-DD, and THH:MM:SS parse goals, so it's\r\n// repeated four times.\r\nfunction processAnnotations(annotations: string) {\r\n  let calendar;\r\n  let calendarWasCritical = false;\r\n  // Avoid the user code minefield of matchAll.\r\n  let match;\r\n  PARSE.annotation.lastIndex = 0;\r\n  while ((match = PARSE.annotation.exec(annotations))) {\r\n    const { 1: critical, 2: key, 3: value } = match;\r\n    if (key === 'u-ca') {\r\n      if (calendar === undefined) {\r\n        calendar = value;\r\n        calendarWasCritical = critical === '!';\r\n      } else if (critical === '!' || calendarWasCritical) {\r\n        throw new RangeError(`Invalid annotations in ${annotations}: more than one u-ca present with critical flag`);\r\n      }\r\n    } else if (critical === '!') {\r\n      throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\r\n    }\r\n  }\r\n  return calendar;\r\n}\r\n\r\nfunction ParseISODateTime(isoString: string) {\r\n  // ZDT is the superset of fields for every other Temporal type\r\n  const match = PARSE.zoneddatetime.exec(isoString);\r\n  if (!match) throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\r\n  const calendar = processAnnotations(match[16]);\r\n  let yearString = match[1];\r\n  if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\r\n  const year = +yearString;\r\n  const month = +(match[2] ?? match[4] ?? 1);\r\n  const day = +(match[3] ?? match[5] ?? 1);\r\n  const hasTime = match[6] !== undefined;\r\n  const hour = +(match[6] ?? 0);\r\n  const minute = +(match[7] ?? match[10] ?? 0);\r\n  let second = +(match[8] ?? match[11] ?? 0);\r\n  if (second === 60) second = 59;\r\n  const fraction = (match[9] ?? match[12] ?? '') + '000000000';\r\n  const millisecond = +fraction.slice(0, 3);\r\n  const microsecond = +fraction.slice(3, 6);\r\n  const nanosecond = +fraction.slice(6, 9);\r\n  let offset;\r\n  let z = false;\r\n  if (match[13]) {\r\n    offset = undefined;\r\n    z = true;\r\n  } else if (match[14]) {\r\n    offset = match[14];\r\n  }\r\n  const tzAnnotation = match[15];\r\n  RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\r\n  return {\r\n    year,\r\n    month,\r\n    day,\r\n    time: hasTime ? { hour, minute, second, millisecond, microsecond, nanosecond } : ('start-of-day' as const),\r\n    tzAnnotation,\r\n    offset,\r\n    z,\r\n    calendar\r\n  };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalInstantString(isoString: string) {\r\n  const result = ParseISODateTime(isoString);\r\n  if (!result.z && !result.offset) throw new RangeError('Temporal.Instant requires a time zone offset');\r\n  return result;\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalZonedDateTimeString(isoString: string) {\r\n  const result = ParseISODateTime(isoString);\r\n  if (!result.tzAnnotation) throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\r\n  return result;\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalDateTimeString(isoString: string) {\r\n  return ParseISODateTime(isoString);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalDateString(isoString: string) {\r\n  return ParseISODateTime(isoString);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalTimeString(isoString: string) {\r\n  const match = PARSE.time.exec(isoString);\r\n  let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\r\n  if (match) {\r\n    calendar = processAnnotations(match[10]);\r\n    hour = +(match[1] ?? 0);\r\n    minute = +(match[2] ?? match[5] ?? 0);\r\n    second = +(match[3] ?? match[6] ?? 0);\r\n    if (second === 60) second = 59;\r\n    const fraction = (match[4] ?? match[7] ?? '') + '000000000';\r\n    millisecond = +fraction.slice(0, 3);\r\n    microsecond = +fraction.slice(3, 6);\r\n    nanosecond = +fraction.slice(6, 9);\r\n    if (match[8]) throw new RangeError('Z designator not supported for PlainTime');\r\n  } else {\r\n    let time, z;\r\n    ({ time, z, calendar } = ParseISODateTime(isoString));\r\n    if (time === 'start-of-day') throw new RangeError(`time is missing in string: ${isoString}`);\r\n    if (z) throw new RangeError('Z designator not supported for PlainTime');\r\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = time);\r\n  }\r\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n  // if it's a date-time string, OK\r\n  if (/[tT ][0-9][0-9]/.test(isoString)) {\r\n    return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\r\n  }\r\n  try {\r\n    const { month, day } = ParseTemporalMonthDayString(isoString);\r\n    RejectISODate(1972, month, day);\r\n  } catch {\r\n    try {\r\n      const { year, month } = ParseTemporalYearMonthString(isoString);\r\n      RejectISODate(year, month, 1);\r\n    } catch {\r\n      return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\r\n    }\r\n  }\r\n  throw new RangeError(`invalid RFC 9557 time-only string ${isoString}; may need a T prefix`);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalYearMonthString(isoString: string) {\r\n  const match = PARSE.yearmonth.exec(isoString);\r\n  let year, month, calendar, referenceISODay;\r\n  if (match) {\r\n    calendar = processAnnotations(match[3]);\r\n    let yearString = match[1];\r\n    if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\r\n    year = +yearString;\r\n    month = +match[2];\r\n    referenceISODay = 1;\r\n    if (calendar !== undefined && calendar !== 'iso8601') {\r\n      throw new RangeError('YYYY-MM format is only valid with iso8601 calendar');\r\n    }\r\n  } else {\r\n    let z;\r\n    ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\r\n    if (z) throw new RangeError('Z designator not supported for PlainYearMonth');\r\n  }\r\n  return { year, month, calendar, referenceISODay };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalMonthDayString(isoString: string) {\r\n  const match = PARSE.monthday.exec(isoString);\r\n  let month, day, calendar, referenceISOYear;\r\n  if (match) {\r\n    calendar = processAnnotations(match[3]);\r\n    month = +match[1];\r\n    day = +match[2];\r\n    if (calendar !== undefined && calendar !== 'iso8601') {\r\n      throw new RangeError('MM-DD format is only valid with iso8601 calendar');\r\n    }\r\n  } else {\r\n    let z;\r\n    ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\r\n    if (z) throw new RangeError('Z designator not supported for PlainMonthDay');\r\n  }\r\n  return { month, day, calendar, referenceISOYear };\r\n}\r\n\r\nconst TIMEZONE_IDENTIFIER = new RegExp(`^${PARSE.timeZoneID.source}$`, 'i');\r\nconst OFFSET_IDENTIFIER = new RegExp(`^${PARSE.offsetIdentifier.source}$`);\r\n\r\nfunction throwBadTimeZoneStringError(timeZoneString: string): never {\r\n  // Offset identifiers only support minute precision, but offsets in ISO\r\n  // strings support nanosecond precision. If the identifier is invalid but\r\n  // it's a valid ISO offset, then it has sub-minute precision. Show a clearer\r\n  // error message in that case.\r\n  const msg = OFFSET.test(timeZoneString) ? 'Seconds not allowed in offset time zone' : 'Invalid time zone';\r\n  throw new RangeError(`${msg}: ${timeZoneString}`);\r\n}\r\n\r\nexport function ParseTimeZoneIdentifier(\r\n  identifier: string\r\n): { tzName: string; offsetMinutes?: undefined } | { tzName?: undefined; offsetMinutes: number } {\r\n  if (!TIMEZONE_IDENTIFIER.test(identifier)) {\r\n    throwBadTimeZoneStringError(identifier);\r\n  }\r\n  if (OFFSET_IDENTIFIER.test(identifier)) {\r\n    const offsetNanoseconds = ParseDateTimeUTCOffset(identifier);\r\n    // The regex limits the input to minutes precision, so we know that the\r\n    // division below will result in an integer.\r\n    return { offsetMinutes: offsetNanoseconds / 60e9 };\r\n  }\r\n  return { tzName: identifier };\r\n}\r\n\r\n// This operation doesn't exist in the spec, but in the polyfill it's split from\r\n// ParseTemporalTimeZoneString so that parsing can be tested separately from the\r\n// logic of converting parsed values into a named or offset identifier.\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalTimeZoneStringRaw(timeZoneString: string): {\r\n  tzAnnotation: string;\r\n  offset: string | undefined;\r\n  z: boolean;\r\n} {\r\n  if (TIMEZONE_IDENTIFIER.test(timeZoneString)) {\r\n    return { tzAnnotation: timeZoneString, offset: undefined, z: false };\r\n  }\r\n  try {\r\n    // Try parsing ISO string instead\r\n    const { tzAnnotation, offset, z } = ParseISODateTime(timeZoneString);\r\n    if (z || tzAnnotation || offset) {\r\n      return { tzAnnotation, offset, z };\r\n    }\r\n  } catch {\r\n    // fall through\r\n  }\r\n  throwBadTimeZoneStringError(timeZoneString);\r\n}\r\n\r\nfunction ParseTemporalTimeZoneString(stringIdent: string): ReturnType<typeof ParseTimeZoneIdentifier> {\r\n  const { tzAnnotation, offset, z } = ParseTemporalTimeZoneStringRaw(stringIdent);\r\n  if (tzAnnotation) return ParseTimeZoneIdentifier(tzAnnotation);\r\n  if (z) return ParseTimeZoneIdentifier('UTC');\r\n  if (offset) return ParseTimeZoneIdentifier(offset);\r\n  /* c8 ignore next */ assertNotReached();\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalDurationStringRaw(isoString: string) {\r\n  const match = PARSE.duration.exec(isoString);\r\n  if (!match) throw new RangeError(`invalid duration: ${isoString}`);\r\n  if (match.every((part, i) => i < 2 || part === undefined)) {\r\n    throw new RangeError(`invalid duration: ${isoString}`);\r\n  }\r\n  const sign = match[1] === '-' ? -1 : 1;\r\n  const years = match[2] === undefined ? 0 : ToIntegerWithTruncation(match[2]) * sign;\r\n  const months = match[3] === undefined ? 0 : ToIntegerWithTruncation(match[3]) * sign;\r\n  const weeks = match[4] === undefined ? 0 : ToIntegerWithTruncation(match[4]) * sign;\r\n  const days = match[5] === undefined ? 0 : ToIntegerWithTruncation(match[5]) * sign;\r\n  const hours = match[6] === undefined ? 0 : ToIntegerWithTruncation(match[6]) * sign;\r\n  const fHours = match[7];\r\n  const minutesStr = match[8];\r\n  const fMinutes = match[9];\r\n  const secondsStr = match[10];\r\n  const fSeconds = match[11];\r\n  let minutes = 0;\r\n  let seconds = 0;\r\n  // fractional hours, minutes, or seconds, expressed in whole nanoseconds:\r\n  let excessNanoseconds = 0;\r\n\r\n  if (fHours !== undefined) {\r\n    if (minutesStr ?? fMinutes ?? secondsStr ?? fSeconds ?? false) {\r\n      throw new RangeError('only the smallest unit can be fractional');\r\n    }\r\n    excessNanoseconds = ToIntegerWithTruncation((fHours + '000000000').slice(0, 9)) * 3600 * sign;\r\n  } else {\r\n    minutes = minutesStr === undefined ? 0 : ToIntegerWithTruncation(minutesStr) * sign;\r\n    if (fMinutes !== undefined) {\r\n      if (secondsStr ?? fSeconds ?? false) {\r\n        throw new RangeError('only the smallest unit can be fractional');\r\n      }\r\n      excessNanoseconds = ToIntegerWithTruncation((fMinutes + '000000000').slice(0, 9)) * 60 * sign;\r\n    } else {\r\n      seconds = secondsStr === undefined ? 0 : ToIntegerWithTruncation(secondsStr) * sign;\r\n      if (fSeconds !== undefined) {\r\n        excessNanoseconds = ToIntegerWithTruncation((fSeconds + '000000000').slice(0, 9)) * sign;\r\n      }\r\n    }\r\n  }\r\n\r\n  const nanoseconds = excessNanoseconds % 1000;\r\n  const microseconds = Math.trunc(excessNanoseconds / 1000) % 1000;\r\n  const milliseconds = Math.trunc(excessNanoseconds / 1e6) % 1000;\r\n  seconds += Math.trunc(excessNanoseconds / 1e9) % 60;\r\n  minutes += Math.trunc(excessNanoseconds / 60e9);\r\n\r\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\r\n}\r\n\r\nfunction ParseTemporalDurationString(isoString: string) {\r\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\r\n    ParseTemporalDurationStringRaw(isoString);\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  return new TemporalDuration(\r\n    years,\r\n    months,\r\n    weeks,\r\n    days,\r\n    hours,\r\n    minutes,\r\n    seconds,\r\n    milliseconds,\r\n    microseconds,\r\n    nanoseconds\r\n  );\r\n}\r\n\r\nexport function RegulateISODate(yearParam: number, monthParam: number, dayParam: number, overflow: Overflow) {\r\n  let year = yearParam;\r\n  let month = monthParam;\r\n  let day = dayParam;\r\n  switch (overflow) {\r\n    case 'reject':\r\n      RejectISODate(year, month, day);\r\n      break;\r\n    case 'constrain':\r\n      ({ year, month, day } = ConstrainISODate(year, month, day));\r\n      break;\r\n  }\r\n  return { year, month, day };\r\n}\r\n\r\nexport function RegulateTime(\r\n  hourParam: number,\r\n  minuteParam: number,\r\n  secondParam: number,\r\n  millisecondParam: number,\r\n  microsecondParam: number,\r\n  nanosecondParam: number,\r\n  overflow: Overflow\r\n) {\r\n  let hour = hourParam;\r\n  let minute = minuteParam;\r\n  let second = secondParam;\r\n  let millisecond = millisecondParam;\r\n  let microsecond = microsecondParam;\r\n  let nanosecond = nanosecondParam;\r\n\r\n  switch (overflow) {\r\n    case 'reject':\r\n      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n      break;\r\n    case 'constrain':\r\n      hour = ConstrainToRange(hour, 0, 23);\r\n      minute = ConstrainToRange(minute, 0, 59);\r\n      second = ConstrainToRange(second, 0, 59);\r\n      millisecond = ConstrainToRange(millisecond, 0, 999);\r\n      microsecond = ConstrainToRange(microsecond, 0, 999);\r\n      nanosecond = ConstrainToRange(nanosecond, 0, 999);\r\n      break;\r\n  }\r\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\r\n}\r\n\r\nexport function ToTemporalPartialDurationRecord(temporalDurationLike: Temporal.DurationLike | string) {\r\n  if (!IsObject(temporalDurationLike)) {\r\n    throw new TypeError('invalid duration-like');\r\n  }\r\n  const result: Record<(typeof DURATION_FIELDS)[number], number | undefined> = {\r\n    years: undefined,\r\n    months: undefined,\r\n    weeks: undefined,\r\n    days: undefined,\r\n    hours: undefined,\r\n    minutes: undefined,\r\n    seconds: undefined,\r\n    milliseconds: undefined,\r\n    microseconds: undefined,\r\n    nanoseconds: undefined\r\n  };\r\n  let any = false;\r\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\r\n    const property = DURATION_FIELDS[index];\r\n    const value = temporalDurationLike[property];\r\n    if (value !== undefined) {\r\n      any = true;\r\n      result[property] = ToIntegerIfIntegral(value);\r\n    }\r\n  }\r\n  if (!any) {\r\n    throw new TypeError('invalid duration-like');\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function AdjustDateDurationRecord(\r\n  { years, months, weeks, days }: DateDuration,\r\n  newDays: number,\r\n  newWeeks?: number,\r\n  newMonths?: number\r\n) {\r\n  return {\r\n    years,\r\n    months: newMonths ?? months,\r\n    weeks: newWeeks ?? weeks,\r\n    days: newDays ?? days\r\n  };\r\n}\r\n\r\nexport function ZeroDateDuration() {\r\n  return { years: 0, months: 0, weeks: 0, days: 0 };\r\n}\r\n\r\nexport function CombineISODateAndTimeRecord(isoDate: ISODate, time: TimeRecord) {\r\n  return { isoDate, time };\r\n}\r\n\r\nexport function MidnightTimeRecord() {\r\n  return { deltaDays: 0, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\r\n}\r\n\r\nexport function NoonTimeRecord() {\r\n  return { deltaDays: 0, hour: 12, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\r\n}\r\n\r\nexport function GetTemporalOverflowOption(options: Temporal.AssignmentOptions) {\r\n  return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\r\n}\r\n\r\nexport function GetTemporalDisambiguationOption(options: Temporal.ToInstantOptions) {\r\n  return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\r\n}\r\n\r\nexport function GetRoundingModeOption(\r\n  options: { roundingMode?: Temporal.RoundingMode },\r\n  fallback: Temporal.RoundingMode\r\n) {\r\n  return GetOption(\r\n    options,\r\n    'roundingMode',\r\n    ['ceil', 'floor', 'expand', 'trunc', 'halfCeil', 'halfFloor', 'halfExpand', 'halfTrunc', 'halfEven'],\r\n    fallback\r\n  );\r\n}\r\n\r\nfunction NegateRoundingMode(roundingMode: Temporal.RoundingMode) {\r\n  switch (roundingMode) {\r\n    case 'ceil':\r\n      return 'floor';\r\n    case 'floor':\r\n      return 'ceil';\r\n    case 'halfCeil':\r\n      return 'halfFloor';\r\n    case 'halfFloor':\r\n      return 'halfCeil';\r\n    default:\r\n      return roundingMode;\r\n  }\r\n}\r\n\r\nexport function GetTemporalOffsetOption(\r\n  options: Temporal.OffsetDisambiguationOptions,\r\n  fallback: Required<Temporal.OffsetDisambiguationOptions>['offset']\r\n) {\r\n  return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\r\n}\r\n\r\nexport function GetTemporalShowCalendarNameOption(options: Temporal.ShowCalendarOption) {\r\n  return GetOption(options, 'calendarName', ['auto', 'always', 'never', 'critical'], 'auto');\r\n}\r\n\r\nexport function GetTemporalShowTimeZoneNameOption(options: Temporal.ZonedDateTimeToStringOptions) {\r\n  return GetOption(options, 'timeZoneName', ['auto', 'never', 'critical'], 'auto');\r\n}\r\n\r\nexport function GetTemporalShowOffsetOption(options: Temporal.ZonedDateTimeToStringOptions) {\r\n  return GetOption(options, 'offset', ['auto', 'never'], 'auto');\r\n}\r\n\r\nexport function GetDirectionOption(options: { direction?: 'next' | 'previous' }) {\r\n  return GetOption(options, 'direction', ['next', 'previous'], REQUIRED);\r\n}\r\n\r\nexport function GetTemporalRoundingIncrementOption(options: { roundingIncrement?: number }) {\r\n  let increment = options.roundingIncrement;\r\n  if (increment === undefined) return 1;\r\n  const integerIncrement = ToIntegerWithTruncation(increment);\r\n  if (integerIncrement < 1 || integerIncrement > 1e9) {\r\n    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${increment}`);\r\n  }\r\n  return integerIncrement;\r\n}\r\nexport function ValidateTemporalRoundingIncrement(increment: number, dividend: number, inclusive: boolean) {\r\n  const maximum = inclusive ? dividend : dividend - 1;\r\n  if (increment > maximum) {\r\n    throw new RangeError(`roundingIncrement must be at least 1 and less than ${maximum}, not ${increment}`);\r\n  }\r\n  if (dividend % increment !== 0) {\r\n    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\r\n  }\r\n}\r\n\r\nexport function GetTemporalFractionalSecondDigitsOption(\r\n  normalizedOptions: Temporal.ToStringPrecisionOptions\r\n): Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] {\r\n  const digitsValue = normalizedOptions.fractionalSecondDigits;\r\n  if (digitsValue === undefined) return 'auto';\r\n  if (typeof digitsValue !== 'number') {\r\n    if (ToString(digitsValue) !== 'auto') {\r\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\r\n    }\r\n    return 'auto';\r\n  }\r\n  const digitCount = Math.floor(digitsValue);\r\n  if (!Number.isFinite(digitCount) || digitCount < 0 || digitCount > 9) {\r\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\r\n  }\r\n  return digitCount as Exclude<Temporal.ToStringPrecisionOptions['fractionalSecondDigits'], 'auto'>;\r\n}\r\n\r\ninterface SecondsStringPrecisionRecord {\r\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] | 'minute';\r\n  unit: UnitSmallerThanOrEqualTo<'minute'>;\r\n  increment: number;\r\n}\r\n\r\nexport function ToSecondsStringPrecisionRecord(\r\n  smallestUnit: Temporal.ToStringPrecisionOptions['smallestUnit'],\r\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits']\r\n): SecondsStringPrecisionRecord {\r\n  switch (smallestUnit) {\r\n    case 'minute':\r\n      return { precision: 'minute', unit: 'minute', increment: 1 };\r\n    case 'second':\r\n      return { precision: 0, unit: 'second', increment: 1 };\r\n    case 'millisecond':\r\n      return { precision: 3, unit: 'millisecond', increment: 1 };\r\n    case 'microsecond':\r\n      return { precision: 6, unit: 'microsecond', increment: 1 };\r\n    case 'nanosecond':\r\n      return { precision: 9, unit: 'nanosecond', increment: 1 };\r\n    default: // fall through if option not given\r\n  }\r\n  switch (precision) {\r\n    case 'auto':\r\n      return { precision, unit: 'nanosecond', increment: 1 };\r\n    case 0:\r\n      return { precision, unit: 'second', increment: 1 };\r\n    case 1:\r\n    case 2:\r\n    case 3:\r\n      return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\r\n    case 4:\r\n    case 5:\r\n    case 6:\r\n      return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\r\n    case 7:\r\n    case 8:\r\n    case 9:\r\n      return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\r\n    default:\r\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${precision}`);\r\n  }\r\n}\r\n\r\nexport const REQUIRED = Symbol('~required~');\r\n\r\ninterface TemporalUnitOptionsBag {\r\n  smallestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\r\n  largestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit | 'auto';\r\n  unit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\r\n}\r\ntype UnitTypeMapping = {\r\n  date: Temporal.DateUnit;\r\n  time: Temporal.TimeUnit;\r\n  datetime: Temporal.DateTimeUnit;\r\n};\r\n// This type specifies the allowed defaults for each unit key type.\r\ntype AllowedGetTemporalUnitDefaultValues = {\r\n  smallestUnit: undefined;\r\n  largestUnit: 'auto' | undefined;\r\n  unit: undefined;\r\n};\r\n\r\nexport function GetTemporalUnitValuedOption<\r\n  U extends keyof TemporalUnitOptionsBag,\r\n  T extends keyof UnitTypeMapping,\r\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\r\n  R extends Exclude<D, typeof REQUIRED> | UnitTypeMapping[T]\r\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D): R;\r\nexport function GetTemporalUnitValuedOption<\r\n  U extends keyof TemporalUnitOptionsBag,\r\n  T extends keyof UnitTypeMapping,\r\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\r\n  E extends 'auto' | Temporal.DateTimeUnit,\r\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\r\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D, extraValues: ReadonlyArray<E>): R;\r\n// This signature of the function is NOT used in type-checking, so restricting\r\n// the default value via generic binding like the other overloads isn't\r\n// necessary.\r\nexport function GetTemporalUnitValuedOption<\r\n  T extends keyof UnitTypeMapping,\r\n  D extends typeof REQUIRED | UnitTypeMapping[T] | 'auto' | undefined,\r\n  E extends 'auto' | Temporal.DateTimeUnit,\r\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\r\n>(\r\n  options: TemporalUnitOptionsBag,\r\n  key: keyof typeof options,\r\n  unitGroup: T,\r\n  requiredOrDefault: D,\r\n  extraValues: ReadonlyArray<E> | never[] = []\r\n): R {\r\n  let allowedSingular: Array<Temporal.DateTimeUnit | 'auto'> = [];\r\n  for (let index = 0; index < TEMPORAL_UNITS.length; index++) {\r\n    const unitInfo = TEMPORAL_UNITS[index];\r\n    const singular = unitInfo[1];\r\n    const category = unitInfo[2];\r\n    if (unitGroup === 'datetime' || unitGroup === category) {\r\n      allowedSingular.push(singular);\r\n    }\r\n  }\r\n  allowedSingular = allowedSingular.concat(extraValues);\r\n  let defaultVal: typeof REQUIRED | Temporal.DateTimeUnit | 'auto' | undefined = requiredOrDefault;\r\n  if (defaultVal === REQUIRED) {\r\n    defaultVal = undefined;\r\n  } else if (defaultVal !== undefined) {\r\n    allowedSingular.push(defaultVal);\r\n  }\r\n  let allowedValues: Array<Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit> | 'auto'> = [];\r\n  allowedValues = allowedValues.concat(allowedSingular);\r\n  for (let index = 0; index < allowedSingular.length; index++) {\r\n    const singular = allowedSingular[index];\r\n    const plural = PLURAL_FOR[singular];\r\n    if (plural !== undefined) allowedValues.push(plural);\r\n  }\r\n  let retval = GetOption(options, key, allowedValues, defaultVal);\r\n  if (retval === undefined && requiredOrDefault === REQUIRED) {\r\n    throw new RangeError(`${key} is required`);\r\n  }\r\n  // Coerce any plural units into their singular form\r\n  return (retval && retval in SINGULAR_FOR ? SINGULAR_FOR[retval] : retval) as R;\r\n}\r\n\r\nexport function GetTemporalRelativeToOption(options: {\r\n  relativeTo?:\r\n    | Temporal.ZonedDateTime\r\n    | Temporal.PlainDateTime\r\n    | Temporal.ZonedDateTimeLike\r\n    | Temporal.PlainDateTimeLike\r\n    | string\r\n    | undefined;\r\n}):\r\n  | { zonedRelativeTo?: Temporal.ZonedDateTime; plainRelativeTo?: never }\r\n  | { plainRelativeTo?: Temporal.PlainDate; zonedRelativeTo?: never } {\r\n  const relativeTo = options.relativeTo;\r\n  if (relativeTo === undefined) return {};\r\n\r\n  let offsetBehaviour: OffsetBehaviour = 'option';\r\n  let matchMinutes = false;\r\n  let isoDate, time, calendar, timeZone, offset;\r\n  if (IsObject(relativeTo)) {\r\n    if (IsTemporalZonedDateTime(relativeTo)) {\r\n      return { zonedRelativeTo: relativeTo };\r\n    }\r\n    if (IsTemporalDate(relativeTo)) return { plainRelativeTo: relativeTo };\r\n    if (IsTemporalDateTime(relativeTo)) {\r\n      return {\r\n        plainRelativeTo: CreateTemporalDate(GetSlot(relativeTo, ISO_DATE_TIME).isoDate, GetSlot(relativeTo, CALENDAR))\r\n      };\r\n    }\r\n    calendar = GetTemporalCalendarIdentifierWithISODefault(relativeTo);\r\n    const fields = PrepareCalendarFields(\r\n      calendar,\r\n      relativeTo,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\r\n      []\r\n    );\r\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, 'constrain'));\r\n    ({ offset, timeZone } = fields);\r\n    if (offset === undefined) offsetBehaviour = 'wall';\r\n  } else {\r\n    let tzAnnotation, z, year, month, day;\r\n    ({ year, month, day, time, calendar, tzAnnotation, offset, z } = ParseISODateTime(RequireString(relativeTo)));\r\n    if (tzAnnotation) {\r\n      timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\r\n      if (z) {\r\n        offsetBehaviour = 'exact';\r\n      } else if (!offset) {\r\n        offsetBehaviour = 'wall';\r\n      }\r\n      matchMinutes = true;\r\n    } else if (z) {\r\n      throw new RangeError(\r\n        'Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone'\r\n      );\r\n    }\r\n    if (!calendar) calendar = 'iso8601';\r\n    calendar = CanonicalizeCalendar(calendar);\r\n    isoDate = { year, month, day };\r\n  }\r\n  if (timeZone === undefined) {\r\n    return { plainRelativeTo: CreateTemporalDate(isoDate, calendar) };\r\n  }\r\n  const offsetNs = offsetBehaviour === 'option' ? ParseDateTimeUTCOffset(castExists(offset)) : 0;\r\n  const epochNanoseconds = InterpretISODateTimeOffset(\r\n    isoDate,\r\n    time,\r\n    offsetBehaviour,\r\n    offsetNs,\r\n    timeZone,\r\n    'compatible',\r\n    'reject',\r\n    matchMinutes\r\n  );\r\n  return { zonedRelativeTo: CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar) };\r\n}\r\n\r\nexport function DefaultTemporalLargestUnit(duration: Temporal.Duration) {\r\n  if (GetSlot(duration, YEARS) !== 0) return 'year';\r\n  if (GetSlot(duration, MONTHS) !== 0) return 'month';\r\n  if (GetSlot(duration, WEEKS) !== 0) return 'week';\r\n  if (GetSlot(duration, DAYS) !== 0) return 'day';\r\n  if (GetSlot(duration, HOURS) !== 0) return 'hour';\r\n  if (GetSlot(duration, MINUTES) !== 0) return 'minute';\r\n  if (GetSlot(duration, SECONDS) !== 0) return 'second';\r\n  if (GetSlot(duration, MILLISECONDS) !== 0) return 'millisecond';\r\n  if (GetSlot(duration, MICROSECONDS) !== 0) return 'microsecond';\r\n  return 'nanosecond';\r\n}\r\n\r\nexport function LargerOfTwoTemporalUnits<T1 extends Temporal.DateTimeUnit, T2 extends Temporal.DateTimeUnit>(\r\n  unit1: T1,\r\n  unit2: T2\r\n) {\r\n  const i1 = UNITS_DESCENDING.indexOf(unit1);\r\n  const i2 = UNITS_DESCENDING.indexOf(unit2);\r\n  if (i1 > i2) {\r\n    return unit2;\r\n  }\r\n  return unit1;\r\n}\r\n\r\nexport function IsCalendarUnit(unit: Temporal.DateTimeUnit): unit is Exclude<Temporal.DateUnit, 'day'> {\r\n  return unit === 'year' || unit === 'month' || unit === 'week';\r\n}\r\n\r\nexport function TemporalUnitCategory(unit: Temporal.DateTimeUnit) {\r\n  if (IsCalendarUnit(unit) || unit === 'day') return 'date';\r\n  return 'time';\r\n}\r\n\r\nfunction calendarImplForID(calendar: BuiltinCalendarId) {\r\n  return GetIntrinsic('%calendarImpl%')(calendar);\r\n}\r\n\r\nexport function calendarImplForObj(\r\n  temporalObj:\r\n    | Temporal.PlainDate\r\n    | Temporal.PlainDateTime\r\n    | Temporal.PlainMonthDay\r\n    | Temporal.PlainYearMonth\r\n    | Temporal.ZonedDateTime\r\n) {\r\n  return GetIntrinsic('%calendarImpl%')(GetSlot(temporalObj, CALENDAR));\r\n}\r\n\r\ntype ISODateToFieldsReturn<Type extends ISODateToFieldsType> = Resolve<{\r\n  year: Type extends 'date' | 'year-month' ? number : never;\r\n  monthCode: string;\r\n  day: Type extends 'date' | 'month-day' ? number : never;\r\n}>;\r\n\r\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate): ISODateToFieldsReturn<'date'>;\r\nexport function ISODateToFields<T extends ISODateToFieldsType>(\r\n  calendar: BuiltinCalendarId,\r\n  isoDate: ISODate,\r\n  type: T\r\n): ISODateToFieldsReturn<T>;\r\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate, type = 'date') {\r\n  const fields = Object.create(null);\r\n  const calendarImpl = calendarImplForID(calendar);\r\n  const calendarDate = calendarImpl.isoToDate(isoDate, { year: true, monthCode: true, day: true });\r\n\r\n  fields.monthCode = calendarDate.monthCode;\r\n  if (type === 'month-day' || type === 'date') {\r\n    fields.day = calendarDate.day;\r\n  }\r\n  if (type === 'year-month' || type === 'date') {\r\n    fields.year = calendarDate.year;\r\n  }\r\n  return fields;\r\n}\r\n\r\ntype Prop<T, K> = T extends unknown ? (K extends keyof T ? T[K] : undefined) : 'ThisShouldNeverHappen';\r\n\r\ntype FieldObjectWithRequired<FieldKeys extends FieldKey> = Resolve<\r\n  // The resulting object type contains:\r\n  // - All keys in FieldKeys, which are required properties and their values\r\n  //   don't include undefined.\r\n  // - All the other keys in CalendarFieldsRecord that aren't in FieldKeys,\r\n  //   which are optional properties and their value types explicitly include\r\n  //   undefined.\r\n  {\r\n    -readonly [k in FieldKeys]: Exclude<Prop<CalendarFieldsRecord, k>, undefined>;\r\n  } & {\r\n    -readonly [k in Exclude<Keys<CalendarFieldsRecord>, FieldKeys>]?: Prop<CalendarFieldsRecord, k> | undefined;\r\n  }\r\n>;\r\n\r\ntype PrepareCalendarFieldsReturn<\r\n  FieldKeys extends FieldKey,\r\n  RequiredFieldsOpt extends ReadonlyArray<FieldKey> | 'partial'\r\n> = RequiredFieldsOpt extends 'partial' ? Partial<CalendarFieldsRecord> : FieldObjectWithRequired<FieldKeys>;\r\n\r\nexport function PrepareCalendarFields<\r\n  FieldKeys extends FieldKey,\r\n  RequiredFields extends ReadonlyArray<FieldKey> | 'partial'\r\n>(\r\n  calendar: BuiltinCalendarId,\r\n  bag: Partial<Record<FieldKeys, unknown>>,\r\n  calendarFieldNames: Array<FieldKeys>,\r\n  nonCalendarFieldNames: Array<FieldKeys>,\r\n  requiredFields: RequiredFields\r\n): PrepareCalendarFieldsReturn<FieldKeys, RequiredFields> {\r\n  const extraFieldNames = calendarImplForID(calendar).extraFields(calendarFieldNames) as FieldKeys[];\r\n  const fields = calendarFieldNames.concat(nonCalendarFieldNames, extraFieldNames);\r\n  const result: Partial<Record<AnyTemporalKey, unknown>> = Object.create(null);\r\n  let any = false;\r\n  fields.sort();\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const property = fields[index];\r\n    const value = bag[property];\r\n    if (value !== undefined) {\r\n      any = true;\r\n      result[property] = castExists(BUILTIN_CASTS[property])(value);\r\n    } else if (requiredFields !== 'partial') {\r\n      if (requiredFields.includes(property)) {\r\n        throw new TypeError(`required property '${property}' missing or undefined`);\r\n      }\r\n      result[property] = BUILTIN_DEFAULTS[property];\r\n    }\r\n  }\r\n  if (requiredFields === 'partial' && !any) {\r\n    throw new TypeError('no supported properties found');\r\n  }\r\n  return result as unknown as PrepareCalendarFieldsReturn<FieldKeys, RequiredFields>;\r\n}\r\n\r\ntype FieldCompleteness = 'complete' | 'partial';\r\n\r\nexport function ToTemporalTimeRecord(bag: Partial<Record<keyof TimeRecord, string | number>>): TimeRecord;\r\nexport function ToTemporalTimeRecord(\r\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\r\n  completeness: 'partial'\r\n): Partial<TimeRecord>;\r\nexport function ToTemporalTimeRecord(\r\n  bag: Partial<Record<keyof TimeRecord, string | number>>,\r\n  completeness: 'complete'\r\n): TimeRecord;\r\nexport function ToTemporalTimeRecord(\r\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\r\n  completeness: FieldCompleteness = 'complete'\r\n): Partial<TimeRecord> {\r\n  // NOTE: Field order is sorted to make the sort in PrepareTemporalFields more efficient.\r\n  const fields: (keyof TimeRecord)[] = ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second'];\r\n  let any = false;\r\n  const result: Partial<TimeRecord> = Object.create(null);\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const field = fields[index];\r\n    const value = bag[field];\r\n    if (value !== undefined) {\r\n      result[field] = ToIntegerWithTruncation(value);\r\n      any = true;\r\n    } else if (completeness === 'complete') {\r\n      result[field] = 0;\r\n    }\r\n  }\r\n  if (!any) throw new TypeError('invalid time-like');\r\n  return result;\r\n}\r\n\r\nexport function ToTemporalDate(\r\n  item: PlainDateParams['from'][0],\r\n  options?: PlainDateParams['from'][1]\r\n): Temporal.PlainDate {\r\n  if (IsObject(item)) {\r\n    if (IsTemporalDate(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDate(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\r\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\r\n      const isoDate = isoDateTime.isoDate;\r\n      return CreateTemporalDate(isoDate, GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalDateTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\r\n      return CreateTemporalDate(GetSlot(item, ISO_DATE_TIME).isoDate, GetSlot(item, CALENDAR));\r\n    }\r\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    const isoDate = CalendarDateFromFields(calendar, fields, overflow);\r\n    return CreateTemporalDate(isoDate, calendar);\r\n  }\r\n  let { year, month, day, calendar, z } = ParseTemporalDateString(RequireString(item));\r\n  if (z) throw new RangeError('Z designator not supported for PlainDate');\r\n  if (!calendar) calendar = 'iso8601';\r\n  calendar = CanonicalizeCalendar(calendar);\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\r\n  GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\r\n  return CreateTemporalDate({ year, month, day }, calendar);\r\n}\r\n\r\nexport function InterpretTemporalDateTimeFields(\r\n  calendar: BuiltinCalendarId,\r\n  fields: CalendarFieldsRecord & TimeRecord,\r\n  overflow: Overflow\r\n) {\r\n  const isoDate = CalendarDateFromFields(calendar, fields, overflow);\r\n  const time = RegulateTime(\r\n    fields.hour,\r\n    fields.minute,\r\n    fields.second,\r\n    fields.millisecond,\r\n    fields.microsecond,\r\n    fields.nanosecond,\r\n    overflow\r\n  );\r\n  return CombineISODateAndTimeRecord(isoDate, time);\r\n}\r\n\r\nexport function ToTemporalDateTime(item: PlainDateTimeParams['from'][0], options?: PlainDateTimeParams['from'][1]) {\r\n  let isoDate, time, calendar;\r\n\r\n  if (IsObject(item)) {\r\n    if (IsTemporalDateTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDateTime(GetSlot(item, ISO_DATE_TIME), GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDateTime(isoDateTime, GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalDate(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDateTime(\r\n        CombineISODateAndTimeRecord(GetSlot(item, ISO_DATE), MidnightTimeRecord()),\r\n        GetSlot(item, CALENDAR)\r\n      );\r\n    }\r\n\r\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(\r\n      calendar,\r\n      item,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\r\n      []\r\n    );\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\r\n  } else {\r\n    let z, year, month, day;\r\n    ({ year, month, day, time, calendar, z } = ParseTemporalDateTimeString(RequireString(item)));\r\n    if (z) throw new RangeError('Z designator not supported for PlainDateTime');\r\n    if (time === 'start-of-day') time = MidnightTimeRecord();\r\n    RejectDateTime(\r\n      year,\r\n      month,\r\n      day,\r\n      time.hour,\r\n      time.minute,\r\n      time.second,\r\n      time.millisecond,\r\n      time.microsecond,\r\n      time.nanosecond\r\n    );\r\n    if (!calendar) calendar = 'iso8601';\r\n    calendar = CanonicalizeCalendar(calendar);\r\n    GetTemporalOverflowOption(GetOptionsObject(options));\r\n    isoDate = { year, month, day };\r\n  }\r\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, time);\r\n  return CreateTemporalDateTime(isoDateTime, calendar);\r\n}\r\n\r\nexport function ToTemporalDuration(item: DurationParams['from'][0]) {\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  if (IsTemporalDuration(item)) {\r\n    return new TemporalDuration(\r\n      GetSlot(item, YEARS),\r\n      GetSlot(item, MONTHS),\r\n      GetSlot(item, WEEKS),\r\n      GetSlot(item, DAYS),\r\n      GetSlot(item, HOURS),\r\n      GetSlot(item, MINUTES),\r\n      GetSlot(item, SECONDS),\r\n      GetSlot(item, MILLISECONDS),\r\n      GetSlot(item, MICROSECONDS),\r\n      GetSlot(item, NANOSECONDS)\r\n    );\r\n  }\r\n  if (!IsObject(item)) {\r\n    return ParseTemporalDurationString(RequireString(item));\r\n  }\r\n  const result = {\r\n    years: 0,\r\n    months: 0,\r\n    weeks: 0,\r\n    days: 0,\r\n    hours: 0,\r\n    minutes: 0,\r\n    seconds: 0,\r\n    milliseconds: 0,\r\n    microseconds: 0,\r\n    nanoseconds: 0\r\n  };\r\n  let partial = ToTemporalPartialDurationRecord(item);\r\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\r\n    const property = DURATION_FIELDS[index];\r\n    const value = partial[property];\r\n    if (value !== undefined) {\r\n      result[property] = value;\r\n    }\r\n  }\r\n  return new TemporalDuration(\r\n    result.years,\r\n    result.months,\r\n    result.weeks,\r\n    result.days,\r\n    result.hours,\r\n    result.minutes,\r\n    result.seconds,\r\n    result.milliseconds,\r\n    result.microseconds,\r\n    result.nanoseconds\r\n  );\r\n}\r\n\r\nexport function ToTemporalInstant(itemParam: InstantParams['from'][0]) {\r\n  let item: string | number;\r\n  if (IsObject(itemParam)) {\r\n    if (IsTemporalInstant(itemParam) || IsTemporalZonedDateTime(itemParam)) {\r\n      return CreateTemporalInstant(GetSlot(itemParam, EPOCHNANOSECONDS));\r\n    }\r\n    item = ToPrimitive(itemParam, String);\r\n  } else {\r\n    item = itemParam;\r\n  }\r\n  const { year, month, day, time, offset, z } = ParseTemporalInstantString(RequireString(item));\r\n  const {\r\n    hour = 0,\r\n    minute = 0,\r\n    second = 0,\r\n    millisecond = 0,\r\n    microsecond = 0,\r\n    nanosecond = 0\r\n  } = time === 'start-of-day' ? {} : time;\r\n\r\n  // ParseTemporalInstantString ensures that either `z` is true or or `offset` is non-undefined\r\n  const offsetNanoseconds = z ? 0 : ParseDateTimeUTCOffset(castExists(offset));\r\n  const balanced = BalanceISODateTime(\r\n    year,\r\n    month,\r\n    day,\r\n    hour,\r\n    minute,\r\n    second,\r\n    millisecond,\r\n    microsecond,\r\n    nanosecond - offsetNanoseconds\r\n  );\r\n  CheckISODaysRange(balanced.isoDate);\r\n  const epochNanoseconds = GetUTCEpochNanoseconds(balanced);\r\n  return CreateTemporalInstant(epochNanoseconds);\r\n}\r\n\r\nexport function ToTemporalMonthDay(item: PlainMonthDayParams['from'][0], options?: PlainMonthDayParams['from'][1]) {\r\n  if (IsObject(item)) {\r\n    if (IsTemporalMonthDay(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalMonthDay(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\r\n    }\r\n    let calendar;\r\n    if (HasSlot(item, CALENDAR)) {\r\n      calendar = GetSlot(item, CALENDAR);\r\n    } else {\r\n      calendar = item.calendar;\r\n      if (calendar === undefined) calendar = 'iso8601';\r\n      calendar = ToTemporalCalendarIdentifier(calendar);\r\n    }\r\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    const isoDate = CalendarMonthDayFromFields(calendar, fields, overflow);\r\n    return CreateTemporalMonthDay(isoDate, calendar);\r\n  }\r\n\r\n  let { month, day, referenceISOYear, calendar } = ParseTemporalMonthDayString(RequireString(item));\r\n  if (calendar === undefined) calendar = 'iso8601';\r\n  calendar = CanonicalizeCalendar(calendar);\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\r\n\r\n  GetTemporalOverflowOption(GetOptionsObject(options));\r\n  if (calendar === 'iso8601') {\r\n    const isoCalendarReferenceYear = 1972; // First leap year after Unix epoch\r\n    return CreateTemporalMonthDay({ year: isoCalendarReferenceYear, month, day }, calendar);\r\n  }\r\n  assertExists(referenceISOYear);\r\n  let isoDate = { year: referenceISOYear, month, day };\r\n  RejectDateRange(isoDate);\r\n  const result = ISODateToFields(calendar, isoDate, 'month-day');\r\n  isoDate = CalendarMonthDayFromFields(calendar, result, 'constrain');\r\n  return CreateTemporalMonthDay(isoDate, calendar);\r\n}\r\n\r\nexport function ToTemporalTime(item: PlainTimeParams['from'][0], options?: PlainTimeParams['from'][1]) {\r\n  let time;\r\n  if (IsObject(item)) {\r\n    if (IsTemporalTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalTime(GetSlot(item, TIME));\r\n    }\r\n    if (IsTemporalDateTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalTime(GetSlot(item, ISO_DATE_TIME).time);\r\n    }\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalTime(isoDateTime.time);\r\n    }\r\n    const { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow);\r\n  } else {\r\n    time = ParseTemporalTimeString(RequireString(item));\r\n    GetTemporalOverflowOption(GetOptionsObject(options));\r\n  }\r\n  return CreateTemporalTime(time);\r\n}\r\n\r\nexport function ToTimeRecordOrMidnight(item: PlainTimeParams['from'][0] | undefined) {\r\n  if (item === undefined) return MidnightTimeRecord();\r\n  return GetSlot(ToTemporalTime(item), TIME);\r\n}\r\n\r\nexport function ToTemporalYearMonth(\r\n  item: PlainYearMonthParams['from'][0],\r\n  options?: PlainYearMonthParams['from'][1]\r\n): Temporal.PlainYearMonth {\r\n  if (IsObject(item)) {\r\n    if (IsTemporalYearMonth(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalYearMonth(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\r\n    }\r\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode'], [], []);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    const isoDate = CalendarYearMonthFromFields(calendar, fields, overflow);\r\n    return CreateTemporalYearMonth(isoDate, calendar);\r\n  }\r\n\r\n  let { year, month, referenceISODay, calendar } = ParseTemporalYearMonthString(RequireString(item));\r\n  if (calendar === undefined) calendar = 'iso8601';\r\n  calendar = CanonicalizeCalendar(calendar);\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\r\n\r\n  GetTemporalOverflowOption(GetOptionsObject(options));\r\n  let isoDate = { year, month, day: referenceISODay };\r\n  RejectYearMonthRange(isoDate);\r\n  const result = ISODateToFields(calendar, isoDate, 'year-month');\r\n  isoDate = CalendarYearMonthFromFields(calendar, result, 'constrain');\r\n  return CreateTemporalYearMonth(isoDate, calendar);\r\n}\r\n\r\ntype OffsetBehaviour = 'wall' | 'exact' | 'option';\r\n\r\nexport function InterpretISODateTimeOffset(\r\n  isoDate: ISODate,\r\n  time: 'start-of-day' | TimeRecord,\r\n  offsetBehaviour: OffsetBehaviour,\r\n  offsetNs: number,\r\n  timeZone: string,\r\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>,\r\n  offsetOpt: Temporal.OffsetDisambiguationOptions['offset'],\r\n  matchMinute: boolean\r\n) {\r\n  // start-of-day signifies that we had a string such as YYYY-MM-DD[Zone]. It is\r\n  // grammatically not possible to specify a UTC offset in that string, so the\r\n  // behaviour collapses into ~WALL~, which is equivalent to offset: \"ignore\".\r\n  if (time === 'start-of-day') {\r\n    assert(offsetBehaviour === 'wall', 'offset cannot be provided in YYYY-MM-DD[Zone] string');\r\n    assert(offsetNs === 0, 'offset cannot be provided in YYYY-MM-DD[Zone] string');\r\n    return GetStartOfDay(timeZone, isoDate);\r\n  }\r\n\r\n  const dt = CombineISODateAndTimeRecord(isoDate, time);\r\n\r\n  if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\r\n    // Simple case: ISO string without a TZ offset (or caller wants to ignore\r\n    // the offset), so just convert DateTime to Instant in the given time zone\r\n    return GetEpochNanosecondsFor(timeZone, dt, disambiguation);\r\n  }\r\n\r\n  // The caller wants the offset to always win ('use') OR the caller is OK\r\n  // with the offset winning ('prefer' or 'reject') as long as it's valid\r\n  // for this timezone and date/time.\r\n  if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\r\n    // Calculate the instant for the input's date/time and offset\r\n    const balanced = BalanceISODateTime(\r\n      isoDate.year,\r\n      isoDate.month,\r\n      isoDate.day,\r\n      time.hour,\r\n      time.minute,\r\n      time.second,\r\n      time.millisecond,\r\n      time.microsecond,\r\n      time.nanosecond - offsetNs\r\n    );\r\n    CheckISODaysRange(balanced.isoDate);\r\n    const epochNs = GetUTCEpochNanoseconds(balanced);\r\n    ValidateEpochNanoseconds(epochNs);\r\n    return epochNs;\r\n  }\r\n\r\n  CheckISODaysRange(isoDate);\r\n  const utcEpochNs = GetUTCEpochNanoseconds(dt);\r\n\r\n  // \"prefer\" or \"reject\"\r\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, dt);\r\n  for (let index = 0; index < possibleEpochNs.length; index++) {\r\n    const candidate = possibleEpochNs[index];\r\n    const candidateOffset = JSBI.toNumber(JSBI.subtract(utcEpochNs, candidate));\r\n    const roundedCandidateOffset = RoundNumberToIncrement(candidateOffset, 60e9, 'halfExpand');\r\n    if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\r\n      return candidate;\r\n    }\r\n  }\r\n\r\n  // the user-provided offset doesn't match any instants for this time\r\n  // zone and date/time.\r\n  if (offsetOpt === 'reject') {\r\n    const offsetStr = FormatUTCOffsetNanoseconds(offsetNs);\r\n    const dtStr = ISODateTimeToString(dt, 'iso8601', 'auto');\r\n    throw new RangeError(`Offset ${offsetStr} is invalid for ${dtStr} in ${timeZone}`);\r\n  }\r\n  // fall through: offsetOpt === 'prefer', but the offset doesn't match\r\n  // so fall back to use the time zone instead.\r\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, dt, disambiguation);\r\n}\r\n\r\nexport function ToTemporalZonedDateTime(\r\n  item: ZonedDateTimeParams['from'][0],\r\n  options?: ZonedDateTimeParams['from'][1]\r\n) {\r\n  let isoDate, time, timeZone, offset, calendar;\r\n  let matchMinute = false;\r\n  let offsetBehaviour: OffsetBehaviour = 'option';\r\n  let disambiguation, offsetOpt;\r\n  if (IsObject(item)) {\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const resolvedOptions = GetOptionsObject(options);\r\n      GetTemporalDisambiguationOption(resolvedOptions); // validate and ignore\r\n      GetTemporalOffsetOption(resolvedOptions, 'reject');\r\n      GetTemporalOverflowOption(resolvedOptions);\r\n      return CreateTemporalZonedDateTime(\r\n        GetSlot(item, EPOCHNANOSECONDS),\r\n        GetSlot(item, TIME_ZONE),\r\n        GetSlot(item, CALENDAR)\r\n      );\r\n    }\r\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(\r\n      calendar,\r\n      item,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\r\n      ['timeZone']\r\n    );\r\n    ({ offset, timeZone } = fields);\r\n    if (offset === undefined) {\r\n      offsetBehaviour = 'wall';\r\n    }\r\n    const resolvedOptions = GetOptionsObject(options);\r\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\r\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\r\n    const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\r\n  } else {\r\n    let tzAnnotation, z, year, month, day;\r\n    ({ year, month, day, time, tzAnnotation, offset, z, calendar } = ParseTemporalZonedDateTimeString(\r\n      RequireString(item)\r\n    ));\r\n    timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\r\n    if (z) {\r\n      offsetBehaviour = 'exact';\r\n    } else if (!offset) {\r\n      offsetBehaviour = 'wall';\r\n    }\r\n    if (!calendar) calendar = 'iso8601';\r\n    calendar = CanonicalizeCalendar(calendar);\r\n    matchMinute = true; // ISO strings may specify offset with less precision\r\n    const resolvedOptions = GetOptionsObject(options);\r\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\r\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\r\n    GetTemporalOverflowOption(resolvedOptions); // validate and ignore\r\n    isoDate = { year, month, day };\r\n  }\r\n  let offsetNs = 0;\r\n  if (offsetBehaviour === 'option') offsetNs = ParseDateTimeUTCOffset(castExists(offset));\r\n  const epochNanoseconds = InterpretISODateTimeOffset(\r\n    isoDate,\r\n    time,\r\n    offsetBehaviour,\r\n    offsetNs,\r\n    timeZone,\r\n    disambiguation,\r\n    offsetOpt,\r\n    matchMinute\r\n  );\r\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\r\n}\r\n\r\nexport function CreateTemporalDateSlots(result: Temporal.PlainDate, isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  RejectDateRange(isoDate);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE, isoDate);\r\n  SetSlot(result, CALENDAR, calendar);\r\n  SetSlot(result, DATE_BRAND, true);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalDateToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainDate <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalDate(isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\r\n  const result = Object.create(TemporalPlainDate.prototype);\r\n  CreateTemporalDateSlots(result, isoDate, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalDateTimeSlots(\r\n  result: Temporal.PlainDateTime,\r\n  isoDateTime: ISODateTime,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  RejectDateTimeRange(isoDateTime);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE_TIME, isoDateTime);\r\n  SetSlot(result, CALENDAR, calendar);\r\n\r\n  if (DEBUG) {\r\n    let repr = ISODateTimeToString(isoDateTime, calendar, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainDateTime <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalDateTime(isoDateTime: ISODateTime, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\r\n  const result = Object.create(TemporalPlainDateTime.prototype);\r\n  CreateTemporalDateTimeSlots(result, isoDateTime, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalMonthDaySlots(\r\n  result: Temporal.PlainMonthDay,\r\n  isoDate: ISODate,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  RejectDateRange(isoDate);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE, isoDate);\r\n  SetSlot(result, CALENDAR, calendar);\r\n  SetSlot(result, MONTH_DAY_BRAND, true);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalMonthDayToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainMonthDay <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalMonthDay(isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\r\n  const result = Object.create(TemporalPlainMonthDay.prototype);\r\n  CreateTemporalMonthDaySlots(result, isoDate, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalTimeSlots(result: Temporal.PlainTime, time: TimeRecord) {\r\n  CreateSlots(result);\r\n  SetSlot(result, TIME, time);\r\n\r\n  if (DEBUG) {\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainTime <${TimeRecordToString(time, 'auto')}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalTime(time: TimeRecord) {\r\n  const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\r\n  const result = Object.create(TemporalPlainTime.prototype);\r\n  CreateTemporalTimeSlots(result, time);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalYearMonthSlots(\r\n  result: Temporal.PlainYearMonth,\r\n  isoDate: ISODate,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  RejectYearMonthRange(isoDate);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE, isoDate);\r\n  SetSlot(result, CALENDAR, calendar);\r\n  SetSlot(result, YEAR_MONTH_BRAND, true);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalYearMonthToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainYearMonth <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalYearMonth(isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\r\n  const result = Object.create(TemporalPlainYearMonth.prototype);\r\n  CreateTemporalYearMonthSlots(result, isoDate, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalInstantSlots(result: Temporal.Instant, epochNanoseconds: JSBI) {\r\n  ValidateEpochNanoseconds(epochNanoseconds);\r\n  CreateSlots(result);\r\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\r\n\r\n  if (DEBUG) {\r\n    const iso = GetISOPartsFromEpoch(epochNanoseconds);\r\n    const repr = ISODateTimeToString(iso, 'iso8601', 'auto', 'never') + 'Z';\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `${result[Symbol.toStringTag]} <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalInstant(epochNanoseconds: JSBI) {\r\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\r\n  const result: Temporal.Instant = Object.create(TemporalInstant.prototype);\r\n  CreateTemporalInstantSlots(result, epochNanoseconds);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalZonedDateTimeSlots(\r\n  result: Temporal.ZonedDateTime,\r\n  epochNanoseconds: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  ValidateEpochNanoseconds(epochNanoseconds);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\r\n  SetSlot(result, TIME_ZONE, timeZone);\r\n  SetSlot(result, CALENDAR, calendar);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalZonedDateTimeToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.ZonedDateTime <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalZonedDateTime(\r\n  epochNanoseconds: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId = 'iso8601'\r\n) {\r\n  const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\r\n  const result: Temporal.ZonedDateTime = Object.create(TemporalZonedDateTime.prototype);\r\n  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\r\n  return result;\r\n}\r\n\r\nfunction CalendarFieldKeysPresent(fields: Record<FieldKey, unknown>) {\r\n  return CALENDAR_FIELD_KEYS.filter((key) => fields[key] !== undefined);\r\n}\r\n\r\nexport function CalendarMergeFields<Base extends Record<string, unknown>, ToAdd extends Record<string, unknown>>(\r\n  calendar: BuiltinCalendarId,\r\n  fields: Base,\r\n  additionalFields: ToAdd\r\n) {\r\n  const additionalKeys = CalendarFieldKeysPresent(additionalFields);\r\n  const overriddenKeys = calendarImplForID(calendar).fieldKeysToIgnore(additionalKeys);\r\n  const merged = Object.create(null);\r\n  const fieldsKeys = CalendarFieldKeysPresent(fields);\r\n  for (let ix = 0; ix < CALENDAR_FIELD_KEYS.length; ix++) {\r\n    let propValue = undefined;\r\n    const key = CALENDAR_FIELD_KEYS[ix];\r\n    if (fieldsKeys.includes(key) && !overriddenKeys.includes(key)) {\r\n      propValue = fields[key];\r\n    }\r\n    if (additionalKeys.includes(key)) {\r\n      propValue = additionalFields[key];\r\n    }\r\n    if (propValue !== undefined) merged[key] = propValue;\r\n  }\r\n  return merged as Base & ToAdd;\r\n}\r\n\r\nexport function CalendarDateAdd(\r\n  calendar: BuiltinCalendarId,\r\n  isoDate: ISODate,\r\n  dateDuration: Partial<DateDuration>,\r\n  overflow: Overflow\r\n) {\r\n  const result = calendarImplForID(calendar).dateAdd(isoDate, dateDuration, overflow);\r\n  RejectDateRange(result);\r\n  return result;\r\n}\r\n\r\nfunction CalendarDateUntil(\r\n  calendar: BuiltinCalendarId,\r\n  isoDate: ISODate,\r\n  isoOtherDate: ISODate,\r\n  largestUnit: Temporal.DateUnit\r\n) {\r\n  return calendarImplForID(calendar).dateUntil(isoDate, isoOtherDate, largestUnit);\r\n}\r\n\r\nexport function ToTemporalCalendarIdentifier(calendarLike: Temporal.CalendarLike): BuiltinCalendarId {\r\n  if (IsObject(calendarLike)) {\r\n    if (HasSlot(calendarLike, CALENDAR)) return GetSlot(calendarLike, CALENDAR);\r\n  }\r\n  const identifier = RequireString(calendarLike);\r\n  try {\r\n    // Fast path: identifier is a calendar type, no ISO string parsing needed\r\n    return CanonicalizeCalendar(identifier);\r\n  } catch {\r\n    // fall through\r\n  }\r\n  let calendar;\r\n  try {\r\n    ({ calendar } = ParseISODateTime(identifier));\r\n  } catch {\r\n    try {\r\n      ({ calendar } = ParseTemporalTimeString(identifier));\r\n    } catch {\r\n      try {\r\n        ({ calendar } = ParseTemporalYearMonthString(identifier));\r\n      } catch {\r\n        ({ calendar } = ParseTemporalMonthDayString(identifier));\r\n      }\r\n    }\r\n  }\r\n  if (!calendar) calendar = 'iso8601';\r\n  return CanonicalizeCalendar(calendar);\r\n}\r\n\r\nfunction GetTemporalCalendarIdentifierWithISODefault(item: { calendar?: Temporal.CalendarLike }) {\r\n  if (HasSlot(item, CALENDAR)) return GetSlot(item, CALENDAR);\r\n  const { calendar } = item;\r\n  if (calendar === undefined) return 'iso8601';\r\n  return ToTemporalCalendarIdentifier(calendar);\r\n}\r\n\r\nexport function CalendarEquals(one: BuiltinCalendarId, two: BuiltinCalendarId) {\r\n  return CanonicalizeCalendar(one) === CanonicalizeCalendar(two);\r\n}\r\n\r\nexport function CalendarDateFromFields(calendar: BuiltinCalendarId, fields: CalendarFieldsRecord, overflow: Overflow) {\r\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\r\n  calendarImpl.resolveFields(fields, 'date');\r\n  const result = calendarImpl.dateToISO(fields, overflow);\r\n  RejectDateRange(result);\r\n  return result;\r\n}\r\n\r\nexport function CalendarYearMonthFromFields(\r\n  calendar: BuiltinCalendarId,\r\n  fields: CalendarFieldsRecord,\r\n  overflow: Overflow\r\n) {\r\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\r\n  calendarImpl.resolveFields(fields, 'year-month');\r\n  fields.day = 1;\r\n  const result = calendarImpl.dateToISO(fields, overflow);\r\n  RejectYearMonthRange(result);\r\n  return result;\r\n}\r\n\r\nexport function CalendarMonthDayFromFields(\r\n  calendar: BuiltinCalendarId,\r\n  fields: MonthDayFromFieldsObject,\r\n  overflow: Overflow\r\n) {\r\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\r\n  calendarImpl.resolveFields(fields, 'month-day');\r\n  const result = calendarImpl.monthDayToISOReferenceDate(fields, overflow);\r\n  RejectDateRange(result);\r\n  return result;\r\n}\r\n\r\nexport function ToTemporalTimeZoneIdentifier(temporalTimeZoneLike: unknown): string {\r\n  if (IsObject(temporalTimeZoneLike)) {\r\n    if (IsTemporalZonedDateTime(temporalTimeZoneLike)) return GetSlot(temporalTimeZoneLike, TIME_ZONE);\r\n  }\r\n  const timeZoneString = RequireString(temporalTimeZoneLike);\r\n  if (timeZoneString === 'UTC') return 'UTC'; // UTC fast path\r\n\r\n  const { tzName, offsetMinutes } = ParseTemporalTimeZoneString(timeZoneString);\r\n  if (offsetMinutes !== undefined) {\r\n    return FormatOffsetTimeZoneIdentifier(offsetMinutes);\r\n  }\r\n  // if offsetMinutes is undefined, then tzName must be present\r\n  const record = GetAvailableNamedTimeZoneIdentifier(castExists(tzName));\r\n  if (!record) throw new RangeError(`Unrecognized time zone ${tzName}`);\r\n  return record.identifier;\r\n}\r\n\r\nexport function TimeZoneEquals(one: string, two: string) {\r\n  if (one === two) return true;\r\n  const offsetMinutes1 = ParseTimeZoneIdentifier(one).offsetMinutes;\r\n  const offsetMinutes2 = ParseTimeZoneIdentifier(two).offsetMinutes;\r\n  if (offsetMinutes1 === undefined && offsetMinutes2 === undefined) {\r\n    // Calling GetAvailableNamedTimeZoneIdentifier is costly, so (unlike the\r\n    // spec) the polyfill will early-return if one of them isn't recognized. Try\r\n    // the second ID first because it's more likely to be unknown, because it\r\n    // can come from the argument of TimeZone.p.equals as opposed to the first\r\n    // ID which comes from the receiver.\r\n    const idRecord2 = GetAvailableNamedTimeZoneIdentifier(two);\r\n    if (!idRecord2) return false;\r\n    const idRecord1 = GetAvailableNamedTimeZoneIdentifier(one);\r\n    if (!idRecord1) return false;\r\n    return idRecord1.primaryIdentifier === idRecord2.primaryIdentifier;\r\n  } else {\r\n    return offsetMinutes1 === offsetMinutes2;\r\n  }\r\n}\r\n\r\nexport function GetOffsetNanosecondsFor(timeZone: string, epochNs: JSBI) {\r\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes;\r\n  if (offsetMinutes !== undefined) return offsetMinutes * 60e9;\r\n\r\n  return GetNamedTimeZoneOffsetNanoseconds(timeZone, epochNs);\r\n}\r\n\r\nexport function FormatUTCOffsetNanoseconds(offsetNs: number): string {\r\n  const sign = offsetNs < 0 ? '-' : '+';\r\n  const absoluteNs = Math.abs(offsetNs);\r\n  const hour = Math.floor(absoluteNs / 3600e9);\r\n  const minute = Math.floor(absoluteNs / 60e9) % 60;\r\n  const second = Math.floor(absoluteNs / 1e9) % 60;\r\n  const subSecondNs = absoluteNs % 1e9;\r\n  const precision = second === 0 && subSecondNs === 0 ? 'minute' : 'auto';\r\n  const timeString = FormatTimeString(hour, minute, second, subSecondNs, precision);\r\n  return `${sign}${timeString}`;\r\n}\r\n\r\nexport function GetISODateTimeFor(timeZone: string, epochNs: JSBI) {\r\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, epochNs);\r\n  let {\r\n    isoDate: { year, month, day },\r\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\r\n  } = GetISOPartsFromEpoch(epochNs);\r\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs);\r\n}\r\n\r\nexport function GetEpochNanosecondsFor(\r\n  timeZone: string,\r\n  isoDateTime: ISODateTime,\r\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\r\n) {\r\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\r\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, isoDateTime, disambiguation);\r\n}\r\n\r\n// TODO: See if this logic can be removed in favour of GetNamedTimeZoneEpochNanoseconds\r\nfunction DisambiguatePossibleEpochNanoseconds(\r\n  possibleEpochNs: JSBI[],\r\n  timeZone: string,\r\n  isoDateTime: ISODateTime,\r\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\r\n) {\r\n  const numInstants = possibleEpochNs.length;\r\n\r\n  if (numInstants === 1) return possibleEpochNs[0];\r\n  if (numInstants) {\r\n    switch (disambiguation) {\r\n      case 'compatible':\r\n      // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\r\n      case 'earlier':\r\n        return possibleEpochNs[0];\r\n      case 'later':\r\n        return possibleEpochNs[numInstants - 1];\r\n      case 'reject': {\r\n        throw new RangeError('multiple instants found');\r\n      }\r\n    }\r\n  }\r\n\r\n  if (disambiguation === 'reject') throw new RangeError('multiple instants found');\r\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\r\n\r\n  const dayBefore = JSBI.subtract(utcns, DAY_NANOS_JSBI);\r\n  ValidateEpochNanoseconds(dayBefore);\r\n  const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\r\n  const dayAfter = JSBI.add(utcns, DAY_NANOS_JSBI);\r\n  ValidateEpochNanoseconds(dayAfter);\r\n  const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\r\n  const nanoseconds = offsetAfter - offsetBefore;\r\n  assert(Math.abs(nanoseconds) <= DAY_NANOS, 'UTC offset shift longer than 24 hours');\r\n\r\n  switch (disambiguation) {\r\n    case 'earlier': {\r\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, -nanoseconds);\r\n      const earlierTime = AddTime(isoDateTime.time, timeDuration);\r\n      const earlierDate = BalanceISODate(\r\n        isoDateTime.isoDate.year,\r\n        isoDateTime.isoDate.month,\r\n        isoDateTime.isoDate.day + earlierTime.deltaDays\r\n      );\r\n      const earlier = CombineISODateAndTimeRecord(earlierDate, earlierTime);\r\n      return GetPossibleEpochNanoseconds(timeZone, earlier)[0];\r\n    }\r\n    case 'compatible':\r\n    // fall through because 'compatible' means 'later' for \"spring forward\" transitions\r\n    case 'later': {\r\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, nanoseconds);\r\n      const laterTime = AddTime(isoDateTime.time, timeDuration);\r\n      const laterDate = BalanceISODate(\r\n        isoDateTime.isoDate.year,\r\n        isoDateTime.isoDate.month,\r\n        isoDateTime.isoDate.day + laterTime.deltaDays\r\n      );\r\n      const later = CombineISODateAndTimeRecord(laterDate, laterTime);\r\n      const possible = GetPossibleEpochNanoseconds(timeZone, later);\r\n      return possible[possible.length - 1];\r\n    }\r\n  }\r\n}\r\n\r\nfunction GetPossibleEpochNanoseconds(timeZone: string, isoDateTime: ISODateTime) {\r\n  // UTC fast path\r\n  if (timeZone === 'UTC') {\r\n    CheckISODaysRange(isoDateTime.isoDate);\r\n    return [GetUTCEpochNanoseconds(isoDateTime)];\r\n  }\r\n\r\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes;\r\n  if (offsetMinutes !== undefined) {\r\n    const balanced = BalanceISODateTime(\r\n      isoDateTime.isoDate.year,\r\n      isoDateTime.isoDate.month,\r\n      isoDateTime.isoDate.day,\r\n      isoDateTime.time.hour,\r\n      isoDateTime.time.minute - offsetMinutes,\r\n      isoDateTime.time.second,\r\n      isoDateTime.time.millisecond,\r\n      isoDateTime.time.microsecond,\r\n      isoDateTime.time.nanosecond\r\n    );\r\n    CheckISODaysRange(balanced.isoDate);\r\n    const epochNs = GetUTCEpochNanoseconds(balanced);\r\n    ValidateEpochNanoseconds(epochNs);\r\n    return [epochNs];\r\n  }\r\n\r\n  CheckISODaysRange(isoDateTime.isoDate);\r\n  return GetNamedTimeZoneEpochNanoseconds(timeZone, isoDateTime);\r\n}\r\n\r\nexport function GetStartOfDay(timeZone: string, isoDate: ISODate) {\r\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\r\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\r\n  // If not a DST gap, return the single or earlier epochNs\r\n  if (possibleEpochNs.length) return possibleEpochNs[0];\r\n\r\n  // Otherwise, 00:00:00 lies within a DST gap. Compute an epochNs that's\r\n  // guaranteed to be before the transition\r\n  assert(!IsOffsetTimeZoneIdentifier(timeZone), 'should only be reached with named time zone');\r\n\r\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\r\n  const dayBefore = JSBI.subtract(utcns, DAY_NANOS_JSBI);\r\n  ValidateEpochNanoseconds(dayBefore);\r\n  return castExists(GetNamedTimeZoneNextTransition(timeZone, dayBefore));\r\n}\r\n\r\nexport function ISOYearString(year: number) {\r\n  let yearString;\r\n  if (year < 0 || year > 9999) {\r\n    const sign = year < 0 ? '-' : '+';\r\n    const yearNumber = Math.abs(year);\r\n    yearString = sign + ToZeroPaddedDecimalString(yearNumber, 6);\r\n  } else {\r\n    yearString = ToZeroPaddedDecimalString(year, 4);\r\n  }\r\n  return yearString;\r\n}\r\n\r\nexport function ISODateTimePartString(part: number) {\r\n  return ToZeroPaddedDecimalString(part, 2);\r\n}\r\n\r\nfunction FormatFractionalSeconds(\r\n  subSecondNanoseconds: number,\r\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\r\n): string {\r\n  let fraction;\r\n  if (precision === 'auto') {\r\n    if (subSecondNanoseconds === 0) return '';\r\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\r\n    // now remove any trailing zeroes\r\n    fraction = fractionFullPrecision.replace(/0+$/, '');\r\n  } else {\r\n    if (precision === 0) return '';\r\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\r\n    fraction = fractionFullPrecision.slice(0, precision);\r\n  }\r\n  return `.${fraction}`;\r\n}\r\n\r\nfunction FormatTimeString(\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  subSecondNanoseconds: number,\r\n  precision: SecondsStringPrecisionRecord['precision']\r\n): string {\r\n  let result = `${ISODateTimePartString(hour)}:${ISODateTimePartString(minute)}`;\r\n  if (precision === 'minute') return result;\r\n\r\n  result += `:${ISODateTimePartString(second)}`;\r\n  result += FormatFractionalSeconds(subSecondNanoseconds, precision);\r\n  return result;\r\n}\r\n\r\nexport function TemporalInstantToString(\r\n  instant: Temporal.Instant,\r\n  timeZone: string | undefined,\r\n  precision: SecondsStringPrecisionRecord['precision']\r\n) {\r\n  let outputTimeZone = timeZone;\r\n  if (outputTimeZone === undefined) outputTimeZone = 'UTC';\r\n  const epochNs = GetSlot(instant, EPOCHNANOSECONDS);\r\n  const iso = GetISODateTimeFor(outputTimeZone, epochNs);\r\n  const dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\r\n  let timeZoneString = 'Z';\r\n  if (timeZone !== undefined) {\r\n    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, epochNs);\r\n    timeZoneString = FormatDateTimeUTCOffsetRounded(offsetNs);\r\n  }\r\n  return `${dateTimeString}${timeZoneString}`;\r\n}\r\n\r\ninterface ToStringOptions {\r\n  unit: SecondsStringPrecisionRecord['unit'];\r\n  increment: number;\r\n  roundingMode: ReturnType<typeof GetRoundingModeOption>;\r\n}\r\n\r\nexport function TemporalDurationToString(\r\n  duration: Temporal.Duration,\r\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\r\n) {\r\n  const years = GetSlot(duration, YEARS);\r\n  const months = GetSlot(duration, MONTHS);\r\n  const weeks = GetSlot(duration, WEEKS);\r\n  const days = GetSlot(duration, DAYS);\r\n  const hours = GetSlot(duration, HOURS);\r\n  const minutes = GetSlot(duration, MINUTES);\r\n  const sign = DurationSign(duration);\r\n\r\n  let datePart = '';\r\n  if (years !== 0) datePart += `${Math.abs(years)}Y`;\r\n  if (months !== 0) datePart += `${Math.abs(months)}M`;\r\n  if (weeks !== 0) datePart += `${Math.abs(weeks)}W`;\r\n  if (days !== 0) datePart += `${Math.abs(days)}D`;\r\n\r\n  let timePart = '';\r\n  if (hours !== 0) timePart += `${Math.abs(hours)}H`;\r\n  if (minutes !== 0) timePart += `${Math.abs(minutes)}M`;\r\n\r\n  // Keeping sub-second units separate avoids losing precision after resolving\r\n  // any overflows from rounding\r\n  const secondsDuration = TimeDuration.fromComponents(\r\n    0,\r\n    0,\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  );\r\n  if (\r\n    !secondsDuration.isZero() ||\r\n    ['second', 'millisecond', 'microsecond', 'nanosecond'].includes(DefaultTemporalLargestUnit(duration)) ||\r\n    precision !== 'auto'\r\n  ) {\r\n    const secondsPart = Math.abs(secondsDuration.sec);\r\n    const subSecondsPart = FormatFractionalSeconds(Math.abs(secondsDuration.subsec), precision);\r\n    timePart += `${secondsPart}${subSecondsPart}S`;\r\n  }\r\n  let result = `${sign < 0 ? '-' : ''}P${datePart}`;\r\n  if (timePart) result = `${result}T${timePart}`;\r\n  return result;\r\n}\r\n\r\nexport function TemporalDateToString(\r\n  date: Temporal.PlainDate,\r\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\r\n) {\r\n  const { year, month, day } = GetSlot(date, ISO_DATE);\r\n  const yearString = ISOYearString(year);\r\n  const monthString = ISODateTimePartString(month);\r\n  const dayString = ISODateTimePartString(day);\r\n  const calendar = FormatCalendarAnnotation(GetSlot(date, CALENDAR), showCalendar);\r\n  return `${yearString}-${monthString}-${dayString}${calendar}`;\r\n}\r\n\r\nexport function TimeRecordToString(\r\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\r\n  precision: SecondsStringPrecisionRecord['precision']\r\n) {\r\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\r\n  return FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\r\n}\r\n\r\nexport function ISODateTimeToString(\r\n  isoDateTime: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  precision: SecondsStringPrecisionRecord['precision'],\r\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto'\r\n) {\r\n  const {\r\n    isoDate: { year, month, day },\r\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\r\n  } = isoDateTime;\r\n  const yearString = ISOYearString(year);\r\n  const monthString = ISODateTimePartString(month);\r\n  const dayString = ISODateTimePartString(day);\r\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\r\n  const timeString = FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\r\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\r\n  return `${yearString}-${monthString}-${dayString}T${timeString}${calendarString}`;\r\n}\r\n\r\nexport function TemporalMonthDayToString(\r\n  monthDay: Temporal.PlainMonthDay,\r\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\r\n) {\r\n  const { year, month, day } = GetSlot(monthDay, ISO_DATE);\r\n  const monthString = ISODateTimePartString(month);\r\n  const dayString = ISODateTimePartString(day);\r\n  let resultString = `${monthString}-${dayString}`;\r\n  const calendar = GetSlot(monthDay, CALENDAR);\r\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\r\n    const yearString = ISOYearString(year);\r\n    resultString = `${yearString}-${resultString}`;\r\n  }\r\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\r\n  if (calendarString) resultString += calendarString;\r\n  return resultString;\r\n}\r\n\r\nexport function TemporalYearMonthToString(\r\n  yearMonth: Temporal.PlainYearMonth,\r\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\r\n) {\r\n  const { year, month, day } = GetSlot(yearMonth, ISO_DATE);\r\n  const yearString = ISOYearString(year);\r\n  const monthString = ISODateTimePartString(month);\r\n  let resultString = `${yearString}-${monthString}`;\r\n  const calendar = GetSlot(yearMonth, CALENDAR);\r\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\r\n    const dayString = ISODateTimePartString(day);\r\n    resultString += `-${dayString}`;\r\n  }\r\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\r\n  if (calendarString) resultString += calendarString;\r\n  return resultString;\r\n}\r\n\r\nexport function TemporalZonedDateTimeToString(\r\n  zdt: Temporal.ZonedDateTime,\r\n  precision: SecondsStringPrecisionRecord['precision'],\r\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto',\r\n  showTimeZone: ReturnType<typeof GetTemporalShowTimeZoneNameOption> = 'auto',\r\n  showOffset: ReturnType<typeof GetTemporalShowOffsetOption> = 'auto',\r\n  options: ToStringOptions | undefined = undefined\r\n) {\r\n  let epochNs = GetSlot(zdt, EPOCHNANOSECONDS);\r\n\r\n  if (options) {\r\n    const { unit, increment, roundingMode } = options;\r\n    epochNs = RoundTemporalInstant(epochNs, increment, unit, roundingMode);\r\n  }\r\n\r\n  const tz = GetSlot(zdt, TIME_ZONE);\r\n  const offsetNs = GetOffsetNanosecondsFor(tz, epochNs);\r\n  const iso = GetISODateTimeFor(tz, epochNs);\r\n  let dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\r\n  if (showOffset !== 'never') {\r\n    dateTimeString += FormatDateTimeUTCOffsetRounded(offsetNs);\r\n  }\r\n  if (showTimeZone !== 'never') {\r\n    const flag = showTimeZone === 'critical' ? '!' : '';\r\n    dateTimeString += `[${flag}${tz}]`;\r\n  }\r\n  dateTimeString += FormatCalendarAnnotation(GetSlot(zdt, CALENDAR), showCalendar);\r\n  return dateTimeString;\r\n}\r\n\r\nexport function IsOffsetTimeZoneIdentifier(string: string) {\r\n  return OFFSET_IDENTIFIER.test(string);\r\n}\r\n\r\nexport function ParseDateTimeUTCOffset(string: string): number {\r\n  const match = OFFSET_WITH_PARTS.exec(string);\r\n  if (!match) {\r\n    throw new RangeError(`invalid time zone offset: ${string}; must match ±HH:MM[:SS.SSSSSSSSS]`);\r\n  }\r\n  const sign = match[1] === '-' ? -1 : +1;\r\n  const hours = +match[2];\r\n  const minutes = +(match[3] || 0);\r\n  const seconds = +(match[4] || 0);\r\n  const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\r\n  const offsetNanoseconds = sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\r\n  return offsetNanoseconds;\r\n}\r\n\r\nlet canonicalTimeZoneIdsCache: Map<string, string> | undefined | null = undefined;\r\nconst isTZIDSep = Object.assign(Object.create(null), { '/': true, '-': true, _: true });\r\n\r\nexport function GetAvailableNamedTimeZoneIdentifier(\r\n  identifier: string\r\n): { identifier: string; primaryIdentifier: string } | undefined {\r\n  // The most common case is when the identifier is a canonical time zone ID.\r\n  // Fast-path that case by caching all canonical IDs. For old ECMAScript\r\n  // implementations lacking this API, set the cache to `null` to avoid retries.\r\n  if (canonicalTimeZoneIdsCache === undefined) {\r\n    const canonicalTimeZoneIds = Intl.supportedValuesOf?.('timeZone');\r\n    if (canonicalTimeZoneIds) {\r\n      canonicalTimeZoneIdsCache = new Map();\r\n      for (let ix = 0; ix < canonicalTimeZoneIds.length; ix++) {\r\n        const id = canonicalTimeZoneIds[ix];\r\n        canonicalTimeZoneIdsCache.set(ASCIILowercase(id), id);\r\n      }\r\n    } else {\r\n      canonicalTimeZoneIdsCache = null;\r\n    }\r\n  }\r\n\r\n  const lower = ASCIILowercase(identifier);\r\n  let primaryIdentifier = canonicalTimeZoneIdsCache?.get(lower);\r\n  if (primaryIdentifier) return { identifier: primaryIdentifier, primaryIdentifier };\r\n\r\n  // It's not already a primary identifier, so get its primary identifier (or\r\n  // return if it's not an available named time zone ID).\r\n  try {\r\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(identifier);\r\n    primaryIdentifier = formatter.resolvedOptions().timeZone;\r\n  } catch {\r\n    return undefined;\r\n  }\r\n\r\n  // Special case this legacy identifier that is listed both in `backzone` and\r\n  // `backward` in the TZDB. Work around implementations that incorrectly use\r\n  // the `backward` data.\r\n  if (lower === 'antarctica/south_pole') primaryIdentifier = 'Antarctica/McMurdo';\r\n\r\n  // Some legacy identifiers are aliases in ICU but not legal IANA identifiers.\r\n  // Reject them even if the implementation's Intl supports them, as they are\r\n  // not present in the IANA time zone database.\r\n  if (ICU_LEGACY_TIME_ZONE_IDS.has(identifier)) {\r\n    throw new RangeError(`${identifier} is a legacy time zone identifier from ICU. Use ${primaryIdentifier} instead`);\r\n  }\r\n\r\n  // The identifier is an alias (a deprecated identifier that's a synonym for a\r\n  // primary identifier), so we need to case-normalize the identifier to match\r\n  // the IANA TZDB, e.g. america/new_york => America/New_York. There's no\r\n  // built-in way to do this using Intl.DateTimeFormat, but the we can normalize\r\n  // almost all aliases (modulo a few special cases) using the TZDB's basic\r\n  // capitalization pattern:\r\n  // 1. capitalize the first letter of the identifier\r\n  // 2. capitalize the letter after every slash, dash, or underscore delimiter\r\n  const chars = [...lower].map((c, i) => (i === 0 || isTZIDSep[lower[i - 1]] ? c.toUpperCase() : c));\r\n  const standardCase = chars.join('');\r\n  const segments = standardCase.split('/');\r\n\r\n  if (segments.length === 1) {\r\n    // If a single-segment legacy ID is 2-3 chars or contains a number or dash, then\r\n    // (except for the \"GB-Eire\" special case) the case-normalized form is uppercase.\r\n    // These are: GMT+0, GMT-0, GB, NZ, PRC, ROC, ROK, UCT, GMT, GMT0, CET, CST6CDT,\r\n    // EET, EST, HST, MET, MST, MST7MDT, PST8PDT, WET, NZ-CHAT, and W-SU.\r\n    // Otherwise it's standard form: first letter capitalized, e.g. Iran, Egypt, Hongkong\r\n    if (lower === 'gb-eire') return { identifier: 'GB-Eire', primaryIdentifier };\r\n    return {\r\n      identifier: lower.length <= 3 || /[-0-9]/.test(lower) ? lower.toUpperCase() : segments[0],\r\n      primaryIdentifier\r\n    };\r\n  }\r\n\r\n  // All Etc zone names are uppercase except three exceptions.\r\n  if (segments[0] === 'Etc') {\r\n    const etcName = ['Zulu', 'Greenwich', 'Universal'].includes(segments[1]) ? segments[1] : segments[1].toUpperCase();\r\n    return { identifier: `Etc/${etcName}`, primaryIdentifier };\r\n  }\r\n\r\n  // Legacy US identifiers like US/Alaska or US/Indiana-Starke are 2 segments and use standard form.\r\n  if (segments[0] === 'Us') return { identifier: `US/${segments[1]}`, primaryIdentifier };\r\n\r\n  // For multi-segment IDs, there's a few special cases in the second/third segments\r\n  const specialCases = new Map([\r\n    ['Act', 'ACT'],\r\n    ['Lhi', 'LHI'],\r\n    ['Nsw', 'NSW'],\r\n    ['Dar_Es_Salaam', 'Dar_es_Salaam'],\r\n    ['Port_Of_Spain', 'Port_of_Spain'],\r\n    ['Port-Au-Prince', 'Port-au-Prince'],\r\n    ['Isle_Of_Man', 'Isle_of_Man'],\r\n    ['Comodrivadavia', 'ComodRivadavia'],\r\n    ['Knox_In', 'Knox_IN'],\r\n    ['Dumontdurville', 'DumontDUrville'],\r\n    ['Mcmurdo', 'McMurdo'],\r\n    ['Denoronha', 'DeNoronha'],\r\n    ['Easterisland', 'EasterIsland'],\r\n    ['Bajanorte', 'BajaNorte'],\r\n    ['Bajasur', 'BajaSur']\r\n  ]);\r\n  segments[1] = specialCases.get(segments[1]) ?? segments[1];\r\n  if (segments.length > 2) segments[2] = specialCases.get(segments[2]) ?? segments[2];\r\n  return { identifier: segments.join('/'), primaryIdentifier };\r\n}\r\n\r\nfunction GetNamedTimeZoneOffsetNanosecondsImpl(id: string, epochMilliseconds: number) {\r\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\r\n  let millisecond = epochMilliseconds % 1000;\r\n  if (millisecond < 0) millisecond += 1000;\r\n  const utc = GetUTCEpochMilliseconds({ isoDate: { year, month, day }, time: { hour, minute, second, millisecond } });\r\n  return (utc - epochMilliseconds) * 1e6;\r\n}\r\n\r\nfunction GetNamedTimeZoneOffsetNanoseconds(id: string, epochNanoseconds: JSBI) {\r\n  // Optimization: We get the offset nanoseconds only with millisecond\r\n  // resolution, assuming that time zone offset changes don't happen in the\r\n  // middle of a millisecond\r\n  return GetNamedTimeZoneOffsetNanosecondsImpl(id, epochNsToMs(epochNanoseconds, 'floor'));\r\n}\r\n\r\nexport function FormatOffsetTimeZoneIdentifier(offsetMinutes: number): string {\r\n  const sign = offsetMinutes < 0 ? '-' : '+';\r\n  const absoluteMinutes = Math.abs(offsetMinutes);\r\n  const hour = Math.floor(absoluteMinutes / 60);\r\n  const minute = absoluteMinutes % 60;\r\n  const timeString = FormatTimeString(hour, minute, 0, 0, 'minute');\r\n  return `${sign}${timeString}`;\r\n}\r\n\r\nfunction FormatDateTimeUTCOffsetRounded(offsetNanosecondsParam: number): string {\r\n  const offsetNanoseconds = RoundNumberToIncrement(offsetNanosecondsParam, MINUTE_NANOS, 'halfExpand');\r\n  return FormatOffsetTimeZoneIdentifier(offsetNanoseconds / 60e9);\r\n}\r\n\r\nfunction GetUTCEpochMilliseconds({\r\n  isoDate: { year, month, day },\r\n  time: { hour, minute, second, millisecond }\r\n}: {\r\n  isoDate: ISODate;\r\n  time: Omit<TimeRecord, 'microsecond' | 'nanosecond'>;\r\n}) {\r\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\r\n  // years. To avoid overflowing at the edges of the range, we reduce the year\r\n  // to the remainder after dividing by 400, and then add back all the\r\n  // nanoseconds from the multiples of 400 years at the end.\r\n  const reducedYear = year % 400;\r\n  const yearCycles = (year - reducedYear) / 400;\r\n\r\n  // Note: Date.UTC() interprets one and two-digit years as being in the\r\n  // 20th century, so don't use it\r\n  const legacyDate = new Date();\r\n  legacyDate.setUTCHours(hour, minute, second, millisecond);\r\n  legacyDate.setUTCFullYear(reducedYear, month - 1, day);\r\n  const ms = legacyDate.getTime();\r\n  return ms + MS_IN_400_YEAR_CYCLE * yearCycles;\r\n}\r\n\r\nfunction GetUTCEpochNanoseconds(isoDateTime: ISODateTime) {\r\n  const ms = GetUTCEpochMilliseconds(isoDateTime);\r\n  const subMs = isoDateTime.time.microsecond * 1e3 + isoDateTime.time.nanosecond;\r\n  return JSBI.add(epochMsToNs(ms), JSBI.BigInt(subMs));\r\n}\r\n\r\nfunction GetISOPartsFromEpoch(epochNanoseconds: JSBI) {\r\n  let epochMilliseconds = epochNsToMs(epochNanoseconds, 'trunc');\r\n  let nanos = JSBI.toNumber(JSBI.remainder(epochNanoseconds, MILLION));\r\n  if (nanos < 0) {\r\n    nanos += 1e6;\r\n    epochMilliseconds -= 1;\r\n  }\r\n  const microsecond = Math.floor(nanos / 1e3) % 1e3;\r\n  const nanosecond = nanos % 1e3;\r\n\r\n  const item = new Date(epochMilliseconds);\r\n  const year = item.getUTCFullYear();\r\n  const month = item.getUTCMonth() + 1;\r\n  const day = item.getUTCDate();\r\n  const hour = item.getUTCHours();\r\n  const minute = item.getUTCMinutes();\r\n  const second = item.getUTCSeconds();\r\n  const millisecond = item.getUTCMilliseconds();\r\n\r\n  return {\r\n    epochMilliseconds,\r\n    isoDate: { year, month, day },\r\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\r\n  };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function GetNamedTimeZoneDateTimeParts(id: string, epochNanoseconds: JSBI) {\r\n  const {\r\n    epochMilliseconds,\r\n    time: { millisecond, microsecond, nanosecond }\r\n  } = GetISOPartsFromEpoch(epochNanoseconds);\r\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\r\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\r\n}\r\n\r\n// Most time zones never transition twice within a short span of days. We still\r\n// accommodate twitchy zones, albeit at a performance penalty. 19 days is the\r\n// default window, past which we'd need to start adding many more special cases.\r\nfunction searchWindowForTransitions(id: string) {\r\n  if (id === 'Africa/El_Aaiun') return DAY_MS * 17;\r\n  if (id === 'America/Argentina/Tucuman') return DAY_MS * 12;\r\n  if (id === 'Europe/Tirane') return DAY_MS * 11;\r\n  if (id === 'Europe/Riga') return DAY_MS * 10;\r\n  if (id === 'Europe/Simferopol' || id === 'Europe/Vienna') return DAY_MS * 9;\r\n  if (id === 'Africa/Tunis') return DAY_MS * 8;\r\n  if (\r\n    id === 'America/Boa_Vista' ||\r\n    id === 'America/Fortaleza' ||\r\n    id === 'America/Maceio' ||\r\n    id === 'America/Noronha' ||\r\n    id === 'America/Recife' ||\r\n    id === 'Asia/Gaza' || // dubious, only in future calculations\r\n    id === 'Asia/Hebron' || // ditto\r\n    id === 'Brazil/DeNoronha'\r\n  ) {\r\n    return DAY_MS * 6;\r\n  }\r\n  return DAY_MS * 19;\r\n}\r\n\r\nexport function GetNamedTimeZoneNextTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\r\n  if (id === 'UTC') return null; // UTC fast path\r\n\r\n  // Optimization: we floor the instant to the previous millisecond boundary\r\n  // so that we can do Number math instead of BigInt math. This assumes that\r\n  // time zone transitions don't happen in the middle of a millisecond.\r\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'floor');\r\n  if (epochMilliseconds < BEFORE_FIRST_DST) {\r\n    return GetNamedTimeZoneNextTransition(id, epochMsToNs(BEFORE_FIRST_DST));\r\n  }\r\n\r\n  // Optimization: the farthest that we'll look for a next transition is 3 years\r\n  // after the later of epochNanoseconds or the current time. If there are no\r\n  // transitions found before then, we'll assume that there will not be any more\r\n  // transitions after that.\r\n  const now = Date.now();\r\n  const base = Math.max(epochMilliseconds, now);\r\n  const uppercap = base + DAY_MS * 366 * 3;\r\n  let leftMs = epochMilliseconds;\r\n  let leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\r\n  let rightMs = leftMs;\r\n  let rightOffsetNs = leftOffsetNs;\r\n  const searchWindow = searchWindowForTransitions(id);\r\n  while (leftOffsetNs === rightOffsetNs && leftMs < uppercap) {\r\n    rightMs = leftMs + searchWindow;\r\n    if (rightMs > MS_MAX) return null;\r\n    rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\r\n    if (leftOffsetNs === rightOffsetNs) {\r\n      leftMs = rightMs;\r\n    }\r\n  }\r\n  if (leftOffsetNs === rightOffsetNs) return null;\r\n  const result = bisect(\r\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\r\n    leftMs,\r\n    rightMs,\r\n    leftOffsetNs,\r\n    rightOffsetNs\r\n  );\r\n  return epochMsToNs(result);\r\n}\r\n\r\nexport function GetNamedTimeZonePreviousTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\r\n  if (id === 'UTC') return null; // UTC fast path\r\n\r\n  // Optimization: we raise the instant to the next millisecond boundary so\r\n  // that we can do Number math instead of BigInt math. This assumes that time\r\n  // zone transitions don't happen in the middle of a millisecond.\r\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'ceil');\r\n\r\n  // Optimization: if the instant is more than 3 years in the future and there\r\n  // are no transitions between the present day and 3 years from now, assume\r\n  // there are none after.\r\n  const now = Date.now();\r\n  const lookahead = now + DAY_MS * 366 * 3;\r\n  if (epochMilliseconds > lookahead) {\r\n    const prevBeforeLookahead = GetNamedTimeZonePreviousTransition(id, epochMsToNs(lookahead));\r\n    if (prevBeforeLookahead === null || JSBI.lessThan(prevBeforeLookahead, epochMsToNs(now))) {\r\n      return prevBeforeLookahead;\r\n    }\r\n  }\r\n\r\n  // We assume most time zones either have regular DST rules that extend\r\n  // indefinitely into the future, or they have no DST transitions between now\r\n  // and next year. Africa/Casablanca and Africa/El_Aaiun are unique cases\r\n  // that fit neither of these. Their irregular DST transitions are\r\n  // precomputed until 2087 in the current time zone database, so requesting\r\n  // the previous transition for an instant far in the future may take an\r\n  // extremely long time as it loops backward 2 weeks at a time.\r\n  if (id === 'Africa/Casablanca' || id === 'Africa/El_Aaiun') {\r\n    const lastPrecomputed = Date.UTC(2088, 0, 1); // 2088-01-01T00Z\r\n    if (lastPrecomputed < epochMilliseconds) {\r\n      return GetNamedTimeZonePreviousTransition(id, epochMsToNs(lastPrecomputed));\r\n    }\r\n  }\r\n\r\n  let rightMs = epochMilliseconds - 1;\r\n  if (rightMs < BEFORE_FIRST_DST) return null;\r\n  let rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\r\n  let leftMs = rightMs;\r\n  let leftOffsetNs = rightOffsetNs;\r\n  const searchWindow = searchWindowForTransitions(id);\r\n  while (rightOffsetNs === leftOffsetNs && rightMs > BEFORE_FIRST_DST) {\r\n    leftMs = rightMs - searchWindow;\r\n    if (leftMs < BEFORE_FIRST_DST) return null;\r\n    leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\r\n    if (rightOffsetNs === leftOffsetNs) {\r\n      rightMs = leftMs;\r\n    }\r\n  }\r\n  if (rightOffsetNs === leftOffsetNs) return null;\r\n  const result = bisect(\r\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\r\n    leftMs,\r\n    rightMs,\r\n    leftOffsetNs,\r\n    rightOffsetNs\r\n  );\r\n  return epochMsToNs(result);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function parseFromEnUsFormat(datetime: string) {\r\n  const splits = datetime.split(/[^\\w]+/);\r\n\r\n  if (splits.length !== 7) {\r\n    throw new RangeError(`expected 7 parts in \"${datetime}`);\r\n  }\r\n\r\n  const month = +splits[0];\r\n  const day = +splits[1];\r\n  let year = +splits[2];\r\n  const era = splits[3];\r\n  if (era[0] === 'b' || era[0] === 'B') {\r\n    year = -year + 1;\r\n  } else if (era[0] !== 'a' && era[0] !== 'A') {\r\n    throw new RangeError(`Unknown era ${era} in \"${datetime}`);\r\n  }\r\n  const hour = splits[4] === '24' ? 0 : +splits[4]; // bugs.chromium.org/p/chromium/issues/detail?id=1045791\r\n  const minute = +splits[5];\r\n  const second = +splits[6];\r\n\r\n  if (\r\n    !Number.isFinite(year) ||\r\n    !Number.isFinite(month) ||\r\n    !Number.isFinite(day) ||\r\n    !Number.isFinite(hour) ||\r\n    !Number.isFinite(minute) ||\r\n    !Number.isFinite(second)\r\n  ) {\r\n    throw new RangeError(`Invalid number in \"${datetime}`);\r\n  }\r\n\r\n  return { year, month, day, hour, minute, second };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function GetFormatterParts(timeZone: string, epochMilliseconds: number) {\r\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\r\n  // Using `format` instead of `formatToParts` for compatibility with older\r\n  // clients and because it is twice as fast\r\n  const datetime = formatter.format(epochMilliseconds);\r\n  return parseFromEnUsFormat(datetime);\r\n}\r\n\r\n// The goal of this function is to find the exact time(s) that correspond to a\r\n// calendar date and clock time in a particular time zone. Normally there will\r\n// be only one match. But for repeated clock times after backwards transitions\r\n// (like when DST ends) there may be two matches. And for skipped clock times\r\n// after forward transitions, there will be no matches.\r\nfunction GetNamedTimeZoneEpochNanoseconds(id: string, isoDateTime: ISODateTime) {\r\n  // Get the offset of one day before and after the requested calendar date and\r\n  // clock time, avoiding overflows if near the edge of the Instant range.\r\n  let ns = GetUTCEpochNanoseconds(isoDateTime);\r\n  let nsEarlier = JSBI.subtract(ns, DAY_NANOS_JSBI);\r\n  if (JSBI.lessThan(nsEarlier, NS_MIN)) nsEarlier = ns;\r\n  let nsLater = JSBI.add(ns, DAY_NANOS_JSBI);\r\n  if (JSBI.greaterThan(nsLater, NS_MAX)) nsLater = ns;\r\n  const earlierOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsEarlier);\r\n  const laterOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsLater);\r\n\r\n  // If before and after offsets are the same, then we assume there was no\r\n  // offset transition in between, and therefore only one exact time can\r\n  // correspond to the provided calendar date and clock time. But if they're\r\n  // different, then there was an offset transition in between, so test both\r\n  // offsets to see which one(s) will yield a matching exact time.\r\n  const found = earlierOffsetNs === laterOffsetNs ? [earlierOffsetNs] : [earlierOffsetNs, laterOffsetNs];\r\n  const candidates = found.map((offsetNanoseconds) => {\r\n    const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\r\n    const parts = GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\r\n    if (CompareISODateTime(isoDateTime, parts) !== 0) return undefined;\r\n    ValidateEpochNanoseconds(epochNanoseconds);\r\n    return epochNanoseconds;\r\n  });\r\n  return candidates.filter((x) => x !== undefined) as JSBI[];\r\n}\r\n\r\nexport function LeapYear(year: number) {\r\n  if (undefined === year) return false;\r\n  const isDiv4 = year % 4 === 0;\r\n  const isDiv100 = year % 100 === 0;\r\n  const isDiv400 = year % 400 === 0;\r\n  return isDiv4 && (!isDiv100 || isDiv400);\r\n}\r\n\r\nexport function ISODaysInMonth(year: number, month: number) {\r\n  const DoM = {\r\n    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\r\n    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\r\n  };\r\n  return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\r\n}\r\n\r\nexport function DurationSign(duration: Temporal.Duration) {\r\n  const fields = [\r\n    GetSlot(duration, YEARS),\r\n    GetSlot(duration, MONTHS),\r\n    GetSlot(duration, WEEKS),\r\n    GetSlot(duration, DAYS),\r\n    GetSlot(duration, HOURS),\r\n    GetSlot(duration, MINUTES),\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  ];\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const prop = fields[index];\r\n    if (prop !== 0) return prop < 0 ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction DateDurationSign(dateDuration: DateDuration) {\r\n  const fieldNames = ['years', 'months', 'weeks', 'days'] as const;\r\n  for (let index = 0; index < fieldNames.length; index++) {\r\n    const prop = dateDuration[fieldNames[index]];\r\n    if (prop !== 0) return prop < 0 ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction InternalDurationSign(duration: InternalDuration) {\r\n  const dateSign = DateDurationSign(duration.date);\r\n  if (dateSign !== 0) return dateSign;\r\n  return duration.time.sign();\r\n}\r\n\r\nexport function BalanceISOYearMonth(yearParam: number, monthParam: number) {\r\n  let year = yearParam;\r\n  let month = monthParam;\r\n  if (!Number.isFinite(year) || !Number.isFinite(month)) throw new RangeError('infinity is out of range');\r\n  month -= 1;\r\n  year += Math.floor(month / 12);\r\n  month %= 12;\r\n  if (month < 0) month += 12;\r\n  month += 1;\r\n  return { year, month };\r\n}\r\n\r\nexport function BalanceISODate(yearParam: number, monthParam: number, dayParam: number) {\r\n  let year = yearParam;\r\n  let month = monthParam;\r\n  let day = dayParam;\r\n  if (!Number.isFinite(day)) throw new RangeError('infinity is out of range');\r\n  ({ year, month } = BalanceISOYearMonth(year, month));\r\n\r\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\r\n  // years. So if we have more than 400 years in days, there's no need to\r\n  // convert days to a year 400 times. We can convert a multiple of 400 all at\r\n  // once.\r\n  const daysIn400YearCycle = 400 * 365 + 97;\r\n  if (Math.abs(day) > daysIn400YearCycle) {\r\n    const nCycles = Math.trunc(day / daysIn400YearCycle);\r\n    year += 400 * nCycles;\r\n    day -= nCycles * daysIn400YearCycle;\r\n  }\r\n\r\n  let daysInYear = 0;\r\n  let testYear = month > 2 ? year : year - 1;\r\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\r\n    year -= 1;\r\n    testYear -= 1;\r\n    day += daysInYear;\r\n  }\r\n  testYear += 1;\r\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\r\n    year += 1;\r\n    testYear += 1;\r\n    day -= daysInYear;\r\n  }\r\n\r\n  while (day < 1) {\r\n    ({ year, month } = BalanceISOYearMonth(year, month - 1));\r\n    day += ISODaysInMonth(year, month);\r\n  }\r\n  while (day > ISODaysInMonth(year, month)) {\r\n    day -= ISODaysInMonth(year, month);\r\n    ({ year, month } = BalanceISOYearMonth(year, month + 1));\r\n  }\r\n\r\n  return { year, month, day };\r\n}\r\n\r\nfunction BalanceISODateTime(\r\n  year: number,\r\n  month: number,\r\n  day: number,\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  millisecond: number,\r\n  microsecond: number,\r\n  nanosecond: number\r\n) {\r\n  const time = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\r\n  return CombineISODateAndTimeRecord(isoDate, time);\r\n}\r\n\r\nfunction BalanceTime(\r\n  hourParam: number,\r\n  minuteParam: number,\r\n  secondParam: number,\r\n  millisecondParam: number,\r\n  microsecondParam: number,\r\n  nanosecondParam: number\r\n) {\r\n  let hour = hourParam;\r\n  let minute = minuteParam;\r\n  let second = secondParam;\r\n  let millisecond = millisecondParam;\r\n  let microsecond = microsecondParam;\r\n  let nanosecond = nanosecondParam;\r\n  let div;\r\n\r\n  ({ div, mod: nanosecond } = TruncatingDivModByPowerOf10(nanosecond, 3));\r\n  microsecond += div;\r\n  if (nanosecond < 0) {\r\n    microsecond -= 1;\r\n    nanosecond += 1000;\r\n  }\r\n\r\n  ({ div, mod: microsecond } = TruncatingDivModByPowerOf10(microsecond, 3));\r\n  millisecond += div;\r\n  if (microsecond < 0) {\r\n    millisecond -= 1;\r\n    microsecond += 1000;\r\n  }\r\n\r\n  second += Math.trunc(millisecond / 1000);\r\n  millisecond %= 1000;\r\n  if (millisecond < 0) {\r\n    second -= 1;\r\n    millisecond += 1000;\r\n  }\r\n\r\n  minute += Math.trunc(second / 60);\r\n  second %= 60;\r\n  if (second < 0) {\r\n    minute -= 1;\r\n    second += 60;\r\n  }\r\n\r\n  hour += Math.trunc(minute / 60);\r\n  minute %= 60;\r\n  if (minute < 0) {\r\n    hour -= 1;\r\n    minute += 60;\r\n  }\r\n\r\n  let deltaDays = Math.trunc(hour / 24);\r\n  hour %= 24;\r\n  if (hour < 0) {\r\n    deltaDays -= 1;\r\n    hour += 24;\r\n  }\r\n\r\n  // Results are possibly -0 at this point, but these are mathematical values in\r\n  // the spec. Force -0 to +0.\r\n  deltaDays += 0;\r\n  hour += 0;\r\n  minute += 0;\r\n  second += 0;\r\n  millisecond += 0;\r\n  microsecond += 0;\r\n  nanosecond += 0;\r\n\r\n  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\r\n}\r\n\r\nexport function DateDurationDays(dateDuration: DateDuration, plainRelativeTo: Temporal.PlainDate) {\r\n  const yearsMonthsWeeksDuration = AdjustDateDurationRecord(dateDuration, 0);\r\n  if (DateDurationSign(yearsMonthsWeeksDuration) === 0) return dateDuration.days;\r\n\r\n  // balance years, months, and weeks down to days\r\n  const isoDate = GetSlot(plainRelativeTo, ISO_DATE);\r\n  const later = CalendarDateAdd(GetSlot(plainRelativeTo, CALENDAR), isoDate, yearsMonthsWeeksDuration, 'constrain');\r\n  const epochDaysEarlier = ISODateToEpochDays(isoDate.year, isoDate.month - 1, isoDate.day);\r\n  const epochDaysLater = ISODateToEpochDays(later.year, later.month - 1, later.day);\r\n  const yearsMonthsWeeksInDays = epochDaysLater - epochDaysEarlier;\r\n  return dateDuration.days + yearsMonthsWeeksInDays;\r\n}\r\n\r\nexport function CreateNegatedTemporalDuration(duration: Temporal.Duration) {\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  return new TemporalDuration(\r\n    -GetSlot(duration, YEARS),\r\n    -GetSlot(duration, MONTHS),\r\n    -GetSlot(duration, WEEKS),\r\n    -GetSlot(duration, DAYS),\r\n    -GetSlot(duration, HOURS),\r\n    -GetSlot(duration, MINUTES),\r\n    -GetSlot(duration, SECONDS),\r\n    -GetSlot(duration, MILLISECONDS),\r\n    -GetSlot(duration, MICROSECONDS),\r\n    -GetSlot(duration, NANOSECONDS)\r\n  );\r\n}\r\n\r\nexport function ConstrainToRange(value: number | undefined, min: number, max: number) {\r\n  // Math.Max accepts undefined values and returns NaN. Undefined values are\r\n  // used for optional params in the method below.\r\n  return Math.min(max, Math.max(min, value as number));\r\n}\r\nexport function ConstrainISODate(year: number, monthParam: number, dayParam?: number) {\r\n  const month = ConstrainToRange(monthParam, 1, 12);\r\n  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\r\n  return { year, month, day };\r\n}\r\n\r\nexport function RejectToRange(value: number, min: number, max: number) {\r\n  if (value < min || value > max) throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\r\n}\r\n\r\nexport function RejectISODate(year: number, month: number, day: number) {\r\n  RejectToRange(month, 1, 12);\r\n  RejectToRange(day, 1, ISODaysInMonth(year, month));\r\n}\r\n\r\nfunction RejectDateRange(isoDate: ISODate) {\r\n  // Noon avoids trouble at edges of DateTime range (excludes midnight)\r\n  RejectDateTimeRange(CombineISODateAndTimeRecord(isoDate, NoonTimeRecord()));\r\n}\r\n\r\nexport function RejectTime(\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  millisecond: number,\r\n  microsecond: number,\r\n  nanosecond: number\r\n) {\r\n  RejectToRange(hour, 0, 23);\r\n  RejectToRange(minute, 0, 59);\r\n  RejectToRange(second, 0, 59);\r\n  RejectToRange(millisecond, 0, 999);\r\n  RejectToRange(microsecond, 0, 999);\r\n  RejectToRange(nanosecond, 0, 999);\r\n}\r\n\r\nexport function RejectDateTime(\r\n  year: number,\r\n  month: number,\r\n  day: number,\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  millisecond: number,\r\n  microsecond: number,\r\n  nanosecond: number\r\n) {\r\n  RejectISODate(year, month, day);\r\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n}\r\n\r\nexport function RejectDateTimeRange(isoDateTime: ISODateTime) {\r\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\r\n  if (JSBI.lessThan(ns, DATETIME_NS_MIN) || JSBI.greaterThan(ns, DATETIME_NS_MAX)) {\r\n    // Because PlainDateTime's range is wider than Instant's range, the line\r\n    // below will always throw. Calling `ValidateEpochNanoseconds` avoids\r\n    // repeating the same error message twice.\r\n    ValidateEpochNanoseconds(ns);\r\n  }\r\n}\r\n\r\n// Same as above, but throws a different, non-user-facing error\r\nfunction AssertISODateTimeWithinLimits(isoDateTime: ISODateTime) {\r\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\r\n  assert(\r\n    JSBI.greaterThanOrEqual(ns, DATETIME_NS_MIN) && JSBI.lessThanOrEqual(ns, DATETIME_NS_MAX),\r\n    `${ISODateTimeToString(isoDateTime, 'iso8601', 'auto')} is outside the representable range`\r\n  );\r\n}\r\n\r\n// In the spec, IsValidEpochNanoseconds returns a boolean and call sites are\r\n// responsible for throwing. In the polyfill, ValidateEpochNanoseconds takes its\r\n// place so that we can DRY the throwing code.\r\nfunction ValidateEpochNanoseconds(epochNanoseconds: JSBI) {\r\n  if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\r\n    throw new RangeError('date/time value is outside of supported range');\r\n  }\r\n}\r\n\r\nfunction RejectYearMonthRange({ year, month }: Omit<ISODate, 'day'>) {\r\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\r\n  if (year === YEAR_MIN) {\r\n    RejectToRange(month, 4, 12);\r\n  } else if (year === YEAR_MAX) {\r\n    RejectToRange(month, 1, 9);\r\n  }\r\n}\r\n\r\nexport function RejectDuration(\r\n  y: number,\r\n  mon: number,\r\n  w: number,\r\n  d: number,\r\n  h: number,\r\n  min: number,\r\n  s: number,\r\n  ms: number,\r\n  µs: number,\r\n  ns: number\r\n) {\r\n  let sign: -1 | 0 | 1 = 0;\r\n  const fields = [y, mon, w, d, h, min, s, ms, µs, ns];\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const prop = fields[index];\r\n    if (prop === Infinity || prop === -Infinity) throw new RangeError('infinite values not allowed as duration fields');\r\n    if (prop !== 0) {\r\n      const propSign = prop < 0 ? -1 : 1;\r\n      if (sign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\r\n      sign = propSign;\r\n    }\r\n  }\r\n  if (Math.abs(y) >= 2 ** 32 || Math.abs(mon) >= 2 ** 32 || Math.abs(w) >= 2 ** 32) {\r\n    throw new RangeError('years, months, and weeks must be < 2³²');\r\n  }\r\n  const msResult = TruncatingDivModByPowerOf10(ms, 3);\r\n  const µsResult = TruncatingDivModByPowerOf10(µs, 6);\r\n  const nsResult = TruncatingDivModByPowerOf10(ns, 9);\r\n  const remainderSec = TruncatingDivModByPowerOf10(msResult.mod * 1e6 + µsResult.mod * 1e3 + nsResult.mod, 9).div;\r\n  const totalSec = d * 86400 + h * 3600 + min * 60 + s + msResult.div + µsResult.div + nsResult.div + remainderSec;\r\n  if (!Number.isSafeInteger(totalSec)) {\r\n    throw new RangeError('total of duration time units cannot exceed 9007199254740991.999999999 s');\r\n  }\r\n}\r\n\r\nexport function ToInternalDurationRecord(duration: Temporal.Duration) {\r\n  const date = {\r\n    years: GetSlot(duration, YEARS),\r\n    months: GetSlot(duration, MONTHS),\r\n    weeks: GetSlot(duration, WEEKS),\r\n    days: GetSlot(duration, DAYS)\r\n  };\r\n  const time = TimeDuration.fromComponents(\r\n    GetSlot(duration, HOURS),\r\n    GetSlot(duration, MINUTES),\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  );\r\n  return { date, time };\r\n}\r\n\r\nexport function ToInternalDurationRecordWith24HourDays(duration: Temporal.Duration) {\r\n  const time = TimeDuration.fromComponents(\r\n    GetSlot(duration, HOURS),\r\n    GetSlot(duration, MINUTES),\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  ).add24HourDays(GetSlot(duration, DAYS));\r\n  const date = {\r\n    years: GetSlot(duration, YEARS),\r\n    months: GetSlot(duration, MONTHS),\r\n    weeks: GetSlot(duration, WEEKS),\r\n    days: 0\r\n  };\r\n  return { date, time };\r\n}\r\n\r\nfunction ToDateDurationRecordWithoutTime(duration: Temporal.Duration) {\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n  const days = Math.trunc(internalDuration.time.sec / 86400);\r\n  RejectDuration(\r\n    internalDuration.date.years,\r\n    internalDuration.date.months,\r\n    internalDuration.date.weeks,\r\n    days,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    0\r\n  );\r\n  return { ...internalDuration.date, days };\r\n}\r\n\r\nexport function TemporalDurationFromInternal(internalDuration: InternalDuration, largestUnit: Temporal.DateTimeUnit) {\r\n  const sign = internalDuration.time.sign();\r\n  let nanoseconds = internalDuration.time.abs().subsec;\r\n  let microseconds = 0;\r\n  let milliseconds = 0;\r\n  let seconds = internalDuration.time.abs().sec;\r\n  let minutes = 0;\r\n  let hours = 0;\r\n  let days = 0;\r\n\r\n  switch (largestUnit) {\r\n    case 'year':\r\n    case 'month':\r\n    case 'week':\r\n    case 'day':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      minutes = Math.trunc(seconds / 60);\r\n      seconds %= 60;\r\n      hours = Math.trunc(minutes / 60);\r\n      minutes %= 60;\r\n      days = Math.trunc(hours / 24);\r\n      hours %= 24;\r\n      break;\r\n    case 'hour':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      minutes = Math.trunc(seconds / 60);\r\n      seconds %= 60;\r\n      hours = Math.trunc(minutes / 60);\r\n      minutes %= 60;\r\n      break;\r\n    case 'minute':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      minutes = Math.trunc(seconds / 60);\r\n      seconds %= 60;\r\n      break;\r\n    case 'second':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      break;\r\n    case 'millisecond':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = FMAPowerOf10(seconds, 3, Math.trunc(microseconds / 1000));\r\n      microseconds %= 1000;\r\n      seconds = 0;\r\n      break;\r\n    case 'microsecond':\r\n      microseconds = FMAPowerOf10(seconds, 6, Math.trunc(nanoseconds / 1000));\r\n      nanoseconds %= 1000;\r\n      seconds = 0;\r\n      break;\r\n    case 'nanosecond':\r\n      nanoseconds = FMAPowerOf10(seconds, 9, nanoseconds);\r\n      seconds = 0;\r\n      break;\r\n    default:\r\n      /* c8 ignore next */ assertNotReached();\r\n  }\r\n\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  return new TemporalDuration(\r\n    internalDuration.date.years,\r\n    internalDuration.date.months,\r\n    internalDuration.date.weeks,\r\n    internalDuration.date.days + sign * days,\r\n    sign * hours,\r\n    sign * minutes,\r\n    sign * seconds,\r\n    sign * milliseconds,\r\n    sign * microseconds,\r\n    sign * nanoseconds\r\n  );\r\n}\r\n\r\nexport function CombineDateAndTimeDuration(dateDuration: DateDuration, timeDuration: TimeDuration) {\r\n  const dateSign = DateDurationSign(dateDuration);\r\n  const timeSign = timeDuration.sign();\r\n  assert(\r\n    dateSign === 0 || timeSign === 0 || dateSign === timeSign,\r\n    'should not be able to create mixed sign duration fields here'\r\n  );\r\n  return { date: dateDuration, time: timeDuration };\r\n}\r\n\r\n// Caution: month is 0-based\r\nexport function ISODateToEpochDays(year: number, month: number, day: number) {\r\n  return (\r\n    GetUTCEpochMilliseconds({\r\n      isoDate: { year, month: month + 1, day },\r\n      time: { hour: 0, minute: 0, second: 0, millisecond: 0 }\r\n    }) / DAY_MS\r\n  );\r\n}\r\n\r\n// This is needed before calling GetUTCEpochNanoseconds, because it uses MakeDay\r\n// which is ill-defined in how it handles large year numbers. If the issue\r\n// https://github.com/tc39/ecma262/issues/1087 is fixed, this can be removed\r\n// with no observable changes.\r\nfunction CheckISODaysRange({ year, month, day }: ISODate) {\r\n  if (Math.abs(ISODateToEpochDays(year, month - 1, day)) > 1e8) {\r\n    throw new RangeError('date/time value is outside the supported range');\r\n  }\r\n}\r\n\r\nfunction DifferenceTime(time1: TimeRecord, time2: TimeRecord) {\r\n  const hours = time2.hour - time1.hour;\r\n  const minutes = time2.minute - time1.minute;\r\n  const seconds = time2.second - time1.second;\r\n  const milliseconds = time2.millisecond - time1.millisecond;\r\n  const microseconds = time2.microsecond - time1.microsecond;\r\n  const nanoseconds = time2.nanosecond - time1.nanosecond;\r\n  const timeDuration = TimeDuration.fromComponents(hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n  assert(timeDuration.abs().sec < 86400, '_bt_.[[Days]] should be 0');\r\n  return timeDuration;\r\n}\r\n\r\nfunction DifferenceInstant(\r\n  ns1: JSBI,\r\n  ns2: JSBI,\r\n  increment: number,\r\n  smallestUnit: Temporal.TimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  let timeDuration = TimeDuration.fromEpochNsDiff(ns2, ns1);\r\n  timeDuration = RoundTimeDuration(timeDuration, increment, smallestUnit, roundingMode);\r\n  return CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\r\n}\r\n\r\nfunction DifferenceISODateTime(\r\n  isoDateTime1: ISODateTime,\r\n  isoDateTime2: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit\r\n) {\r\n  AssertISODateTimeWithinLimits(isoDateTime1);\r\n  AssertISODateTimeWithinLimits(isoDateTime2);\r\n  let timeDuration = DifferenceTime(isoDateTime1.time, isoDateTime2.time);\r\n\r\n  const timeSign = timeDuration.sign();\r\n  const dateSign = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\r\n\r\n  // back-off a day from date2 so that the signs of the date and time diff match\r\n  let adjustedDate = isoDateTime2.isoDate;\r\n  if (dateSign === timeSign) {\r\n    adjustedDate = BalanceISODate(adjustedDate.year, adjustedDate.month, adjustedDate.day + timeSign);\r\n    timeDuration = timeDuration.add24HourDays(-timeSign);\r\n  }\r\n\r\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\r\n  const dateDifference = CalendarDateUntil(calendar, isoDateTime1.isoDate, adjustedDate, dateLargestUnit);\r\n  if (largestUnit !== dateLargestUnit) {\r\n    // largestUnit < days, so add the days in to the internal duration\r\n    timeDuration = timeDuration.add24HourDays(dateDifference.days);\r\n    dateDifference.days = 0;\r\n  }\r\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\r\n}\r\n\r\nfunction DifferenceZonedDateTime(\r\n  ns1: JSBI,\r\n  ns2: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit\r\n) {\r\n  const nsDiff = JSBI.subtract(ns2, ns1);\r\n  if (JSBI.equal(nsDiff, ZERO)) return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\r\n  const sign = JSBI.lessThan(nsDiff, ZERO) ? -1 : 1;\r\n\r\n  // Convert start/end instants to datetimes\r\n  const isoDtStart = GetISODateTimeFor(timeZone, ns1);\r\n  const isoDtEnd = GetISODateTimeFor(timeZone, ns2);\r\n\r\n  // Simulate moving ns1 as many years/months/weeks/days as possible without\r\n  // surpassing ns2. This value is stored in intermediateDateTime/intermediateInstant/intermediateNs.\r\n  // We do not literally move years/months/weeks/days with calendar arithmetic,\r\n  // but rather assume intermediateDateTime will have the same time-parts as\r\n  // dtStart and the date-parts from dtEnd, and move backward from there.\r\n  // The number of days we move backward is stored in dayCorrection.\r\n  // Credit to Adam Shaw for devising this algorithm.\r\n  let dayCorrection = 0;\r\n  let intermediateDateTime: ISODateTime | undefined;\r\n\r\n  // The max number of allowed day corrections depends on the direction of travel.\r\n  // Both directions allow for 1 day correction due to an ISO wall-clock overshoot (see below).\r\n  // Only the forward direction allows for an additional 1 day correction caused by a push-forward\r\n  // 'compatible' DST transition causing the wall-clock to overshoot again.\r\n  // This max value is inclusive.\r\n  let maxDayCorrection = sign === 1 ? 2 : 1;\r\n\r\n  // Detect ISO wall-clock overshoot.\r\n  // If the diff of the ISO wall-clock times is opposite to the overall diff's sign,\r\n  // we are guaranteed to need at least one day correction.\r\n  let timeDuration = DifferenceTime(isoDtStart.time, isoDtEnd.time);\r\n  if (timeDuration.sign() === -sign) {\r\n    dayCorrection++;\r\n  }\r\n\r\n  for (; dayCorrection <= maxDayCorrection; dayCorrection++) {\r\n    const intermediateDate = BalanceISODate(\r\n      isoDtEnd.isoDate.year,\r\n      isoDtEnd.isoDate.month,\r\n      isoDtEnd.isoDate.day - dayCorrection * sign\r\n    );\r\n\r\n    // Incorporate time parts from dtStart\r\n    intermediateDateTime = CombineISODateAndTimeRecord(intermediateDate, isoDtStart.time);\r\n\r\n    // Convert intermediate datetime to epoch-nanoseconds (may disambiguate)\r\n    const intermediateNs = GetEpochNanosecondsFor(timeZone, intermediateDateTime, 'compatible');\r\n\r\n    // Compute the nanosecond diff between the intermediate instant and the final destination\r\n    timeDuration = TimeDuration.fromEpochNsDiff(ns2, intermediateNs);\r\n\r\n    // Did intermediateNs NOT surpass ns2?\r\n    // If so, exit the loop with success (without incrementing dayCorrection past maxDayCorrection)\r\n    if (timeDuration.sign() !== -sign) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  assert(dayCorrection <= maxDayCorrection, `more than ${maxDayCorrection} day correction needed`);\r\n\r\n  // Output of the above loop\r\n  assertExists(intermediateDateTime);\r\n\r\n  // Similar to what happens in DifferenceISODateTime with date parts only:\r\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\r\n  const dateDifference = CalendarDateUntil(calendar, isoDtStart.isoDate, intermediateDateTime.isoDate, dateLargestUnit);\r\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\r\n}\r\n\r\n// Epoch-nanosecond bounding technique where the start/end of the calendar-unit\r\n// interval are converted to epoch-nanosecond times and destEpochNs is nudged to\r\n// either one.\r\nfunction NudgeToCalendarUnit(\r\n  sign: -1 | 1,\r\n  durationParam: InternalDuration,\r\n  destEpochNs: JSBI,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  increment: number,\r\n  unit: Temporal.DateUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be day, week, month, or year\r\n  // timeZone may be undefined\r\n  let duration = durationParam;\r\n\r\n  // Create a duration with smallestUnit trunc'd towards zero\r\n  // Create a separate duration that incorporates roundingIncrement\r\n  let r1, r2, startDuration, endDuration;\r\n  switch (unit) {\r\n    case 'year': {\r\n      const years = RoundNumberToIncrement(duration.date.years, increment, 'trunc');\r\n      r1 = years;\r\n      r2 = years + increment * sign;\r\n      startDuration = { years: r1, months: 0, weeks: 0, days: 0 };\r\n      endDuration = { ...startDuration, years: r2 };\r\n      break;\r\n    }\r\n    case 'month': {\r\n      const months = RoundNumberToIncrement(duration.date.months, increment, 'trunc');\r\n      r1 = months;\r\n      r2 = months + increment * sign;\r\n      startDuration = AdjustDateDurationRecord(duration.date, 0, 0, r1);\r\n      endDuration = AdjustDateDurationRecord(duration.date, 0, 0, r2);\r\n      break;\r\n    }\r\n    case 'week': {\r\n      const yearsMonths = AdjustDateDurationRecord(duration.date, 0, 0);\r\n      const weeksStart = CalendarDateAdd(calendar, isoDateTime.isoDate, yearsMonths, 'constrain');\r\n      const weeksEnd = BalanceISODate(weeksStart.year, weeksStart.month, weeksStart.day + duration.date.days);\r\n      const untilResult = CalendarDateUntil(calendar, weeksStart, weeksEnd, 'week');\r\n      const weeks = RoundNumberToIncrement(duration.date.weeks + untilResult.weeks, increment, 'trunc');\r\n      r1 = weeks;\r\n      r2 = weeks + increment * sign;\r\n      startDuration = AdjustDateDurationRecord(duration.date, 0, r1);\r\n      endDuration = AdjustDateDurationRecord(duration.date, 0, r2);\r\n      break;\r\n    }\r\n    case 'day': {\r\n      const days = RoundNumberToIncrement(duration.date.days, increment, 'trunc');\r\n      r1 = days;\r\n      r2 = days + increment * sign;\r\n      startDuration = AdjustDateDurationRecord(duration.date, r1);\r\n      endDuration = AdjustDateDurationRecord(duration.date, r2);\r\n      break;\r\n    }\r\n    default:\r\n      /* c8 ignore next */ assertNotReached();\r\n  }\r\n\r\n  if (sign === 1) assert(r1 >= 0 && r1 < r2, `positive ordering of r1, r2: 0 ≤ ${r1} < ${r2}`);\r\n  if (sign === -1) assert(r1 <= 0 && r1 > r2, `negative ordering of r1, r2: 0 ≥ ${r1} > ${r2}`);\r\n\r\n  // Apply to origin, output PlainDateTimes\r\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, startDuration, 'constrain');\r\n  const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\r\n\r\n  // Convert to epoch-nanoseconds\r\n  let startEpochNs, endEpochNs;\r\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\r\n  const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\r\n  if (timeZone) {\r\n    startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\r\n    endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\r\n  } else {\r\n    startEpochNs = GetUTCEpochNanoseconds(startDateTime);\r\n    endEpochNs = GetUTCEpochNanoseconds(endDateTime);\r\n  }\r\n\r\n  // Round the smallestUnit within the epoch-nanosecond span\r\n  if (sign === 1) {\r\n    assert(\r\n      JSBI.lessThanOrEqual(startEpochNs, destEpochNs) && JSBI.lessThanOrEqual(destEpochNs, endEpochNs),\r\n      `${unit} was 0 days long`\r\n    );\r\n  }\r\n  if (sign === -1) {\r\n    assert(\r\n      JSBI.lessThanOrEqual(endEpochNs, destEpochNs) && JSBI.lessThanOrEqual(destEpochNs, startEpochNs),\r\n      `${unit} was 0 days long`\r\n    );\r\n  }\r\n  assert(!JSBI.equal(endEpochNs, startEpochNs), 'startEpochNs must ≠ endEpochNs');\r\n  const numerator = TimeDuration.fromEpochNsDiff(destEpochNs, startEpochNs);\r\n  const denominator = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\r\n  const unsignedRoundingMode = GetUnsignedRoundingMode(roundingMode, sign < 0 ? 'negative' : 'positive');\r\n  const cmp = numerator.add(numerator).abs().subtract(denominator.abs()).sign();\r\n  const even = (Math.abs(r1) / increment) % 2 === 0;\r\n  // prettier-ignore\r\n  const roundedUnit = numerator.isZero()\r\n    ? Math.abs(r1)\r\n    : !numerator.cmp(denominator) // equal?\r\n      ? Math.abs(r2)\r\n      : ApplyUnsignedRoundingMode(Math.abs(r1), Math.abs(r2), cmp, even, unsignedRoundingMode);\r\n\r\n  // Trick to minimize rounding error, due to the lack of fma() in JS\r\n  const fakeNumerator = new TimeDuration(\r\n    JSBI.add(\r\n      JSBI.multiply(denominator.totalNs, JSBI.BigInt(r1)),\r\n      JSBI.multiply(numerator.totalNs, JSBI.BigInt(increment * sign))\r\n    )\r\n  );\r\n  const total = fakeNumerator.fdiv(denominator.totalNs);\r\n  assert(Math.abs(r1) <= Math.abs(total) && Math.abs(total) <= Math.abs(r2), 'r1 ≤ total ≤ r2');\r\n\r\n  // Determine whether expanded or contracted\r\n  const didExpandCalendarUnit = roundedUnit === Math.abs(r2);\r\n  duration = { date: didExpandCalendarUnit ? endDuration : startDuration, time: TimeDuration.ZERO };\r\n\r\n  const nudgeResult = {\r\n    duration,\r\n    nudgedEpochNs: didExpandCalendarUnit ? endEpochNs : startEpochNs,\r\n    didExpandCalendarUnit\r\n  };\r\n  return { nudgeResult, total };\r\n}\r\n\r\n// Attempts rounding of time units within a time zone's day, but if the rounding\r\n// causes time to exceed the total time within the day, rerun rounding in next\r\n// day.\r\nfunction NudgeToZonedTime(\r\n  sign: -1 | 1,\r\n  durationParam: InternalDuration,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  increment: number,\r\n  unit: Temporal.TimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be hour or smaller\r\n  let duration = durationParam;\r\n\r\n  // Apply to origin, output start/end of the day as PlainDateTimes\r\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, duration.date, 'constrain');\r\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\r\n  const endDate = BalanceISODate(start.year, start.month, start.day + sign);\r\n  const endDateTime = CombineISODateAndTimeRecord(endDate, isoDateTime.time);\r\n\r\n  // Compute the epoch-nanosecond start/end of the final whole-day interval\r\n  // If duration has negative sign, startEpochNs will be after endEpochNs\r\n  const startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\r\n  const endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\r\n\r\n  // The signed amount of time from the start of the whole-day interval to the end\r\n  const daySpan = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\r\n  if (daySpan.sign() !== sign) throw new RangeError('time zone returned inconsistent Instants');\r\n\r\n  // Compute time parts of the duration to nanoseconds and round\r\n  // Result could be negative\r\n  const unitIncrement = JSBI.BigInt(NS_PER_TIME_UNIT[unit] * increment);\r\n  let roundedTimeDuration = duration.time.round(unitIncrement, roundingMode);\r\n\r\n  // Does the rounded time exceed the time-in-day?\r\n  const beyondDaySpan = roundedTimeDuration.subtract(daySpan);\r\n  const didRoundBeyondDay = beyondDaySpan.sign() !== -sign;\r\n\r\n  let dayDelta, nudgedEpochNs;\r\n  if (didRoundBeyondDay) {\r\n    // If rounded into next day, use the day-end as the local origin and rerun\r\n    // the rounding\r\n    dayDelta = sign;\r\n    roundedTimeDuration = beyondDaySpan.round(unitIncrement, roundingMode);\r\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(endEpochNs);\r\n  } else {\r\n    // Otherwise, if time not rounded beyond day, use the day-start as the local\r\n    // origin\r\n    dayDelta = 0;\r\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(startEpochNs);\r\n  }\r\n\r\n  const dateDuration = AdjustDateDurationRecord(duration.date, duration.date.days + dayDelta);\r\n  const resultDuration = CombineDateAndTimeDuration(dateDuration, roundedTimeDuration);\r\n  return {\r\n    duration: resultDuration,\r\n    nudgedEpochNs,\r\n    didExpandCalendarUnit: didRoundBeyondDay\r\n  };\r\n}\r\n\r\n// Converts all fields to nanoseconds and does integer rounding.\r\nfunction NudgeToDayOrTime(\r\n  durationParam: InternalDuration,\r\n  destEpochNs: JSBI,\r\n  largestUnit: Temporal.DateTimeUnit,\r\n  increment: number,\r\n  smallestUnit: Temporal.TimeUnit | 'day',\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be day or smaller\r\n  let duration = durationParam;\r\n\r\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\r\n  // Convert to nanoseconds and round\r\n  const roundedTime = timeDuration.round(JSBI.BigInt(increment * NS_PER_TIME_UNIT[smallestUnit]), roundingMode);\r\n  const diffTime = roundedTime.subtract(timeDuration);\r\n\r\n  // Determine if whole days expanded\r\n  const { quotient: wholeDays } = timeDuration.divmod(DAY_NANOS);\r\n  const { quotient: roundedWholeDays } = roundedTime.divmod(DAY_NANOS);\r\n  const didExpandDays = Math.sign(roundedWholeDays - wholeDays) === timeDuration.sign();\r\n\r\n  const nudgedEpochNs = diffTime.addToEpochNs(destEpochNs);\r\n\r\n  let days = 0;\r\n  let remainder = roundedTime;\r\n  if (TemporalUnitCategory(largestUnit) === 'date') {\r\n    days = roundedWholeDays;\r\n    remainder = roundedTime.add(TimeDuration.fromComponents(-roundedWholeDays * 24, 0, 0, 0, 0, 0));\r\n  }\r\n\r\n  const dateDuration = AdjustDateDurationRecord(duration.date, days);\r\n  return {\r\n    duration: { date: dateDuration, time: remainder },\r\n    nudgedEpochNs,\r\n    didExpandCalendarUnit: didExpandDays\r\n  };\r\n}\r\n\r\n// Given a potentially bottom-heavy duration, bubble up smaller units to larger\r\n// units. Any units smaller than smallestUnit are already zeroed-out.\r\nfunction BubbleRelativeDuration(\r\n  sign: -1 | 1,\r\n  durationParam: InternalDuration,\r\n  nudgedEpochNs: JSBI,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateUnit,\r\n  smallestUnit: Temporal.DateUnit\r\n) {\r\n  // smallestUnit is day or larger\r\n  let duration = durationParam;\r\n\r\n  if (smallestUnit === largestUnit) return duration;\r\n\r\n  // Check to see if nudgedEpochNs has hit the boundary of any units higher than\r\n  // smallestUnit, in which case increment the higher unit and clear smaller\r\n  // units.\r\n  const largestUnitIndex = UNITS_DESCENDING.indexOf(largestUnit);\r\n  const smallestUnitIndex = UNITS_DESCENDING.indexOf(smallestUnit);\r\n  for (let unitIndex = smallestUnitIndex - 1; unitIndex >= largestUnitIndex; unitIndex--) {\r\n    // The only situation where days and smaller bubble-up into weeks is when\r\n    // largestUnit is 'week' (not to be confused with the situation where\r\n    // smallestUnit is 'week', in which case days and smaller are ROUNDED-up\r\n    // into weeks, but that has already happened by the time this function\r\n    // executes)\r\n    // So, if days and smaller are NOT bubbled-up into weeks, and the current\r\n    // unit is weeks, skip.\r\n    const unit = UNITS_DESCENDING[unitIndex];\r\n    if (unit === 'week' && largestUnit !== 'week') {\r\n      continue;\r\n    }\r\n\r\n    let endDuration;\r\n    switch (unit) {\r\n      case 'year': {\r\n        const years = duration.date.years + sign;\r\n        endDuration = { years, months: 0, weeks: 0, days: 0 };\r\n        break;\r\n      }\r\n      case 'month': {\r\n        const months = duration.date.months + sign;\r\n        endDuration = AdjustDateDurationRecord(duration.date, 0, 0, months);\r\n        break;\r\n      }\r\n      case 'week': {\r\n        const weeks = duration.date.weeks + sign;\r\n        endDuration = AdjustDateDurationRecord(duration.date, 0, weeks);\r\n        break;\r\n      }\r\n      default:\r\n        /* c8 ignore next */ assertNotReached();\r\n    }\r\n\r\n    // Compute end-of-unit in epoch-nanoseconds\r\n    const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\r\n    const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\r\n    let endEpochNs;\r\n    if (timeZone) {\r\n      endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\r\n    } else {\r\n      endEpochNs = GetUTCEpochNanoseconds(endDateTime);\r\n    }\r\n\r\n    const didExpandToEnd = compare(nudgedEpochNs, endEpochNs) !== -sign;\r\n\r\n    // Is nudgedEpochNs at the end-of-unit? This means it should bubble-up to\r\n    // the next highest unit (and possibly further...)\r\n    if (didExpandToEnd) {\r\n      duration = { date: endDuration, time: TimeDuration.ZERO };\r\n    } else {\r\n      // NOT at end-of-unit. Stop looking for bubbling\r\n      break;\r\n    }\r\n  }\r\n\r\n  return duration;\r\n}\r\n\r\nfunction RoundRelativeDuration(\r\n  durationParam: InternalDuration,\r\n  destEpochNs: JSBI,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnitParam: Temporal.DateTimeUnit,\r\n  increment: number,\r\n  smallestUnit: Temporal.DateTimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  let duration = durationParam;\r\n  // The duration must already be balanced. This should be achieved by calling\r\n  // one of the non-rounding since/until internal methods prior. It's okay to\r\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\r\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\r\n  // >24 hours in its timezone. (should automatically end up like this if using\r\n  // non-rounding since/until internal methods prior)\r\n  const irregularLengthUnit = IsCalendarUnit(smallestUnit) || (timeZone && smallestUnit === 'day');\r\n  const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\r\n\r\n  let nudgeResult;\r\n  if (irregularLengthUnit) {\r\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\r\n    ({ nudgeResult } = NudgeToCalendarUnit(\r\n      sign,\r\n      duration,\r\n      destEpochNs,\r\n      isoDateTime,\r\n      timeZone,\r\n      calendar,\r\n      increment,\r\n      smallestUnit,\r\n      roundingMode\r\n    ));\r\n  } else if (timeZone) {\r\n    // Special-case for rounding time units within a zoned day\r\n    uncheckedAssertNarrowedType<Temporal.TimeUnit>(\r\n      smallestUnit,\r\n      'other values handled in irregularLengthUnit clause above'\r\n    );\r\n    nudgeResult = NudgeToZonedTime(\r\n      sign,\r\n      duration,\r\n      isoDateTime,\r\n      timeZone,\r\n      calendar,\r\n      increment,\r\n      smallestUnit,\r\n      roundingMode\r\n    );\r\n  } else {\r\n    // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\r\n    // math. years/months/weeks unchanged\r\n    nudgeResult = NudgeToDayOrTime(duration, destEpochNs, largestUnitParam, increment, smallestUnit, roundingMode);\r\n  }\r\n\r\n  duration = nudgeResult.duration;\r\n  // Did nudging cause the duration to expand to the next day or larger?\r\n  // Bubble-up smaller calendar units into higher ones, except for weeks, which\r\n  // don't balance up into months\r\n  if (nudgeResult.didExpandCalendarUnit && smallestUnit !== 'week') {\r\n    uncheckedAssertNarrowedType<Temporal.DateUnit>(\r\n      largestUnitParam,\r\n      'if we expanded to a calendar unit, then largestUnit is a calendar unit'\r\n    );\r\n    duration = BubbleRelativeDuration(\r\n      sign,\r\n      duration,\r\n      nudgeResult.nudgedEpochNs, // The destEpochNs after expanding/contracting\r\n      isoDateTime,\r\n      timeZone,\r\n      calendar,\r\n      largestUnitParam, // where to STOP bubbling\r\n      LargerOfTwoTemporalUnits(smallestUnit, 'day') as Temporal.DateUnit // where to START bubbling-up from\r\n    );\r\n  }\r\n\r\n  return duration;\r\n}\r\n\r\nfunction TotalRelativeDuration(\r\n  duration: InternalDuration,\r\n  destEpochNs: JSBI,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  unit: Temporal.DateTimeUnit\r\n) {\r\n  // The duration must already be balanced. This should be achieved by calling\r\n  // one of the non-rounding since/until internal methods prior. It's okay to\r\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\r\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\r\n  // >24 hours in its timezone. (should automatically end up like this if using\r\n  // non-rounding since/until internal methods prior)\r\n  if (IsCalendarUnit(unit) || (timeZone && unit === 'day')) {\r\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\r\n    const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\r\n    return NudgeToCalendarUnit(sign, duration, destEpochNs, isoDateTime, timeZone, calendar, 1, unit, 'trunc').total;\r\n  }\r\n  // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\r\n  // math. years/months/weeks unchanged\r\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\r\n  return TotalTimeDuration(timeDuration, unit);\r\n}\r\n\r\nexport function DifferencePlainDateTimeWithRounding(\r\n  isoDateTime1: ISODateTime,\r\n  isoDateTime2: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit,\r\n  roundingIncrement: number,\r\n  smallestUnit: Temporal.DateTimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) {\r\n    return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\r\n  }\r\n\r\n  RejectDateTimeRange(isoDateTime1);\r\n  RejectDateTimeRange(isoDateTime2);\r\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, largestUnit);\r\n\r\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\r\n\r\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\r\n  return RoundRelativeDuration(\r\n    duration,\r\n    destEpochNs,\r\n    isoDateTime1,\r\n    null,\r\n    calendar,\r\n    largestUnit,\r\n    roundingIncrement,\r\n    smallestUnit,\r\n    roundingMode\r\n  );\r\n}\r\n\r\nexport function DifferencePlainDateTimeWithTotal(\r\n  isoDateTime1: ISODateTime,\r\n  isoDateTime2: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  unit: Temporal.DateTimeUnit\r\n) {\r\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) return 0;\r\n\r\n  RejectDateTimeRange(isoDateTime1);\r\n  RejectDateTimeRange(isoDateTime2);\r\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, unit);\r\n\r\n  if (unit === 'nanosecond') return JSBI.toNumber(duration.time.totalNs);\r\n\r\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\r\n  return TotalRelativeDuration(duration, destEpochNs, isoDateTime1, null, calendar, unit);\r\n}\r\n\r\nexport function DifferenceZonedDateTimeWithRounding(\r\n  ns1: JSBI,\r\n  ns2: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit,\r\n  roundingIncrement: number,\r\n  smallestUnit: Temporal.DateTimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  if (TemporalUnitCategory(largestUnit) === 'time') {\r\n    // The user is only asking for a time difference, so return difference of instants.\r\n    return DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit as Temporal.TimeUnit, roundingMode);\r\n  }\r\n\r\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit);\r\n\r\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\r\n\r\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\r\n  return RoundRelativeDuration(\r\n    duration,\r\n    ns2,\r\n    dateTime,\r\n    timeZone,\r\n    calendar,\r\n    largestUnit,\r\n    roundingIncrement,\r\n    smallestUnit,\r\n    roundingMode\r\n  );\r\n}\r\n\r\nexport function DifferenceZonedDateTimeWithTotal(\r\n  ns1: JSBI,\r\n  ns2: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  unit: Temporal.DateTimeUnit\r\n) {\r\n  if (TemporalUnitCategory(unit) === 'time') {\r\n    // The user is only asking for a time difference, so return difference of instants.\r\n    return TotalTimeDuration(TimeDuration.fromEpochNsDiff(ns2, ns1), unit as Temporal.TimeUnit);\r\n  }\r\n\r\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, unit);\r\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\r\n  return TotalRelativeDuration(duration, ns2, dateTime, timeZone, calendar, unit);\r\n}\r\n\r\ntype DifferenceOperation = 'since' | 'until';\r\n\r\nfunction GetDifferenceSettings<T extends Temporal.DateTimeUnit>(\r\n  op: DifferenceOperation,\r\n  options: Temporal.DifferenceOptions<T>,\r\n  group: 'datetime' | 'date' | 'time',\r\n  disallowed: (Temporal.DateTimeUnit | 'auto')[],\r\n  fallbackSmallest: T,\r\n  smallestLargestDefaultUnit: T\r\n) {\r\n  const ALLOWED_UNITS = TEMPORAL_UNITS.reduce((allowed, unitInfo) => {\r\n    const p = unitInfo[0];\r\n    const s = unitInfo[1];\r\n    const c = unitInfo[2];\r\n    if ((group === 'datetime' || c === group) && !disallowed.includes(s)) {\r\n      allowed.push(s, p);\r\n    }\r\n    return allowed;\r\n  }, [] as (Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit>)[]);\r\n\r\n  let largestUnit = GetTemporalUnitValuedOption(options, 'largestUnit', group, 'auto');\r\n  if (disallowed.includes(largestUnit)) {\r\n    throw new RangeError(`largestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${largestUnit}`);\r\n  }\r\n\r\n  const roundingIncrement = GetTemporalRoundingIncrementOption(options);\r\n\r\n  let roundingMode = GetRoundingModeOption(options, 'trunc');\r\n  if (op === 'since') roundingMode = NegateRoundingMode(roundingMode);\r\n\r\n  const smallestUnit = GetTemporalUnitValuedOption(options, 'smallestUnit', group, fallbackSmallest);\r\n  if (disallowed.includes(smallestUnit)) {\r\n    throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\r\n  }\r\n\r\n  const defaultLargestUnit = LargerOfTwoTemporalUnits(smallestLargestDefaultUnit, smallestUnit);\r\n  if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\r\n  if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\r\n    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\r\n  }\r\n  const MAX_DIFFERENCE_INCREMENTS: { [k in Temporal.DateTimeUnit]?: number } = {\r\n    hour: 24,\r\n    minute: 60,\r\n    second: 60,\r\n    millisecond: 1000,\r\n    microsecond: 1000,\r\n    nanosecond: 1000\r\n  };\r\n  const maximum = MAX_DIFFERENCE_INCREMENTS[smallestUnit];\r\n  if (maximum !== undefined) ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\r\n\r\n  return { largestUnit: largestUnit as T, roundingIncrement, roundingMode, smallestUnit: smallestUnit as T };\r\n}\r\n\r\nexport function DifferenceTemporalInstant(\r\n  operation: DifferenceOperation,\r\n  instant: Temporal.Instant,\r\n  otherParam: InstantParams['until'][0],\r\n  options: InstantParams['until'][1]\r\n) {\r\n  const other = ToTemporalInstant(otherParam);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'second');\r\n\r\n  const onens = GetSlot(instant, EPOCHNANOSECONDS);\r\n  const twons = GetSlot(other, EPOCHNANOSECONDS);\r\n  const duration = DifferenceInstant(\r\n    onens,\r\n    twons,\r\n    settings.roundingIncrement,\r\n    settings.smallestUnit,\r\n    settings.roundingMode\r\n  );\r\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainDate(\r\n  operation: DifferenceOperation,\r\n  plainDate: Temporal.PlainDate,\r\n  otherParam: PlainDateParams['until'][0],\r\n  options: PlainDateParams['until'][1]\r\n) {\r\n  const other = ToTemporalDate(otherParam);\r\n  const calendar = GetSlot(plainDate, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', [], 'day', 'day');\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n  const isoDate = GetSlot(plainDate, ISO_DATE);\r\n  const isoOther = GetSlot(other, ISO_DATE);\r\n  if (CompareISODate(isoDate, isoOther) === 0) return new Duration();\r\n\r\n  const dateDifference = CalendarDateUntil(calendar, isoDate, isoOther, settings.largestUnit);\r\n\r\n  let duration = { date: dateDifference, time: TimeDuration.ZERO };\r\n  const roundingIsNoop = settings.smallestUnit === 'day' && settings.roundingIncrement === 1;\r\n  if (!roundingIsNoop) {\r\n    const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\r\n    const isoDateTimeOther = CombineISODateAndTimeRecord(isoOther, MidnightTimeRecord());\r\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\r\n    duration = RoundRelativeDuration(\r\n      duration,\r\n      destEpochNs,\r\n      isoDateTime,\r\n      null,\r\n      calendar,\r\n      settings.largestUnit,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit,\r\n      settings.roundingMode\r\n    );\r\n  }\r\n\r\n  let result = TemporalDurationFromInternal(duration, 'day');\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainDateTime(\r\n  operation: DifferenceOperation,\r\n  plainDateTime: Temporal.PlainDateTime,\r\n  otherParam: PlainDateTimeParams['until'][0],\r\n  options: PlainDateTimeParams['until'][1]\r\n) {\r\n  const other = ToTemporalDateTime(otherParam);\r\n  const calendar = GetSlot(plainDateTime, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'day');\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n  const isoDateTime1 = GetSlot(plainDateTime, ISO_DATE_TIME);\r\n  const isoDateTime2 = GetSlot(other, ISO_DATE_TIME);\r\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) === 0) return new Duration();\r\n\r\n  const duration = DifferencePlainDateTimeWithRounding(\r\n    isoDateTime1,\r\n    isoDateTime2,\r\n    calendar,\r\n    settings.largestUnit,\r\n    settings.roundingIncrement,\r\n    settings.smallestUnit,\r\n    settings.roundingMode\r\n  );\r\n\r\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainTime(\r\n  operation: DifferenceOperation,\r\n  plainTime: Temporal.PlainTime,\r\n  otherParam: PlainTimeParams['until'][0],\r\n  options: PlainTimeParams['until'][1]\r\n) {\r\n  const other = ToTemporalTime(otherParam);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'hour');\r\n\r\n  let timeDuration = DifferenceTime(GetSlot(plainTime, TIME), GetSlot(other, TIME));\r\n  timeDuration = RoundTimeDuration(\r\n    timeDuration,\r\n    settings.roundingIncrement,\r\n    settings.smallestUnit,\r\n    settings.roundingMode\r\n  );\r\n  const duration = CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\r\n\r\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainYearMonth(\r\n  operation: DifferenceOperation,\r\n  yearMonth: Temporal.PlainYearMonth,\r\n  otherParam: PlainYearMonthParams['until'][0],\r\n  options: PlainYearMonthParams['until'][1]\r\n) {\r\n  const other = ToTemporalYearMonth(otherParam);\r\n  const calendar = GetSlot(yearMonth, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between months of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', ['week', 'day'], 'month', 'year');\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n  if (CompareISODate(GetSlot(yearMonth, ISO_DATE), GetSlot(other, ISO_DATE)) == 0) {\r\n    return new Duration();\r\n  }\r\n\r\n  const thisFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\r\n  thisFields.day = 1;\r\n  const thisDate = CalendarDateFromFields(calendar, thisFields, 'constrain');\r\n  const otherFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(other, ISO_DATE), 'year-month');\r\n  otherFields.day = 1;\r\n  const otherDate = CalendarDateFromFields(calendar, otherFields, 'constrain');\r\n\r\n  const dateDifference = CalendarDateUntil(calendar, thisDate, otherDate, settings.largestUnit);\r\n  let duration = { date: AdjustDateDurationRecord(dateDifference, 0, 0), time: TimeDuration.ZERO };\r\n  if (settings.smallestUnit !== 'month' || settings.roundingIncrement !== 1) {\r\n    const isoDateTime = CombineISODateAndTimeRecord(thisDate, MidnightTimeRecord());\r\n    const isoDateTimeOther = CombineISODateAndTimeRecord(otherDate, MidnightTimeRecord());\r\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\r\n    duration = RoundRelativeDuration(\r\n      duration,\r\n      destEpochNs,\r\n      isoDateTime,\r\n      null,\r\n      calendar,\r\n      settings.largestUnit,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit,\r\n      settings.roundingMode\r\n    );\r\n  }\r\n\r\n  let result = TemporalDurationFromInternal(duration, 'day');\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalZonedDateTime(\r\n  operation: DifferenceOperation,\r\n  zonedDateTime: Temporal.ZonedDateTime,\r\n  otherParam: ZonedDateTimeParams['until'][0],\r\n  options: ZonedDateTimeParams['until'][1]\r\n) {\r\n  const other = ToTemporalZonedDateTime(otherParam);\r\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'hour');\r\n\r\n  const ns1 = GetSlot(zonedDateTime, EPOCHNANOSECONDS);\r\n  const ns2 = GetSlot(other, EPOCHNANOSECONDS);\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n\r\n  let result;\r\n  if (TemporalUnitCategory(settings.largestUnit) !== 'date') {\r\n    // The user is only asking for a time difference, so return difference of instants.\r\n    const duration = DifferenceInstant(\r\n      ns1,\r\n      ns2,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit as Temporal.TimeUnit,\r\n      settings.roundingMode\r\n    );\r\n    result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  } else {\r\n    const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\r\n    if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\r\n      throw new RangeError(\r\n        \"When calculating difference between time zones, largestUnit must be 'hours' \" +\r\n          'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.'\r\n      );\r\n    }\r\n\r\n    if (JSBI.equal(ns1, ns2)) return new Duration();\r\n\r\n    const duration = DifferenceZonedDateTimeWithRounding(\r\n      ns1,\r\n      ns2,\r\n      timeZone,\r\n      calendar,\r\n      settings.largestUnit,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit,\r\n      settings.roundingMode\r\n    );\r\n    result = TemporalDurationFromInternal(duration, 'hour');\r\n  }\r\n\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function AddTime(\r\n  { hour, minute, second: secondParam, millisecond, microsecond, nanosecond: nanosecondParam }: TimeRecord,\r\n  timeDuration: TimeDuration\r\n) {\r\n  let second = secondParam;\r\n  let nanosecond = nanosecondParam;\r\n\r\n  second += timeDuration.sec;\r\n  nanosecond += timeDuration.subsec;\r\n  return BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n}\r\n\r\nfunction AddInstant(epochNanoseconds: JSBI, timeDuration: TimeDuration) {\r\n  const result = timeDuration.addToEpochNs(epochNanoseconds);\r\n  ValidateEpochNanoseconds(result);\r\n  return result;\r\n}\r\n\r\nexport function AddZonedDateTime(\r\n  epochNs: JSBI,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  duration: InternalDuration,\r\n  overflow: Overflow = 'constrain'\r\n) {\r\n  // If only time is to be added, then use Instant math. It's not OK to fall\r\n  // through to the date/time code below because compatible disambiguation in\r\n  // the PlainDateTime=>Instant conversion will change the offset of any\r\n  // ZonedDateTime in the repeated clock time after a backwards transition.\r\n  // When adding/subtracting time units and not dates, this disambiguation is\r\n  // not expected and so is avoided below via a fast path for time-only\r\n  // arithmetic.\r\n  // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\r\n  if (DateDurationSign(duration.date) === 0) return AddInstant(epochNs, duration.time);\r\n\r\n  // RFC 5545 requires the date portion to be added in calendar days and the\r\n  // time portion to be added in exact time.\r\n  const dt = GetISODateTimeFor(timeZone, epochNs);\r\n  const addedDate = CalendarDateAdd(calendar, dt.isoDate, duration.date, overflow);\r\n  const dtIntermediate = CombineISODateAndTimeRecord(addedDate, dt.time);\r\n\r\n  // Note that 'compatible' is used below because this disambiguation behavior\r\n  // is required by RFC 5545.\r\n  const intermediateNs = GetEpochNanosecondsFor(timeZone, dtIntermediate, 'compatible');\r\n  return AddInstant(intermediateNs, duration.time);\r\n}\r\n\r\ntype AddSubtractOperation = 'add' | 'subtract';\r\n\r\nexport function AddDurations(\r\n  operation: AddSubtractOperation,\r\n  duration: Temporal.Duration,\r\n  otherParam: DurationParams['add'][0]\r\n) {\r\n  let other = ToTemporalDuration(otherParam);\r\n  if (operation === 'subtract') other = CreateNegatedTemporalDuration(other);\r\n\r\n  const largestUnit1 = DefaultTemporalLargestUnit(duration);\r\n  const largestUnit2 = DefaultTemporalLargestUnit(other);\r\n  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\r\n  if (IsCalendarUnit(largestUnit)) {\r\n    throw new RangeError('For years, months, or weeks arithmetic, use date arithmetic relative to a starting point');\r\n  }\r\n\r\n  const d1 = ToInternalDurationRecordWith24HourDays(duration);\r\n  const d2 = ToInternalDurationRecordWith24HourDays(other);\r\n  const result = CombineDateAndTimeDuration(ZeroDateDuration(), d1.time.add(d2.time));\r\n  return TemporalDurationFromInternal(result, largestUnit);\r\n}\r\n\r\nexport function AddDurationToInstant(\r\n  operation: AddSubtractOperation,\r\n  instant: Temporal.Instant,\r\n  durationLike: InstantParams['add'][0]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const largestUnit = DefaultTemporalLargestUnit(duration);\r\n  if (TemporalUnitCategory(largestUnit) === 'date') {\r\n    throw new RangeError(\r\n      `Duration field ${largestUnit} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`\r\n    );\r\n  }\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n  const ns = AddInstant(GetSlot(instant, EPOCHNANOSECONDS), internalDuration.time);\r\n  return CreateTemporalInstant(ns);\r\n}\r\n\r\nexport function AddDurationToDate(\r\n  operation: AddSubtractOperation,\r\n  plainDate: Temporal.PlainDate,\r\n  durationLike: PlainDateParams['add'][0],\r\n  options: PlainDateParams['add'][1]\r\n) {\r\n  const calendar = GetSlot(plainDate, CALENDAR);\r\n\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const dateDuration = ToDateDurationRecordWithoutTime(duration);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n\r\n  const addedDate = CalendarDateAdd(calendar, GetSlot(plainDate, ISO_DATE), dateDuration, overflow);\r\n  return CreateTemporalDate(addedDate, calendar);\r\n}\r\n\r\nexport function AddDurationToDateTime(\r\n  operation: AddSubtractOperation,\r\n  dateTime: Temporal.PlainDateTime,\r\n  durationLike: PlainDateTimeParams['add'][0],\r\n  options: PlainDateTimeParams['add'][1]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n\r\n  const calendar = GetSlot(dateTime, CALENDAR);\r\n\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n\r\n  // Add the time part\r\n  const isoDateTime = GetSlot(dateTime, ISO_DATE_TIME);\r\n  const timeResult = AddTime(isoDateTime.time, internalDuration.time);\r\n  const dateDuration = AdjustDateDurationRecord(internalDuration.date, timeResult.deltaDays);\r\n\r\n  // Delegate the date part addition to the calendar\r\n  RejectDuration(dateDuration.years, dateDuration.months, dateDuration.weeks, dateDuration.days, 0, 0, 0, 0, 0, 0);\r\n  const addedDate = CalendarDateAdd(calendar, isoDateTime.isoDate, dateDuration, overflow);\r\n\r\n  const result = CombineISODateAndTimeRecord(addedDate, timeResult);\r\n  return CreateTemporalDateTime(result, calendar);\r\n}\r\n\r\nexport function AddDurationToTime(\r\n  operation: AddSubtractOperation,\r\n  temporalTime: Temporal.PlainTime,\r\n  durationLike: PlainTimeParams['add'][0]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n  const { hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\r\n    GetSlot(temporalTime, TIME),\r\n    internalDuration.time\r\n  );\r\n  const time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject');\r\n  return CreateTemporalTime(time);\r\n}\r\n\r\nexport function AddDurationToYearMonth(\r\n  operation: AddSubtractOperation,\r\n  yearMonth: Temporal.PlainYearMonth,\r\n  durationLike: PlainYearMonthParams['add'][0],\r\n  options: PlainYearMonthParams['add'][1]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n  const sign = DurationSign(duration);\r\n\r\n  const calendar = GetSlot(yearMonth, CALENDAR);\r\n  const fields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\r\n  fields.day = 1;\r\n  let startDate = CalendarDateFromFields(calendar, fields, 'constrain');\r\n  if (sign < 0) {\r\n    const nextMonth = CalendarDateAdd(calendar, startDate, { months: 1 }, 'constrain');\r\n    startDate = BalanceISODate(nextMonth.year, nextMonth.month, nextMonth.day - 1);\r\n  }\r\n  const durationToAdd = ToDateDurationRecordWithoutTime(duration);\r\n  RejectDateRange(startDate);\r\n  const addedDate = CalendarDateAdd(calendar, startDate, durationToAdd, overflow);\r\n  const addedDateFields = ISODateToFields(calendar, addedDate, 'year-month');\r\n\r\n  const isoDate = CalendarYearMonthFromFields(calendar, addedDateFields, overflow);\r\n  return CreateTemporalYearMonth(isoDate, calendar);\r\n}\r\n\r\nexport function AddDurationToZonedDateTime(\r\n  operation: AddSubtractOperation,\r\n  zonedDateTime: Temporal.ZonedDateTime,\r\n  durationLike: ZonedDateTimeParams['add'][0],\r\n  options: ZonedDateTimeParams['add'][1]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n  const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\r\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\r\n  const internalDuration = ToInternalDurationRecord(duration);\r\n  const epochNanoseconds = AddZonedDateTime(\r\n    GetSlot(zonedDateTime, EPOCHNANOSECONDS),\r\n    timeZone,\r\n    calendar,\r\n    internalDuration,\r\n    overflow\r\n  );\r\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function RoundNumberToIncrement(quantity: number, increment: number, mode: Temporal.RoundingMode) {\r\n  const quotient = Math.trunc(quantity / increment);\r\n  const remainder = quantity % increment;\r\n  const sign = quantity < 0 ? 'negative' : 'positive';\r\n  const r1 = Math.abs(quotient);\r\n  const r2 = r1 + 1;\r\n  const cmp = ComparisonResult(Math.abs(remainder * 2) - increment);\r\n  const even = r1 % 2 === 0;\r\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\r\n  const rounded = remainder === 0 ? r1 : ApplyUnsignedRoundingMode(r1, r2, cmp, even, unsignedRoundingMode);\r\n  return increment * (sign === 'positive' ? rounded : -rounded);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function RoundNumberToIncrementAsIfPositive(\r\n  quantityParam: JSBI | bigint,\r\n  incrementParam: JSBI | bigint,\r\n  mode: Temporal.RoundingMode\r\n) {\r\n  const quantity = ensureJSBI(quantityParam);\r\n  const increment = ensureJSBI(incrementParam);\r\n  const quotient = JSBI.divide(quantity, increment);\r\n  const remainder = JSBI.remainder(quantity, increment);\r\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, 'positive');\r\n  let r1: JSBI, r2: JSBI;\r\n  if (JSBI.lessThan(quantity, ZERO)) {\r\n    r1 = JSBI.subtract(quotient, ONE);\r\n    r2 = quotient;\r\n  } else {\r\n    r1 = quotient;\r\n    r2 = JSBI.add(quotient, ONE);\r\n  }\r\n  // Similar to the comparison in RoundNumberToIncrement, but multiplied by an\r\n  // extra sign to make sure we treat it as positive\r\n  const cmp = (compare(abs(JSBI.multiply(remainder, TWO)), increment) * (JSBI.lessThan(quantity, ZERO) ? -1 : 1) +\r\n    0) as -1 | 0 | 1;\r\n  const rounded = JSBI.equal(remainder, ZERO)\r\n    ? quotient\r\n    : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(r1), unsignedRoundingMode);\r\n  return JSBI.multiply(rounded, increment);\r\n}\r\n\r\nexport function RoundTemporalInstant(\r\n  epochNs: JSBI,\r\n  increment: number,\r\n  unit: TimeUnitOrDay,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  const incrementNs = NS_PER_TIME_UNIT[unit] * increment;\r\n  return RoundNumberToIncrementAsIfPositive(epochNs, JSBI.BigInt(incrementNs), roundingMode);\r\n}\r\n\r\nexport function RoundISODateTime(\r\n  isoDateTime: ISODateTime,\r\n  increment: number,\r\n  unit: UnitSmallerThanOrEqualTo<'day'>,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  AssertISODateTimeWithinLimits(isoDateTime);\r\n  const { year, month, day } = isoDateTime.isoDate;\r\n  const time = RoundTime(isoDateTime.time, increment, unit, roundingMode);\r\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\r\n  return CombineISODateAndTimeRecord(isoDate, time);\r\n}\r\n\r\nexport function RoundTime(\r\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\r\n  increment: number,\r\n  unit: TimeUnitOrDay,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  let quantity;\r\n  switch (unit) {\r\n    case 'day':\r\n    case 'hour':\r\n      quantity = ((((hour * 60 + minute) * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'minute':\r\n      quantity = (((minute * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'second':\r\n      quantity = ((second * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'millisecond':\r\n      quantity = (millisecond * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'microsecond':\r\n      quantity = microsecond * 1000 + nanosecond;\r\n      break;\r\n    case 'nanosecond':\r\n      quantity = nanosecond;\r\n  }\r\n  const nsPerUnit = NS_PER_TIME_UNIT[unit];\r\n  const result = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode) / nsPerUnit;\r\n  switch (unit) {\r\n    case 'day':\r\n      return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\r\n    case 'hour':\r\n      return BalanceTime(result, 0, 0, 0, 0, 0);\r\n    case 'minute':\r\n      return BalanceTime(hour, result, 0, 0, 0, 0);\r\n    case 'second':\r\n      return BalanceTime(hour, minute, result, 0, 0, 0);\r\n    case 'millisecond':\r\n      return BalanceTime(hour, minute, second, result, 0, 0);\r\n    case 'microsecond':\r\n      return BalanceTime(hour, minute, second, millisecond, result, 0);\r\n    case 'nanosecond':\r\n      return BalanceTime(hour, minute, second, millisecond, microsecond, result);\r\n    default:\r\n      throw new Error(`Invalid unit ${unit}`);\r\n  }\r\n}\r\n\r\nexport function RoundTimeDuration(\r\n  timeDuration: TimeDuration,\r\n  increment: number,\r\n  unit: Temporal.TimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be a time unit\r\n  const divisor = NS_PER_TIME_UNIT[unit];\r\n  return timeDuration.round(JSBI.BigInt(divisor * increment), roundingMode);\r\n}\r\n\r\nexport function TotalTimeDuration(timeDuration: TimeDuration, unit: TimeUnitOrDay) {\r\n  const divisor = NS_PER_TIME_UNIT[unit];\r\n  return timeDuration.fdiv(JSBI.BigInt(divisor));\r\n}\r\n\r\nexport function CompareISODate(isoDate1: ISODate, isoDate2: ISODate) {\r\n  if (isoDate1.year !== isoDate2.year) return ComparisonResult(isoDate1.year - isoDate2.year);\r\n  if (isoDate1.month !== isoDate2.month) return ComparisonResult(isoDate1.month - isoDate2.month);\r\n  if (isoDate1.day !== isoDate2.day) return ComparisonResult(isoDate1.day - isoDate2.day);\r\n  return 0;\r\n}\r\n\r\nexport function CompareTimeRecord(time1: TimeRecord, time2: TimeRecord) {\r\n  if (time1.hour !== time2.hour) return ComparisonResult(time1.hour - time2.hour);\r\n  if (time1.minute !== time2.minute) return ComparisonResult(time1.minute - time2.minute);\r\n  if (time1.second !== time2.second) return ComparisonResult(time1.second - time2.second);\r\n  if (time1.millisecond !== time2.millisecond) return ComparisonResult(time1.millisecond - time2.millisecond);\r\n  if (time1.microsecond !== time2.microsecond) return ComparisonResult(time1.microsecond - time2.microsecond);\r\n  if (time1.nanosecond !== time2.nanosecond) return ComparisonResult(time1.nanosecond - time2.nanosecond);\r\n  return 0;\r\n}\r\n\r\nexport function CompareISODateTime(isoDateTime1: ISODateTime, isoDateTime2: ISODateTime) {\r\n  const dateResult = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\r\n  if (dateResult !== 0) return dateResult;\r\n  return CompareTimeRecord(isoDateTime1.time, isoDateTime2.time);\r\n}\r\n\r\n// Defaults to native bigint, or something \"native bigint-like\".\r\n// For users of Temporal that are running in environments without native BigInt,\r\n// the only guarantee we should give is that the returned object's toString will\r\n// return a string containing an accurate base 10 value of this bigint. This\r\n// form factor should correctly interop with other bigint compat libraries\r\n// easily.\r\ntype ExternalBigInt = bigint;\r\n\r\nexport function ToBigIntExternal(arg: unknown): ExternalBigInt {\r\n  const jsbiBI = ToBigInt(arg);\r\n  if (typeof (globalThis as any).BigInt !== 'undefined') return (globalThis as any).BigInt(jsbiBI.toString(10));\r\n  return jsbiBI as unknown as ExternalBigInt;\r\n}\r\n\r\n// rounding modes supported: floor, ceil, trunc\r\nexport function epochNsToMs(epochNanosecondsParam: JSBI | bigint, mode: 'floor' | 'ceil' | 'trunc') {\r\n  const epochNanoseconds = ensureJSBI(epochNanosecondsParam);\r\n  const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\r\n  let epochMilliseconds = JSBI.toNumber(quotient);\r\n  if (mode === 'floor' && JSBI.toNumber(remainder) < 0) epochMilliseconds -= 1;\r\n  if (mode === 'ceil' && JSBI.toNumber(remainder) > 0) epochMilliseconds += 1;\r\n  return epochMilliseconds;\r\n}\r\n\r\nexport function epochMsToNs(epochMilliseconds: number) {\r\n  if (!Number.isInteger(epochMilliseconds)) throw new RangeError('epoch milliseconds must be an integer');\r\n  return JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\r\n}\r\n\r\nexport function ToBigInt(arg: unknown): JSBI {\r\n  let prim = arg;\r\n  if (typeof arg === 'object') {\r\n    const toPrimFn = (arg as { [Symbol.toPrimitive]: unknown })[Symbol.toPrimitive];\r\n    if (toPrimFn && typeof toPrimFn === 'function') {\r\n      prim = toPrimFn.call(arg, 'number');\r\n    }\r\n  }\r\n\r\n  // The AO ToBigInt throws on numbers because it does not allow implicit\r\n  // conversion between number and bigint (unlike the bigint constructor).\r\n  if (typeof prim === 'number') {\r\n    throw new TypeError('cannot convert number to bigint');\r\n  }\r\n  if (typeof prim === 'bigint') {\r\n    // JSBI doesn't know anything about the bigint type, and intentionally\r\n    // assumes it doesn't exist. Passing one to the BigInt function will throw\r\n    // an error.\r\n    return JSBI.BigInt(prim.toString(10));\r\n  }\r\n  // JSBI will properly coerce types into a BigInt the same as the native BigInt\r\n  // constructor will, with the exception of native bigint which is handled\r\n  // above.\r\n  // As of 2023-04-07, the only runtime type that neither of those can handle is\r\n  // 'symbol', and both native bigint and the JSBI.BigInt function will throw an\r\n  // error if they are given a Symbol.\r\n  return JSBI.BigInt(prim as string | boolean | object);\r\n}\r\n\r\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\r\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\r\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\r\nexport const SystemUTCEpochNanoSeconds: () => JSBI = (() => {\r\n  let ns = JSBI.BigInt(Date.now() % 1e6);\r\n  return () => {\r\n    const now = Date.now();\r\n    const ms = JSBI.BigInt(now);\r\n    const result = JSBI.add(epochMsToNs(now), ns);\r\n    ns = JSBI.remainder(ms, MILLION);\r\n    if (JSBI.greaterThan(result, NS_MAX)) return NS_MAX;\r\n    if (JSBI.lessThan(result, NS_MIN)) return NS_MIN;\r\n    return result;\r\n  };\r\n})();\r\n\r\nexport function DefaultTimeZone() {\r\n  return new Intl.DateTimeFormat().resolvedOptions().timeZone;\r\n}\r\n\r\nexport function ComparisonResult(value: number) {\r\n  return value < 0 ? -1 : value > 0 ? 1 : (value as 0);\r\n}\r\n\r\nexport function GetOptionsObject<T>(options: T) {\r\n  if (options === undefined) return Object.create(null) as NonNullable<T>;\r\n  if (IsObject(options) && options !== null) return options;\r\n  throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\r\n}\r\n\r\nexport function CreateOnePropObject<K extends string, V>(propName: K, propValue: V): { [k in K]: V } {\r\n  const o = Object.create(null);\r\n  o[propName] = propValue;\r\n  return o;\r\n}\r\n\r\ntype StringlyTypedKeys<T> = Exclude<keyof T, symbol | number>;\r\nfunction GetOption<P extends StringlyTypedKeys<O>, O extends Partial<Record<P, unknown>>>(\r\n  options: O,\r\n  property: P,\r\n  allowedValues: ReadonlyArray<O[P]>,\r\n  fallback: undefined\r\n): O[P];\r\nfunction GetOption<\r\n  P extends StringlyTypedKeys<O>,\r\n  O extends Partial<Record<P, unknown>>,\r\n  Fallback extends Required<O>[P] | typeof REQUIRED | undefined\r\n>(\r\n  options: O,\r\n  property: P,\r\n  allowedValues: ReadonlyArray<O[P]>,\r\n  fallback: Fallback\r\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P];\r\nfunction GetOption<\r\n  P extends StringlyTypedKeys<O>,\r\n  O extends Partial<Record<P, unknown>>,\r\n  Fallback extends Required<O>[P] | undefined\r\n>(\r\n  options: O,\r\n  property: P,\r\n  allowedValues: ReadonlyArray<O[P]>,\r\n  fallback: O[P]\r\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P] {\r\n  let value = options[property];\r\n  if (value !== undefined) {\r\n    value = ToString(value) as O[P];\r\n    if (!allowedValues.includes(value)) {\r\n      throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\r\n    }\r\n    return value;\r\n  }\r\n  if (fallback === REQUIRED) throw new RangeError(`${property} option is required`);\r\n  return fallback;\r\n}\r\n\r\n// This is a temporary implementation. Ideally we'd rely on Intl.DateTimeFormat\r\n// here, to provide the latest CLDR alias data, when implementations catch up to\r\n// the ECMA-402 change. The aliases below are taken from\r\n// https://github.com/unicode-org/cldr/blob/main/common/bcp47/calendar.xml\r\nexport function CanonicalizeCalendar(idParam: string): BuiltinCalendarId {\r\n  const id = ASCIILowercase(idParam);\r\n\r\n  if (!BUILTIN_CALENDAR_IDS.includes(ASCIILowercase(id))) {\r\n    throw new RangeError(`invalid calendar identifier ${id}`);\r\n  }\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(id, 'above code throws out any non-calendar IDs');\r\n\r\n  switch (id) {\r\n    case 'ethiopic-amete-alem':\r\n      // May need to be removed in the future.\r\n      // See https://github.com/tc39/ecma402/issues/285\r\n      return 'ethioaa';\r\n    // case 'gregorian':\r\n    // (Skip 'gregorian'. It isn't a valid identifier as it's a single\r\n    // subcomponent longer than 8 letters. It can only be used with the old\r\n    // @key=value syntax.)\r\n    case 'islamicc':\r\n      return 'islamic-civil';\r\n  }\r\n  return id;\r\n}\r\n\r\nfunction ASCIILowercase<T extends string>(str: T): T {\r\n  // The spec defines this operation distinct from String.prototype.lowercase,\r\n  // so we'll follow the spec here. Note that nasty security issues that can\r\n  // happen for some use cases if you're comparing case-modified non-ASCII\r\n  // values. For example, Turkish's \"I\" character was the source of a security\r\n  // issue involving \"file://\" URLs. See\r\n  // https://haacked.com/archive/2012/07/05/turkish-i-problem-and-why-you-should-care.aspx/.\r\n  let lowercase = '';\r\n  for (let ix = 0; ix < str.length; ix++) {\r\n    const code = str.charCodeAt(ix);\r\n    if (code >= 0x41 && code <= 0x5a) {\r\n      lowercase += String.fromCharCode(code + 0x20);\r\n    } else {\r\n      lowercase += String.fromCharCode(code);\r\n    }\r\n  }\r\n  return lowercase as T;\r\n}\r\n\r\n// This function isn't in the spec, but we put it in the polyfill to avoid\r\n// repeating the same (long) error message in many files.\r\nexport function ValueOfThrows(constructorName: string): never {\r\n  const compareCode =\r\n    constructorName === 'PlainMonthDay'\r\n      ? 'Temporal.PlainDate.compare(obj1.toPlainDate(year), obj2.toPlainDate(year))'\r\n      : `Temporal.${constructorName}.compare(obj1, obj2)`;\r\n\r\n  throw new TypeError(\r\n    'Do not use built-in arithmetic operators with Temporal objects. ' +\r\n      `When comparing, use ${compareCode}, not obj1 > obj2. ` +\r\n      \"When coercing to strings, use `${obj}` or String(obj), not '' + obj. \" +\r\n      'When coercing to numbers, use properties or methods of the object, not `+obj`. ' +\r\n      'When concatenating with strings, use `${str}${obj}` or str.concat(obj), not str + obj. ' +\r\n      'In React, coerce to a string before rendering a Temporal object.'\r\n  );\r\n}\r\n\r\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\r\nconst OFFSET_WITH_PARTS = new RegExp(`^${PARSE.offsetWithParts.source}$`);\r\n\r\nfunction bisect(\r\n  getState: (epochMs: number) => number,\r\n  leftParam: number,\r\n  rightParam: number,\r\n  lstateParam = getState(leftParam),\r\n  rstateParam = getState(rightParam)\r\n) {\r\n  let left = leftParam;\r\n  let right = rightParam;\r\n  let lstate = lstateParam;\r\n  let rstate = rstateParam;\r\n  while (right - left > 1) {\r\n    let middle = Math.trunc((left + right) / 2);\r\n    const mstate = getState(middle);\r\n    if (mstate === lstate) {\r\n      left = middle;\r\n      lstate = mstate;\r\n    } else if (mstate === rstate) {\r\n      right = middle;\r\n      rstate = mstate;\r\n    } else {\r\n      /* c8 ignore next */ assertNotReached(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\r\n    }\r\n  }\r\n  return right;\r\n}\r\n","import * as ES from './ecmascript';\r\nimport { DefineIntrinsic } from './intrinsicclass';\r\nimport type { Temporal } from '..';\r\nimport type {\r\n  BuiltinCalendarId,\r\n  CalendarDateRecord,\r\n  CalendarFieldsRecord,\r\n  CalendarYMD,\r\n  DateDuration,\r\n  FieldKey,\r\n  ISODate,\r\n  ISODateToFieldsType,\r\n  MonthDayFromFieldsObject,\r\n  Overflow,\r\n  Resolve\r\n} from './internaltypes';\r\n\r\nfunction arrayFromSet<T>(src: Set<T>): T[] {\r\n  return [...src];\r\n}\r\n\r\nfunction calendarDateWeekOfYear(id: BuiltinCalendarId, isoDate: ISODate): { week: number; year: number } | undefined {\r\n  // Supports only ISO8601 calendar; can be updated to add support for other calendars.\r\n  // Returns undefined for calendars without a well-defined week calendar system.\r\n  // eslint-disable-next-line max-len\r\n  // Also see: https://github.com/unicode-org/icu/blob/ab72ab1d4a3c3f9beeb7d92b0c7817ca93dfdb04/icu4c/source/i18n/calendar.cpp#L1606\r\n  if (id !== 'iso8601') return undefined;\r\n  const calendar = impl[id];\r\n  let yow = isoDate.year;\r\n  const { dayOfWeek, dayOfYear, daysInYear } = calendar.isoToDate(isoDate, {\r\n    dayOfWeek: true,\r\n    dayOfYear: true,\r\n    daysInYear: true\r\n  });\r\n  const fdow = calendar.getFirstDayOfWeek();\r\n  const mdow = calendar.getMinimalDaysInFirstWeek();\r\n  ES.uncheckedAssertNarrowedType<number>(fdow, 'guaranteed to exist for iso8601');\r\n  ES.uncheckedAssertNarrowedType<number>(mdow, 'guaranteed to exist for iso8601');\r\n\r\n  // For both the input date and the first day of its calendar year, calculate the day of week\r\n  // relative to first day of week in the relevant calendar (e.g., in iso8601, relative to Monday).\r\n  let relDow = (dayOfWeek + 7 - fdow) % 7;\r\n  // Assuming the year length is less than 7000 days.\r\n  let relDowJan1 = (dayOfWeek - dayOfYear + 7001 - fdow) % 7;\r\n\r\n  let woy = Math.floor((dayOfYear - 1 + relDowJan1) / 7);\r\n  if (7 - relDowJan1 >= mdow) {\r\n    ++woy;\r\n  }\r\n\r\n  // Adjust for weeks at the year end that overlap into the previous or next calendar year.\r\n  if (woy == 0) {\r\n    // Check for last week of previous year; if true, handle the case for\r\n    // first week of next year\r\n    const prevYearCalendar = calendar.isoToDate(calendar.dateAdd(isoDate, { years: -1 }, 'constrain'), {\r\n      daysInYear: true\r\n    });\r\n    let prevDoy = dayOfYear + prevYearCalendar.daysInYear;\r\n    woy = weekNumber(fdow, mdow, prevDoy, dayOfWeek);\r\n    yow--;\r\n  } else {\r\n    // For it to be week 1 of the next year, dayOfYear must be >= lastDoy - 5\r\n    //          L-5                  L\r\n    // doy: 359 360 361 362 363 364 365 001\r\n    // dow:      1   2   3   4   5   6   7\r\n    let lastDoy = daysInYear;\r\n    if (dayOfYear >= lastDoy - 5) {\r\n      let lastRelDow = (relDow + lastDoy - dayOfYear) % 7;\r\n      if (lastRelDow < 0) {\r\n        lastRelDow += 7;\r\n      }\r\n      if (6 - lastRelDow >= mdow && dayOfYear + 7 - relDow > lastDoy) {\r\n        woy = 1;\r\n        yow++;\r\n      }\r\n    }\r\n  }\r\n  return { week: woy, year: yow };\r\n}\r\n\r\nfunction ISODateSurpasses(sign: -1 | 0 | 1, y1: number, m1: number, d1: number, isoDate2: ISODate) {\r\n  if (y1 !== isoDate2.year) {\r\n    if (sign * (y1 - isoDate2.year) > 0) return true;\r\n  } else if (m1 !== isoDate2.month) {\r\n    if (sign * (m1 - isoDate2.month) > 0) return true;\r\n  } else if (d1 !== isoDate2.day) {\r\n    if (sign * (d1 - isoDate2.day) > 0) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\ntype ResolveFieldsReturn<Type extends ISODateToFieldsType> = Resolve<\r\n  CalendarFieldsRecord & {\r\n    year: Type extends 'date' ? number : never;\r\n    month: number;\r\n    monthCode: string;\r\n    day: number;\r\n  }\r\n>;\r\n\r\n/**\r\n * Shape of internal implementation of each built-in calendar. Note that\r\n * parameter types are simpler than CalendarProtocol because the `Calendar`\r\n * class performs validation and parameter normalization before handing control\r\n * over to CalendarImpl.\r\n *\r\n * There are two instances of this interface: one for the ISO calendar and\r\n * another that handles logic that's the same across all non-ISO calendars. The\r\n * latter is cloned for each non-ISO calendar at the end of this file.\r\n */\r\nexport interface CalendarImpl {\r\n  isoToDate<\r\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\r\n    T extends {\r\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\r\n    }\r\n  >(\r\n    isoDate: ISODate,\r\n    requestedFields: Request\r\n  ): T;\r\n  getFirstDayOfWeek(): number | undefined;\r\n  getMinimalDaysInFirstWeek(): number | undefined;\r\n  resolveFields<Type extends ISODateToFieldsType>(\r\n    fields: CalendarFieldsRecord,\r\n    type: Type\r\n  ): asserts fields is ResolveFieldsReturn<Type>;\r\n  dateToISO(fields: ResolveFieldsReturn<'date'>, overflow: Overflow): ISODate;\r\n  monthDayToISOReferenceDate(fields: ResolveFieldsReturn<'month-day'>, overflow: Overflow): ISODate;\r\n  dateAdd(date: ISODate, duration: Partial<DateDuration>, overflow: Overflow): ISODate;\r\n  dateUntil(one: ISODate, two: ISODate, largestUnit: 'year' | 'month' | 'week' | 'day'): DateDuration;\r\n  extraFields(fields: FieldKey[]): FieldKey[];\r\n  fieldKeysToIgnore(keys: FieldKey[]): FieldKey[];\r\n}\r\n\r\ntype CalendarImplementations = {\r\n  [k in BuiltinCalendarId]: CalendarImpl;\r\n};\r\n\r\n/**\r\n * Implementations for each calendar.\r\n * Registration for each of these calendars happens throughout this file. The ISO and non-ISO calendars are registered\r\n * separately - look for 'iso8601' for the ISO calendar registration, and all non-ISO calendar registrations happens\r\n * at the bottom of the file.\r\n */\r\nconst impl: CalendarImplementations = {} as unknown as CalendarImplementations;\r\n\r\n/**\r\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\r\n * guaranteed to be supported by all ECMAScript implementations, including those\r\n * without Intl (ECMA-402) support.\r\n */\r\nimpl['iso8601'] = {\r\n  resolveFields(fields, type) {\r\n    if ((type === 'date' || type === 'year-month') && fields.year === undefined) {\r\n      throw new TypeError('year is required');\r\n    }\r\n    if ((type === 'date' || type === 'month-day') && fields.day === undefined) {\r\n      throw new TypeError('day is required');\r\n    }\r\n    Object.assign(fields, resolveNonLunisolarMonth(fields));\r\n  },\r\n  dateToISO(fields, overflow) {\r\n    return ES.RegulateISODate(fields.year, fields.month, fields.day, overflow);\r\n  },\r\n  monthDayToISOReferenceDate(fields, overflow) {\r\n    const referenceISOYear = 1972;\r\n    const { month, day } = ES.RegulateISODate(fields.year ?? referenceISOYear, fields.month, fields.day, overflow);\r\n    return { month, day, year: referenceISOYear };\r\n  },\r\n  extraFields() {\r\n    return [];\r\n  },\r\n  fieldKeysToIgnore(keys) {\r\n    const result = new Set<FieldKey>();\r\n    for (let ix = 0; ix < keys.length; ix++) {\r\n      const key = keys[ix];\r\n      result.add(key);\r\n      if (key === 'month') {\r\n        result.add('monthCode');\r\n      } else if (key === 'monthCode') {\r\n        result.add('month');\r\n      }\r\n    }\r\n    return arrayFromSet(result);\r\n  },\r\n  dateAdd(isoDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow) {\r\n    let { year, month, day } = isoDate;\r\n    year += years;\r\n    month += months;\r\n    ({ year, month } = ES.BalanceISOYearMonth(year, month));\r\n    ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\r\n    day += days + 7 * weeks;\r\n    return ES.BalanceISODate(year, month, day);\r\n  },\r\n  dateUntil(one, two, largestUnit) {\r\n    const sign = -ES.CompareISODate(one, two);\r\n    if (sign === 0) return { years: 0, months: 0, weeks: 0, days: 0 };\r\n    ES.uncheckedAssertNarrowedType<-1 | 1>(sign, \"the - operator's return type is number\");\r\n\r\n    let years = 0;\r\n    let months = 0;\r\n    let intermediate;\r\n    if (largestUnit === 'year' || largestUnit === 'month') {\r\n      // We can skip right to the neighbourhood of the correct number of years,\r\n      // it'll be at least one less than two.year - one.year (unless it's zero)\r\n      let candidateYears = two.year - one.year;\r\n      if (candidateYears !== 0) candidateYears -= sign;\r\n      // loops at most twice\r\n      while (!ISODateSurpasses(sign, one.year + candidateYears, one.month, one.day, two)) {\r\n        years = candidateYears;\r\n        candidateYears += sign;\r\n      }\r\n\r\n      let candidateMonths = sign;\r\n      intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + candidateMonths);\r\n      // loops at most 12 times\r\n      while (!ISODateSurpasses(sign, intermediate.year, intermediate.month, one.day, two)) {\r\n        months = candidateMonths;\r\n        candidateMonths += sign;\r\n        intermediate = ES.BalanceISOYearMonth(intermediate.year, intermediate.month + sign);\r\n      }\r\n\r\n      if (largestUnit === 'month') {\r\n        months += years * 12;\r\n        years = 0;\r\n      }\r\n    }\r\n\r\n    intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + months);\r\n    const constrained = ES.ConstrainISODate(intermediate.year, intermediate.month, one.day);\r\n\r\n    let weeks = 0;\r\n    let days =\r\n      ES.ISODateToEpochDays(two.year, two.month - 1, two.day) -\r\n      ES.ISODateToEpochDays(constrained.year, constrained.month - 1, constrained.day);\r\n\r\n    if (largestUnit === 'week') {\r\n      weeks = Math.trunc(days / 7);\r\n      days %= 7;\r\n    }\r\n\r\n    return { years, months, weeks, days };\r\n  },\r\n  isoToDate<\r\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\r\n    T extends {\r\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\r\n    }\r\n  >({ year, month, day }: ISODate, requestedFields: Request): T {\r\n    // requestedFields parameter is not part of the spec text. It's an\r\n    // illustration of one way implementations may choose to optimize this\r\n    // operation.\r\n    const date: Partial<CalendarDateRecord> = {\r\n      era: undefined,\r\n      eraYear: undefined,\r\n      year,\r\n      month,\r\n      day,\r\n      daysInWeek: 7,\r\n      monthsInYear: 12\r\n    };\r\n    if (requestedFields.monthCode) date.monthCode = buildMonthCode(month);\r\n    if (requestedFields.dayOfWeek) {\r\n      // https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Disparate_variation\r\n      const shiftedMonth = month + (month < 3 ? 10 : -2);\r\n      const shiftedYear = year - (month < 3 ? 1 : 0);\r\n\r\n      const century = Math.floor(shiftedYear / 100);\r\n      const yearInCentury = shiftedYear - century * 100;\r\n\r\n      const monthTerm = Math.floor(2.6 * shiftedMonth - 0.2);\r\n      const yearTerm = yearInCentury + Math.floor(yearInCentury / 4);\r\n      const centuryTerm = Math.floor(century / 4) - 2 * century;\r\n\r\n      const dow = (day + monthTerm + yearTerm + centuryTerm) % 7;\r\n\r\n      date.dayOfWeek = dow + (dow <= 0 ? 7 : 0);\r\n    }\r\n    if (requestedFields.dayOfYear) {\r\n      let days = day;\r\n      for (let m = month - 1; m > 0; m--) {\r\n        days += ES.ISODaysInMonth(year, m);\r\n      }\r\n      date.dayOfYear = days;\r\n    }\r\n    if (requestedFields.weekOfYear) date.weekOfYear = calendarDateWeekOfYear('iso8601', { year, month, day });\r\n    if (requestedFields.daysInMonth) date.daysInMonth = ES.ISODaysInMonth(year, month);\r\n    if (requestedFields.daysInYear || requestedFields.inLeapYear) {\r\n      date.inLeapYear = ES.LeapYear(year);\r\n      date.daysInYear = date.inLeapYear ? 366 : 365;\r\n    }\r\n    return date as T;\r\n  },\r\n  getFirstDayOfWeek() {\r\n    return 1;\r\n  },\r\n  getMinimalDaysInFirstWeek() {\r\n    return 4;\r\n  }\r\n};\r\n\r\n// Note: Built-in calendars other than iso8601 are not part of the Temporal\r\n// proposal for ECMA-262. These calendars will be standardized as part of\r\n// ECMA-402. Code below here includes an implementation of these calendars to\r\n// validate the Temporal API and to get feedback. However, native non-ISO\r\n// calendar behavior is at least somewhat implementation-defined, so may not\r\n// match this polyfill's output exactly.\r\n//\r\n// Some ES implementations don't include ECMA-402. For this reason, it's helpful\r\n// to ensure a clean separation between the ISO calendar implementation which is\r\n// a part of ECMA-262 and the non-ISO calendar implementation which requires\r\n// ECMA-402.\r\n//\r\n// To ensure this separation, the implementation is split. A `CalendarImpl`\r\n// interface defines the common operations between both ISO and non-ISO\r\n// calendars.\r\n\r\n/**\r\n * This type is passed through from CalendarImpl#dateFromFields().\r\n * `monthExtra` is additional information used internally to identify lunisolar leap months.\r\n */\r\ntype CalendarDateFields = CalendarFieldsRecord & { monthExtra?: string };\r\n\r\n/**\r\n * This is a \"fully populated\" calendar date record. It's only lacking\r\n * `era`/`eraYear` (which may not be present in all calendars) and `monthExtra`\r\n * which is only used in some cases.\r\n */\r\ntype FullCalendarDate = {\r\n  era?: string;\r\n  eraYear?: number;\r\n  year: number;\r\n  month: number;\r\n  monthCode: string;\r\n  day: number;\r\n  monthExtra?: string;\r\n};\r\n\r\n// The types below are various subsets of calendar dates\r\ntype CalendarYM = { year: number; month: number };\r\ntype CalendarYearOnly = { year: number };\r\ntype EraAndEraYear = { era: string; eraYear: number };\r\n\r\nfunction nonLeapMonthCodeNumberPart(monthCode: string) {\r\n  if (!monthCode.startsWith('M')) {\r\n    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\r\n  }\r\n  const month = +monthCode.slice(1);\r\n  if (Number.isNaN(month)) throw new RangeError(`Invalid month code: ${monthCode}`);\r\n  return month;\r\n}\r\n\r\nfunction buildMonthCode(month: number, leap = false) {\r\n  const digitPart = `${month}`.padStart(2, '0');\r\n  const leapMarker = leap ? 'L' : '';\r\n  return `M${digitPart}${leapMarker}`;\r\n}\r\n\r\n/**\r\n * Safely merge a month, monthCode pair into an integer month.\r\n * If both are present, make sure they match.\r\n * This logic doesn't work for lunisolar calendars!\r\n * */\r\nfunction resolveNonLunisolarMonth<T extends { monthCode?: string; month?: number }>(\r\n  calendarDate: T,\r\n  overflow: Overflow | undefined = undefined,\r\n  monthsPerYear = 12\r\n) {\r\n  let { month, monthCode } = calendarDate;\r\n  if (monthCode === undefined) {\r\n    if (month === undefined) throw new TypeError('Either month or monthCode are required');\r\n    // The ISO calendar uses the default (undefined) value because it does\r\n    // constrain/reject after this method returns. Non-ISO calendars, however,\r\n    // rely on this function to constrain/reject out-of-range `month` values.\r\n    if (overflow === 'reject') ES.RejectToRange(month, 1, monthsPerYear);\r\n    if (overflow === 'constrain') month = ES.ConstrainToRange(month, 1, monthsPerYear);\r\n    monthCode = buildMonthCode(month);\r\n  } else {\r\n    const numberPart = nonLeapMonthCodeNumberPart(monthCode);\r\n    if (monthCode !== buildMonthCode(numberPart)) {\r\n      throw new RangeError(`Invalid month code: ${monthCode}`);\r\n    }\r\n    if (month !== undefined && month !== numberPart) {\r\n      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\r\n    }\r\n    month = numberPart;\r\n    if (month < 1 || month > monthsPerYear) throw new RangeError(`Invalid monthCode: ${monthCode}`);\r\n  }\r\n  return { ...calendarDate, month, monthCode };\r\n}\r\n\r\nfunction weekNumber(firstDayOfWeek: number, minimalDaysInFirstWeek: number, desiredDay: number, dayOfWeek: number) {\r\n  let periodStartDayOfWeek = (dayOfWeek - firstDayOfWeek - desiredDay + 1) % 7;\r\n  if (periodStartDayOfWeek < 0) periodStartDayOfWeek += 7;\r\n  let weekNo = Math.floor((desiredDay + periodStartDayOfWeek - 1) / 7);\r\n  if (7 - periodStartDayOfWeek >= minimalDaysInFirstWeek) {\r\n    ++weekNo;\r\n  }\r\n  return weekNo;\r\n}\r\n\r\n/**\r\n * This prototype implementation of non-ISO calendars makes many repeated calls\r\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\r\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\r\n * to a specific Temporal object, which speeds up multiple calendar calls on the\r\n * same Temporal object instance.  No invalidation or pruning is necessary\r\n * because each object's cache is thrown away when the object is GC-ed.\r\n */\r\nclass OneObjectCache {\r\n  map = new Map();\r\n  calls = 0;\r\n  // now = OneObjectCache.monotonicTimestamp();\r\n  hits = 0;\r\n  misses = 0;\r\n\r\n  // static monotonicTimestamp() {\r\n  //   return performance?.now() ?? Date.now();\r\n  // }\r\n\r\n  constructor(cacheToClone?: OneObjectCache) {\r\n    if (cacheToClone !== undefined) {\r\n      let i = 0;\r\n      for (const entry of cacheToClone.map.entries()) {\r\n        if (++i > OneObjectCache.MAX_CACHE_ENTRIES) break;\r\n        this.map.set(...entry);\r\n      }\r\n    }\r\n  }\r\n  get(key: string) {\r\n    const result = this.map.get(key);\r\n    if (result) {\r\n      this.hits++;\r\n      this.report();\r\n    }\r\n    this.calls++;\r\n    return result;\r\n  }\r\n  set(key: string, value: unknown) {\r\n    this.map.set(key, value);\r\n    this.misses++;\r\n    this.report();\r\n  }\r\n  report() {\r\n    // if (this.calls === 0) return;\r\n    // const ms = OneObjectCache.monotonicTimestamp() - this.now;\r\n    // const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\r\n    // const t = `${ms.toFixed(2)}ms`;\r\n    // // eslint-disable-next-line no-console\r\n    // console.log(`${this.calls} calls in ${t}. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\r\n  }\r\n  setObject(obj: ISODate) {\r\n    if (OneObjectCache.objectMap.get(obj)) throw new RangeError('object already cached');\r\n    OneObjectCache.objectMap.set(obj, this);\r\n    this.report();\r\n  }\r\n\r\n  static objectMap = new WeakMap();\r\n  static MAX_CACHE_ENTRIES = 1000;\r\n\r\n  /**\r\n   * Returns a WeakMap-backed cache that's used to store expensive results\r\n   * that are associated with a particular Temporal object instance.\r\n   *\r\n   * @param obj - object to associate with the cache\r\n   */\r\n  static getCacheForObject(obj: ISODate) {\r\n    let cache = OneObjectCache.objectMap.get(obj);\r\n    if (!cache) {\r\n      cache = new OneObjectCache();\r\n      OneObjectCache.objectMap.set(obj, cache);\r\n    }\r\n    return cache;\r\n  }\r\n}\r\n\r\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }: { isoYear: number; isoMonth: number; isoDay: number }) {\r\n  const yearString = ES.ISOYearString(isoYear);\r\n  const monthString = ES.ISODateTimePartString(isoMonth);\r\n  const dayString = ES.ISODateTimePartString(isoDay);\r\n  return `${yearString}-${monthString}-${dayString}T00:00Z`;\r\n}\r\n\r\nfunction simpleDateDiff(one: CalendarYMD, two: CalendarYMD) {\r\n  return {\r\n    years: one.year - two.year,\r\n    months: one.month - two.month,\r\n    days: one.day - two.day\r\n  };\r\n}\r\n\r\n/**\r\n * Implementation helper that's common to all non-ISO calendars\r\n */\r\nabstract class HelperBase {\r\n  abstract id: BuiltinCalendarId;\r\n  abstract monthsInYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): number;\r\n  abstract maximumMonthLength(calendarDate?: CalendarYM): number;\r\n  abstract minimumMonthLength(calendarDate?: CalendarYM): number;\r\n  abstract maxLengthOfMonthCodeInAnyYear(monthCode: string): number;\r\n  abstract estimateIsoDate(calendarDate: CalendarYMD): ISODate;\r\n  abstract inLeapYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): boolean;\r\n  abstract calendarType: 'solar' | 'lunar' | 'lunisolar';\r\n  reviseIntlEra?<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T;\r\n  eras: Era[] = [];\r\n  checkIcuBugs?(isoDate: ISODate): void;\r\n  private formatter?: globalThis.Intl.DateTimeFormat;\r\n  getFormatter() {\r\n    // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\r\n    // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\r\n    // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\r\n    // calendars that are used. Note that the HelperBase class is extended to\r\n    // create each calendar's implementation before any cache is created, so\r\n    // each calendar gets its own separate cached formatter.\r\n    if (typeof this.formatter === 'undefined') {\r\n      this.formatter = new Intl.DateTimeFormat(`en-US-u-ca-${this.id}`, {\r\n        day: 'numeric',\r\n        month: 'numeric',\r\n        year: 'numeric',\r\n        era: 'short',\r\n        timeZone: 'UTC'\r\n      });\r\n    }\r\n    return this.formatter;\r\n  }\r\n  getCalendarParts(isoString: string) {\r\n    let dateTimeFormat = this.getFormatter();\r\n    let legacyDate = new Date(isoString);\r\n\r\n    // PlainDate's minimum date -271821-04-19 is one day beyond legacy Date's\r\n    // minimum -271821-04-20, because of accommodating all Instants in all time\r\n    // zones. If we have -271821-04-19, instead format -271821-04-20 in a time\r\n    // zone that pushes the result into the previous day. This is a slow path\r\n    // because we create a new Intl.DateTimeFormat.\r\n    if (isoString === '-271821-04-19T00:00Z') {\r\n      const options = dateTimeFormat.resolvedOptions();\r\n      dateTimeFormat = new Intl.DateTimeFormat(options.locale, {\r\n        ...(options as Intl.DateTimeFormatOptions),\r\n        timeZone: 'Etc/GMT+1'\r\n      });\r\n      legacyDate = new Date('-271821-04-20T00:00Z');\r\n    }\r\n\r\n    try {\r\n      return dateTimeFormat.formatToParts(legacyDate);\r\n    } catch (e) {\r\n      throw new RangeError(`Invalid ISO date: ${isoString}`);\r\n    }\r\n  }\r\n  isoToCalendarDate(isoDate: ISODate, cache: OneObjectCache): FullCalendarDate {\r\n    const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\r\n    const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\r\n    const cached = cache.get(key);\r\n    if (cached) return cached;\r\n\r\n    const isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\r\n    const parts = this.getCalendarParts(isoString);\r\n    const result: Partial<FullCalendarDate> = {};\r\n    for (let i = 0; i < parts.length; i++) {\r\n      const { type, value } = parts[i];\r\n      // TODO: remove this type annotation when `relatedYear` gets into TS lib types\r\n      if (type === 'year' || type === ('relatedYear' as Intl.DateTimeFormatPartTypes)) {\r\n        if (this.hasEra) {\r\n          result.eraYear = +value;\r\n        } else {\r\n          result.year = +value;\r\n        }\r\n      }\r\n      if (type === 'month') {\r\n        const matches = /^([0-9]*)(.*?)$/.exec(value);\r\n        if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\r\n          throw new RangeError(`Unexpected month: ${value}`);\r\n        }\r\n        // If the month has no numeric part (should only see this for the Hebrew\r\n        // calendar with newer FF / Chromium versions; see\r\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\r\n        // placeholder month index of `1` and rely on the derived class to\r\n        // calculate the correct month index from the month name stored in\r\n        // `monthExtra`.\r\n        result.month = matches[1] ? +matches[1] : 1;\r\n        if (result.month < 1) {\r\n          throw new RangeError(\r\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\r\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)'\r\n          );\r\n        }\r\n        if (result.month > 13) {\r\n          throw new RangeError(\r\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\r\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\r\n          );\r\n        }\r\n\r\n        // The ICU formats for the Hebrew calendar no longer support a numeric\r\n        // month format. So we'll rely on the derived class to interpret it.\r\n        // `monthExtra` is also used on the Chinese calendar to handle a suffix\r\n        // \"bis\" indicating a leap month.\r\n        if (matches[2]) result.monthExtra = matches[2];\r\n      }\r\n      if (type === 'day') result.day = +value;\r\n      if (this.hasEra && type === 'era' && value != null && value !== '') {\r\n        // The convention for Temporal era values is lowercase, so following\r\n        // that convention in this prototype. Punctuation is removed, accented\r\n        // letters are normalized, and spaces are replaced with dashes.\r\n        // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\r\n        // The call to normalize() and the replacement regex deals with era\r\n        // names that contain non-ASCII characters like Japanese eras. Also\r\n        // ignore extra content in parentheses like JPN era date ranges.\r\n        result.era = value\r\n          .split(' (')[0]\r\n          .normalize('NFD')\r\n          .replace(/[^-0-9 \\p{L}]/gu, '')\r\n          .replace(/ /g, '-')\r\n          .toLowerCase();\r\n      }\r\n    }\r\n    if (this.hasEra && result.eraYear === undefined) {\r\n      // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\r\n      // output of Intl.DateTimeFormat.formatToParts.\r\n      throw new RangeError(\r\n        `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\r\n      );\r\n    }\r\n    // Translate old ICU era codes \"ERA0\" etc. into canonical era names.\r\n    if (this.hasEra) {\r\n      const replacement = this.eras.find((e) => result.era === e.genericName);\r\n      if (replacement) result.era = replacement.code;\r\n    }\r\n    // Translate eras that may be handled differently by Temporal vs. by Intl\r\n    // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\r\n    if (this.reviseIntlEra) {\r\n      const { era, eraYear } = this.reviseIntlEra(result, isoDate);\r\n      result.era = era;\r\n      result.eraYear = eraYear;\r\n    }\r\n    if (this.checkIcuBugs) this.checkIcuBugs(isoDate);\r\n\r\n    const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\r\n    if (calendarDate.year === undefined) throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\r\n    if (calendarDate.month === undefined) {\r\n      throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\r\n    }\r\n    if (calendarDate.day === undefined) throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\r\n    cache.set(key, calendarDate);\r\n    // Also cache the reverse mapping\r\n    const cacheReverse = (overflow: Overflow) => {\r\n      const keyReverse = JSON.stringify({\r\n        func: 'calendarToIsoDate',\r\n        year: calendarDate.year,\r\n        month: calendarDate.month,\r\n        day: calendarDate.day,\r\n        overflow,\r\n        id: this.id\r\n      });\r\n      cache.set(keyReverse, isoDate);\r\n    };\r\n    (['constrain', 'reject'] as const).forEach(cacheReverse);\r\n    return calendarDate;\r\n  }\r\n  validateCalendarDate(calendarDate: Partial<FullCalendarDate>): asserts calendarDate is FullCalendarDate {\r\n    const { month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\r\n    // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\r\n    // the derived class must deal with it.\r\n    if (monthExtra !== undefined) throw new RangeError('Unexpected `monthExtra` value');\r\n    if (year === undefined && eraYear === undefined) throw new TypeError('year or eraYear is required');\r\n    if (month === undefined && monthCode === undefined) throw new TypeError('month or monthCode is required');\r\n    if (day === undefined) throw new RangeError('Missing day');\r\n    if (monthCode !== undefined) {\r\n      if (typeof monthCode !== 'string') {\r\n        throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\r\n      }\r\n      if (!/^M([01]?\\d)(L?)$/.test(monthCode)) {\r\n        throw new RangeError(`Invalid monthCode: ${monthCode}`);\r\n      }\r\n    }\r\n    if (this.hasEra) {\r\n      if ((calendarDate['era'] === undefined) !== (calendarDate['eraYear'] === undefined)) {\r\n        throw new TypeError('properties era and eraYear must be provided together');\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Allows derived calendars to add additional fields and/or to make\r\n   * adjustments e.g. to set the era based on the date or to revise the month\r\n   * number in lunisolar calendars per\r\n   * https://github.com/tc39/proposal-temporal/issues/1203.\r\n   *\r\n   * The base implementation fills in missing values by assuming the simplest\r\n   * possible calendar:\r\n   * - no eras\r\n   * - non-lunisolar calendar (no leap months)\r\n   * */\r\n  adjustCalendarDate(\r\n    calendarDateParam: Partial<FullCalendarDate>,\r\n    cache: OneObjectCache | undefined = undefined,\r\n    overflow: Overflow = 'constrain',\r\n    // This param is only used by derived classes\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    fromLegacyDate = false\r\n  ): FullCalendarDate {\r\n    if (this.calendarType === 'lunisolar') throw new RangeError('Override required for lunisolar calendars');\r\n    let calendarDate = calendarDateParam;\r\n    this.validateCalendarDate(calendarDate);\r\n    const largestMonth = this.monthsInYear(calendarDate, cache);\r\n    let { month, monthCode } = calendarDate;\r\n\r\n    ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\r\n    return { ...(calendarDate as typeof calendarDate & CalendarYMD), month, monthCode };\r\n  }\r\n  regulateMonthDayNaive(calendarDate: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): FullCalendarDate {\r\n    const largestMonth = this.monthsInYear(calendarDate, cache);\r\n    let { month, day } = calendarDate;\r\n    if (overflow === 'reject') {\r\n      ES.RejectToRange(month, 1, largestMonth);\r\n      ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\r\n    } else {\r\n      month = ES.ConstrainToRange(month, 1, largestMonth);\r\n      day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\r\n    }\r\n    return { ...calendarDate, month, day };\r\n  }\r\n  calendarToIsoDate(dateParam: CalendarDateFields, overflow: Overflow = 'constrain', cache: OneObjectCache): ISODate {\r\n    const originalDate = dateParam as Partial<FullCalendarDate>;\r\n    // First, normalize the calendar date to ensure that (year, month, day)\r\n    // are all present, converting monthCode and eraYear if needed.\r\n    let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\r\n\r\n    // Fix obviously out-of-bounds values. Values that are valid generally, but\r\n    // not in this particular year, may not be caught here for some calendars.\r\n    // If so, these will be handled lower below.\r\n    date = this.regulateMonthDayNaive(date, overflow, cache);\r\n\r\n    const { year, month, day } = date;\r\n    const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\r\n    let cached = cache.get(key);\r\n    if (cached) return cached;\r\n    // If YMD are present in the input but the input has been constrained\r\n    // already, then cache both the original value and the constrained value.\r\n    let keyOriginal;\r\n    if (\r\n      originalDate.year !== undefined &&\r\n      originalDate.month !== undefined &&\r\n      originalDate.day !== undefined &&\r\n      (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)\r\n    ) {\r\n      keyOriginal = JSON.stringify({\r\n        func: 'calendarToIsoDate',\r\n        year: originalDate.year,\r\n        month: originalDate.month,\r\n        day: originalDate.day,\r\n        overflow,\r\n        id: this.id\r\n      });\r\n      cached = cache.get(keyOriginal);\r\n      if (cached) return cached;\r\n    }\r\n\r\n    // First, try to roughly guess the result\r\n    let isoEstimate = this.estimateIsoDate({ year, month, day });\r\n    const calculateSameMonthResult = (diffDays: number) => {\r\n      // If the estimate is in the same year & month as the target, then we can\r\n      // calculate the result exactly and short-circuit any additional logic.\r\n      // This optimization assumes that months are continuous. It would break if\r\n      // a calendar skipped days, like the Julian->Gregorian switchover. But\r\n      // current ICU calendars only skip days (japanese/roc/buddhist) because of\r\n      // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\r\n      // that's currently worked around by a custom calendarToIsoDate\r\n      // implementation in those calendars. So this optimization should be safe\r\n      // for all ICU calendars.\r\n      let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\r\n      if (date.day > this.minimumMonthLength(date)) {\r\n        // There's a chance that the calendar date is out of range. Throw or\r\n        // constrain if so.\r\n        let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\r\n        while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\r\n          if (overflow === 'reject') {\r\n            throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\r\n          }\r\n          // Back up a day at a time until we're not hanging over the month end\r\n          testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\r\n          testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\r\n        }\r\n      }\r\n      return testIsoEstimate;\r\n    };\r\n    let sign = 0;\r\n    let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\r\n    let diff = simpleDateDiff(date, roundtripEstimate);\r\n    if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\r\n      const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\r\n      isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\r\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\r\n      diff = simpleDateDiff(date, roundtripEstimate);\r\n      if (diff.years === 0 && diff.months === 0) {\r\n        isoEstimate = calculateSameMonthResult(diff.days);\r\n      } else {\r\n        sign = this.compareCalendarDates(date, roundtripEstimate);\r\n      }\r\n    }\r\n    // If the initial guess is not in the same month, then bisect the\r\n    // distance to the target, starting with 8 days per step.\r\n    let increment = 8;\r\n    while (sign) {\r\n      isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\r\n      const oldRoundtripEstimate = roundtripEstimate;\r\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\r\n      const oldSign = sign;\r\n      sign = this.compareCalendarDates(date, roundtripEstimate);\r\n      if (sign) {\r\n        diff = simpleDateDiff(date, roundtripEstimate);\r\n        if (diff.years === 0 && diff.months === 0) {\r\n          isoEstimate = calculateSameMonthResult(diff.days);\r\n          // Signal the loop condition that there's a match.\r\n          sign = 0;\r\n        } else if (oldSign && sign !== oldSign) {\r\n          if (increment > 1) {\r\n            // If the estimate overshot the target, try again with a smaller increment\r\n            // in the reverse direction.\r\n            increment /= 2;\r\n          } else {\r\n            // Increment is 1, and neither the previous estimate nor the new\r\n            // estimate is correct. The only way that can happen is if the\r\n            // original date was an invalid value that will be constrained or\r\n            // rejected here.\r\n            if (overflow === 'reject') {\r\n              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\r\n            } else {\r\n              // To constrain, pick the earliest value\r\n              const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\r\n              // If current value is larger, then back up to the previous value.\r\n              if (order > 0) isoEstimate = this.addDaysIso(isoEstimate, -1);\r\n              sign = 0;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    cache.set(key, isoEstimate);\r\n    if (keyOriginal) cache.set(keyOriginal, isoEstimate);\r\n    if (\r\n      date.year === undefined ||\r\n      date.month === undefined ||\r\n      date.day === undefined ||\r\n      date.monthCode === undefined ||\r\n      (this.hasEra && (date.era === undefined || date.eraYear === undefined))\r\n    ) {\r\n      throw new RangeError('Unexpected missing property');\r\n    }\r\n    return isoEstimate;\r\n  }\r\n  compareCalendarDates(date1: CalendarYMD, date2: CalendarYMD) {\r\n    if (date1.year !== date2.year) return ES.ComparisonResult(date1.year - date2.year);\r\n    if (date1.month !== date2.month) return ES.ComparisonResult(date1.month - date2.month);\r\n    if (date1.day !== date2.day) return ES.ComparisonResult(date1.day - date2.day);\r\n    return 0;\r\n  }\r\n  /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\r\n  regulateDate(calendarDate: CalendarYMD, overflow: Overflow = 'constrain', cache: OneObjectCache): FullCalendarDate {\r\n    const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\r\n    return this.isoToCalendarDate(isoDate, cache);\r\n  }\r\n  addDaysIso(isoDate: ISODate, days: number): ISODate {\r\n    const added = ES.BalanceISODate(isoDate.year, isoDate.month, isoDate.day + days);\r\n    return added;\r\n  }\r\n  addDaysCalendar(calendarDate: CalendarYMD, days: number, cache: OneObjectCache): FullCalendarDate {\r\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n    const addedIso = this.addDaysIso(isoDate, days);\r\n    const addedCalendar = this.isoToCalendarDate(addedIso, cache);\r\n    return addedCalendar;\r\n  }\r\n  addMonthsCalendar(\r\n    calendarDateParam: CalendarYMD,\r\n    months: number,\r\n    overflow: Overflow,\r\n    cache: OneObjectCache\r\n  ): CalendarYMD {\r\n    let calendarDate = calendarDateParam;\r\n    const { day } = calendarDate;\r\n    for (let i = 0, absMonths = Math.abs(months); i < absMonths; i++) {\r\n      const { month } = calendarDate;\r\n      const oldCalendarDate = calendarDate;\r\n      const days =\r\n        months < 0\r\n          ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\r\n          : this.daysInMonth(calendarDate, cache);\r\n      const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n      let addedIso = this.addDaysIso(isoDate, days);\r\n      calendarDate = this.isoToCalendarDate(addedIso, cache);\r\n\r\n      // Normally, we can advance one month by adding the number of days in the\r\n      // current month. However, if we're at the end of the current month and\r\n      // the next month has fewer days, then we rolled over to the after-next\r\n      // month. Below we detect this condition and back up until we're back in\r\n      // the desired month.\r\n      if (months > 0) {\r\n        const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\r\n        while (calendarDate.month - 1 !== month % monthsInOldYear) {\r\n          addedIso = this.addDaysIso(addedIso, -1);\r\n          calendarDate = this.isoToCalendarDate(addedIso, cache);\r\n        }\r\n      }\r\n\r\n      if (calendarDate.day !== day) {\r\n        // try to retain the original day-of-month, if possible\r\n        calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\r\n      }\r\n    }\r\n    if (overflow === 'reject' && calendarDate.day !== day) {\r\n      throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\r\n    }\r\n    return calendarDate;\r\n  }\r\n  addCalendar(\r\n    calendarDate: CalendarYMD & { monthCode: string },\r\n    { years = 0, months = 0, weeks = 0, days = 0 },\r\n    overflow: Overflow,\r\n    cache: OneObjectCache\r\n  ): FullCalendarDate {\r\n    const { year, day, monthCode } = calendarDate;\r\n    const addedYears = this.adjustCalendarDate({ year: year + years, monthCode, day }, cache);\r\n    const addedMonths = this.addMonthsCalendar(addedYears, months, overflow, cache);\r\n    const initialDays = days + weeks * 7;\r\n    const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\r\n    return addedDays;\r\n  }\r\n  untilCalendar(\r\n    calendarOne: FullCalendarDate,\r\n    calendarTwo: FullCalendarDate,\r\n    largestUnit: Temporal.DateUnit,\r\n    cache: OneObjectCache\r\n  ): { years: number; months: number; weeks: number; days: number } {\r\n    let days = 0;\r\n    let weeks = 0;\r\n    let months = 0;\r\n    let years = 0;\r\n    switch (largestUnit) {\r\n      case 'day':\r\n        days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\r\n        break;\r\n      case 'week': {\r\n        const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\r\n        days = totalDays % 7;\r\n        weeks = (totalDays - days) / 7;\r\n        break;\r\n      }\r\n      case 'month':\r\n      case 'year': {\r\n        const sign = this.compareCalendarDates(calendarTwo, calendarOne);\r\n        if (!sign) {\r\n          return { years: 0, months: 0, weeks: 0, days: 0 };\r\n        }\r\n        const diffYears = calendarTwo.year - calendarOne.year;\r\n        const diffDays = calendarTwo.day - calendarOne.day;\r\n        if (largestUnit === 'year' && diffYears) {\r\n          let diffInYearSign = 0;\r\n          if (calendarTwo.monthCode > calendarOne.monthCode) diffInYearSign = 1;\r\n          if (calendarTwo.monthCode < calendarOne.monthCode) diffInYearSign = -1;\r\n          if (!diffInYearSign) diffInYearSign = Math.sign(diffDays);\r\n          const isOneFurtherInYear = diffInYearSign * sign < 0;\r\n          years = isOneFurtherInYear ? diffYears - sign : diffYears;\r\n        }\r\n        const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\r\n        // Now we have less than one year remaining. Add one month at a time\r\n        // until we go over the target, then back up one month and calculate\r\n        // remaining days and weeks.\r\n        let current;\r\n        let next: CalendarYMD = yearsAdded;\r\n        do {\r\n          months += sign;\r\n          current = next;\r\n          next = this.addMonthsCalendar(current, sign, 'constrain', cache);\r\n          if (next.day !== calendarOne.day) {\r\n            // In case the day was constrained down, try to un-constrain it\r\n            next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\r\n          }\r\n        } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\r\n        months -= sign; // correct for loop above which overshoots by 1\r\n        const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\r\n        days = remainingDays;\r\n        break;\r\n      }\r\n    }\r\n    return { years, months, weeks, days };\r\n  }\r\n  daysInMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\r\n    // Add enough days to roll over to the next month. One we're in the next\r\n    // month, we can calculate the length of the current month. NOTE: This\r\n    // algorithm assumes that months are continuous. It would break if a\r\n    // calendar skipped days, like the Julian->Gregorian switchover. But current\r\n    // ICU calendars only skip days (japanese/roc/buddhist) because of a bug\r\n    // (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158) that's\r\n    // currently worked around by a custom calendarToIsoDate implementation in\r\n    // those calendars. So this code should be safe for all ICU calendars.\r\n    const { day } = calendarDate;\r\n    const max = this.maximumMonthLength(calendarDate);\r\n    const min = this.minimumMonthLength(calendarDate);\r\n    // easiest case: we already know the month length if min and max are the same.\r\n    if (min === max) return min;\r\n\r\n    // Add enough days to get into the next month, without skipping it\r\n    const increment = day <= max - min ? max : min;\r\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n    const addedIsoDate = this.addDaysIso(isoDate, increment);\r\n    const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\r\n\r\n    // Now back up to the last day of the original month\r\n    const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\r\n    const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\r\n    return endOfMonthCalendar.day;\r\n  }\r\n  daysInPreviousMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\r\n    const { day, month, year } = calendarDate;\r\n\r\n    // Check to see if we already know the month length, and return it if so\r\n    const previousMonthYear = month > 1 ? year : year - 1;\r\n    let previousMonthDate = { year: previousMonthYear, month, day: 1 };\r\n    const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\r\n    previousMonthDate = { ...previousMonthDate, month: previousMonth };\r\n    const min = this.minimumMonthLength(previousMonthDate);\r\n    const max = this.maximumMonthLength(previousMonthDate);\r\n    if (min === max) return max;\r\n\r\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n    const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\r\n    const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\r\n    return lastDayOfPreviousMonthCalendar.day;\r\n  }\r\n  startOfCalendarYear(calendarDate: CalendarYearOnly): CalendarYMD & { monthCode: string } {\r\n    return { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\r\n  }\r\n  startOfCalendarMonth(calendarDate: CalendarYM): CalendarYMD {\r\n    return { year: calendarDate.year, month: calendarDate.month, day: 1 };\r\n  }\r\n  calendarDaysUntil(calendarOne: CalendarYMD, calendarTwo: CalendarYMD, cache: OneObjectCache): number {\r\n    const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\r\n    const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\r\n    return (\r\n      ES.ISODateToEpochDays(twoIso.year, twoIso.month - 1, twoIso.day) -\r\n      ES.ISODateToEpochDays(oneIso.year, oneIso.month - 1, oneIso.day)\r\n    );\r\n  }\r\n  // Override if calendar uses eras\r\n  hasEra = false;\r\n  // See https://github.com/tc39/proposal-temporal/issues/1784\r\n  erasBeginMidYear = false;\r\n  // Override this to shortcut the search space if certain month codes only\r\n  // occur long in the past\r\n  monthDaySearchStartYear(monthCode: string, day: number) {\r\n    void monthCode, day;\r\n    return 1972;\r\n  }\r\n  monthDayFromFields(fields: MonthDayFromFieldsObject, overflow: Overflow, cache: OneObjectCache): ISODate {\r\n    let { era, eraYear, year, month, monthCode, day } = fields;\r\n    if (month !== undefined && year === undefined && (!this.hasEra || era === undefined || eraYear === undefined)) {\r\n      throw new TypeError('when month is present, year (or era and eraYear) are required');\r\n    }\r\n    if (monthCode === undefined || year !== undefined || (this.hasEra && eraYear !== undefined)) {\r\n      // Apply overflow behaviour to year/month/day, to get correct monthCode/day\r\n      ({ monthCode, day } = this.isoToCalendarDate(this.calendarToIsoDate(fields, overflow, cache), cache));\r\n    }\r\n\r\n    let isoYear, isoMonth, isoDay;\r\n    let closestCalendar, closestIso;\r\n    // Look backwards starting from one of the calendar years spanning ISO year\r\n    // 1972, up to 20 calendar years prior, to find a year that has this month\r\n    // and day. Normal months and days will match immediately, but for leap days\r\n    // and leap months we may have to look for a while. For searches longer than\r\n    // 20 years, override the start date in monthDaySearchStartYear.\r\n    const startDateIso = {\r\n      year: this.monthDaySearchStartYear(monthCode, day),\r\n      month: 12,\r\n      day: 31\r\n    };\r\n    const calendarOfStartDateIso = this.isoToCalendarDate(startDateIso, cache);\r\n    // Note: relies on lexicographical ordering of monthCodes\r\n    const calendarYear =\r\n      calendarOfStartDateIso.monthCode > monthCode ||\r\n      (calendarOfStartDateIso.monthCode === monthCode && calendarOfStartDateIso.day >= day)\r\n        ? calendarOfStartDateIso.year\r\n        : calendarOfStartDateIso.year - 1;\r\n    for (let i = 0; i < 20; i++) {\r\n      const testCalendarDate: FullCalendarDate = this.adjustCalendarDate(\r\n        { day, monthCode, year: calendarYear - i },\r\n        cache\r\n      );\r\n      const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\r\n      const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\r\n      ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\r\n      if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\r\n        return { month: isoMonth, day: isoDay, year: isoYear };\r\n      } else if (overflow === 'constrain') {\r\n        // If the requested day is never present in any instance of this month\r\n        // code, and the round trip date is an instance of this month code with\r\n        // the most possible days, we are as close as we can get.\r\n        const maxDayForMonthCode = this.maxLengthOfMonthCodeInAnyYear(roundTripCalendarDate.monthCode);\r\n        if (\r\n          roundTripCalendarDate.monthCode === monthCode &&\r\n          roundTripCalendarDate.day === maxDayForMonthCode &&\r\n          day > maxDayForMonthCode\r\n        ) {\r\n          return { month: isoMonth, day: isoDay, year: isoYear };\r\n        }\r\n        // non-ISO constrain algorithm tries to find the closest date in a matching month\r\n        if (\r\n          closestCalendar === undefined ||\r\n          (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\r\n            roundTripCalendarDate.day > closestCalendar.day)\r\n        ) {\r\n          closestCalendar = roundTripCalendarDate;\r\n          closestIso = isoDate;\r\n        }\r\n      }\r\n    }\r\n    if (overflow === 'constrain' && closestIso !== undefined) return closestIso;\r\n    throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\r\n  }\r\n  getFirstDayOfWeek(): number | undefined {\r\n    return undefined;\r\n  }\r\n  getMinimalDaysInFirstWeek(): number | undefined {\r\n    return undefined;\r\n  }\r\n}\r\n\r\ninterface HebrewMonthInfo {\r\n  [m: string]: (\r\n    | {\r\n        leap: undefined;\r\n        regular: number;\r\n      }\r\n    | {\r\n        leap: number;\r\n        regular: undefined;\r\n      }\r\n    | {\r\n        leap: number;\r\n        regular: number;\r\n      }\r\n  ) & {\r\n    monthCode: string;\r\n    days:\r\n      | number\r\n      | {\r\n          min: number;\r\n          max: number;\r\n        };\r\n  };\r\n}\r\n\r\nclass HebrewHelper extends HelperBase {\r\n  id = 'hebrew' as const;\r\n  calendarType = 'lunisolar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    const { year } = calendarDate;\r\n    // FYI: In addition to adding a month in leap years, the Hebrew calendar\r\n    // also has per-year changes to the number of days of Heshvan and Kislev.\r\n    // Given that these can be calculated by counting the number of days in\r\n    // those months, I assume that these DO NOT need to be exposed as\r\n    // Hebrew-only prototype fields or methods.\r\n    return (7 * year + 1) % 19 < 7;\r\n  }\r\n  monthsInYear(calendarDate: CalendarYearOnly) {\r\n    return this.inLeapYear(calendarDate) ? 13 : 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    return this.minMaxMonthLength(calendarDate, 'min');\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    return this.minMaxMonthLength(calendarDate, 'max');\r\n  }\r\n  minMaxMonthLength(calendarDate: CalendarYM, minOrMax: 'min' | 'max') {\r\n    const { month, year } = calendarDate;\r\n    const monthCode = this.getMonthCode(year, month);\r\n    const monthInfo = Object.entries(this.months).find((m) => m[1].monthCode === monthCode);\r\n    if (monthInfo === undefined) throw new RangeError(`unmatched Hebrew month: ${month}`);\r\n    const daysInMonth = monthInfo[1].days;\r\n    return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    return ['M04', 'M06', 'M08', 'M10', 'M12'].includes(monthCode) ? 29 : 30;\r\n  }\r\n  /** Take a guess at what ISO date a particular calendar date corresponds to */\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year } = calendarDate;\r\n    return { year: year - 3760, month: 1, day: 1 };\r\n  }\r\n  months: HebrewMonthInfo = {\r\n    Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\r\n    Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\r\n    Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\r\n    Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\r\n    Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\r\n    Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\r\n    'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\r\n    'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\r\n    Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\r\n    Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\r\n    Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\r\n    Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\r\n    Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\r\n    Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\r\n  };\r\n  getMonthCode(year: number, month: number) {\r\n    if (this.inLeapYear({ year })) {\r\n      return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\r\n    } else {\r\n      return buildMonthCode(month);\r\n    }\r\n  }\r\n  override adjustCalendarDate(\r\n    calendarDate: Partial<FullCalendarDate>,\r\n    cache?: OneObjectCache,\r\n    overflow: Overflow = 'constrain',\r\n    fromLegacyDate = false\r\n  ): FullCalendarDate {\r\n    let { year, month, monthCode, day, monthExtra } = calendarDate as Omit<typeof calendarDate, 'day'> & {\r\n      day: number;\r\n    };\r\n    if (year === undefined) throw new TypeError('Missing property: year');\r\n    if (fromLegacyDate) {\r\n      // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\r\n      // output returns the numeric equivalent of `month` as a string, meaning\r\n      // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\r\n      // means Adar. In this case, `month` will already be correct and no action\r\n      // is needed. However, in Node 14 and later formatToParts returns the name\r\n      // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\r\n      // correct `month` using the string name as a key.\r\n      if (monthExtra) {\r\n        const monthInfo = this.months[monthExtra];\r\n        if (!monthInfo) throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\r\n        month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\r\n      }\r\n      // Because we're getting data from legacy Date, then `month` will always be present\r\n      monthCode = this.getMonthCode(year, month as number);\r\n      return { year, month: month as number, day, monthCode };\r\n    } else {\r\n      // When called without input coming from legacy Date output, simply ensure\r\n      // that all fields are present.\r\n      this.validateCalendarDate(calendarDate);\r\n      if (month === undefined) {\r\n        ES.assertExists(monthCode);\r\n        if (monthCode.endsWith('L')) {\r\n          if (monthCode !== 'M05L') {\r\n            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\r\n          }\r\n          month = 6;\r\n          if (!this.inLeapYear({ year })) {\r\n            if (overflow === 'reject') {\r\n              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\r\n            } else {\r\n              // constrain to same day of next month (Adar)\r\n              month = 6;\r\n              monthCode = 'M06';\r\n            }\r\n          }\r\n        } else {\r\n          month = nonLeapMonthCodeNumberPart(monthCode);\r\n          // if leap month is before this one, the month index is one more than the month code\r\n          if (this.inLeapYear({ year }) && month >= 6) month++;\r\n          const largestMonth = this.monthsInYear({ year });\r\n          if (month < 1 || month > largestMonth) throw new RangeError(`Invalid monthCode: ${monthCode}`);\r\n        }\r\n      } else {\r\n        if (overflow === 'reject') {\r\n          ES.RejectToRange(month, 1, this.monthsInYear({ year }));\r\n          ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\r\n        } else {\r\n          month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\r\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\r\n        }\r\n        if (monthCode === undefined) {\r\n          monthCode = this.getMonthCode(year, month);\r\n        } else {\r\n          const calculatedMonthCode = this.getMonthCode(year, month);\r\n          if (calculatedMonthCode !== monthCode) {\r\n            throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\r\n          }\r\n        }\r\n      }\r\n      return { ...calendarDate, day, month, monthCode, year };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * For Temporal purposes, the Islamic calendar is simple because it's always the\r\n * same 12 months in the same order.\r\n */\r\nabstract class IslamicBaseHelper extends HelperBase {\r\n  abstract override id: BuiltinCalendarId;\r\n  calendarType = 'lunar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    const startOfYearCalendar = { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\r\n    const startOfNextYearCalendar = { year: calendarDate.year + 1, month: 1, monthCode: 'M01', day: 1 };\r\n    const result = this.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\r\n    return result === 355;\r\n  }\r\n  monthsInYear(/* calendarYear, cache */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(/* calendarDate */) {\r\n    return 29;\r\n  }\r\n  maximumMonthLength(/* calendarDate */) {\r\n    return 30;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(/* monthCode */) {\r\n    return 30;\r\n  }\r\n  DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\r\n  DAYS_PER_ISO_YEAR = 365.2425;\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year } = this.adjustCalendarDate(calendarDate);\r\n    return { year: Math.floor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\r\n  }\r\n}\r\n\r\n// There are 6 Islamic calendars with the same implementation in this polyfill.\r\n// They vary only in their ID. They do emit different output from the underlying\r\n// Intl implementation, but our code for each of them is identical.\r\nclass IslamicHelper extends IslamicBaseHelper {\r\n  id = 'islamic' as const;\r\n}\r\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\r\n  id = 'islamic-umalqura' as const;\r\n}\r\nclass IslamicTblaHelper extends IslamicBaseHelper {\r\n  id = 'islamic-tbla' as const;\r\n}\r\nclass IslamicCivilHelper extends IslamicBaseHelper {\r\n  id = 'islamic-civil' as const;\r\n}\r\nclass IslamicRgsaHelper extends IslamicBaseHelper {\r\n  id = 'islamic-rgsa' as const;\r\n}\r\nclass IslamicCcHelper extends IslamicBaseHelper {\r\n  id = 'islamicc' as const;\r\n}\r\n\r\nclass PersianHelper extends HelperBase {\r\n  id = 'persian' as const;\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    // If the last month has 30 days, it's a leap year.\r\n    return this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache) === 30;\r\n  }\r\n  monthsInYear(/* calendarYear, cache */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    if (month === 12) return 29;\r\n    return month <= 6 ? 31 : 30;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    if (month === 12) return 30;\r\n    return month <= 6 ? 31 : 30;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    return month <= 6 ? 31 : 30;\r\n  }\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year } = this.adjustCalendarDate(calendarDate);\r\n    return { year: year + 621, month: 1, day: 1 };\r\n  }\r\n}\r\n\r\ninterface IndianMonthInfo {\r\n  [month: number]: {\r\n    length: number;\r\n    month: number;\r\n    day: number;\r\n    leap?: {\r\n      length: number;\r\n      month: number;\r\n      day: number;\r\n    };\r\n    nextYear?: true | undefined;\r\n  };\r\n}\r\n\r\nclass IndianHelper extends HelperBase {\r\n  id = 'indian' as const;\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    // From https://en.wikipedia.org/wiki/Indian_national_calendar:\r\n    // Years are counted in the Saka era, which starts its year 0 in the year 78\r\n    // of the Common Era. To determine leap years, add 78 to the Saka year – if\r\n    // the result is a leap year in the Gregorian calendar, then the Saka year\r\n    // is a leap year as well.\r\n    return isGregorianLeapYear(calendarDate.year + 78);\r\n  }\r\n  monthsInYear(/* calendarYear, cache */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    return this.getMonthInfo(calendarDate).length;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    return this.getMonthInfo(calendarDate).length;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    let monthInfo = this.months[month];\r\n    monthInfo = monthInfo.leap ?? monthInfo;\r\n    return monthInfo.length;\r\n  }\r\n  // Indian months always start at the same well-known Gregorian month and\r\n  // day. So this conversion is easy and fast. See\r\n  // https://en.wikipedia.org/wiki/Indian_national_calendar\r\n  months: IndianMonthInfo = {\r\n    1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\r\n    2: { length: 31, month: 4, day: 21 },\r\n    3: { length: 31, month: 5, day: 22 },\r\n    4: { length: 31, month: 6, day: 22 },\r\n    5: { length: 31, month: 7, day: 23 },\r\n    6: { length: 31, month: 8, day: 23 },\r\n    7: { length: 30, month: 9, day: 23 },\r\n    8: { length: 30, month: 10, day: 23 },\r\n    9: { length: 30, month: 11, day: 22 },\r\n    10: { length: 30, month: 12, day: 22 },\r\n    11: { length: 30, month: 1, nextYear: true, day: 21 },\r\n    12: { length: 30, month: 2, nextYear: true, day: 20 }\r\n  };\r\n  getMonthInfo(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    let monthInfo = this.months[month];\r\n    if (monthInfo === undefined) throw new RangeError(`Invalid month: ${month}`);\r\n    if (this.inLeapYear(calendarDate) && monthInfo.leap) monthInfo = monthInfo.leap;\r\n    return monthInfo;\r\n  }\r\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\r\n    // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\r\n    // calendar fast!\r\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\r\n    const monthInfo = this.getMonthInfo(calendarDate);\r\n    const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\r\n    const isoMonth = monthInfo.month;\r\n    const isoDay = monthInfo.day;\r\n    const isoDate = ES.BalanceISODate(isoYear, isoMonth, isoDay + calendarDate.day - 1);\r\n    return isoDate;\r\n  }\r\n  // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\r\n  // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\r\n  // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\r\n  // expected.\r\n  vulnerableToBceBug =\r\n    new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\r\n  override checkIcuBugs(isoDate: ISODate) {\r\n    if (this.vulnerableToBceBug && isoDate.year < 1) {\r\n      throw new RangeError(\r\n        `calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\r\n          ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Era metadata defined for each calendar.\r\n * TODO: instead of optional properties, this should really have rules\r\n * encoded in the type, e.g. isoEpoch is required unless reverseOf is present.\r\n *  */\r\ninterface InputEra {\r\n  /**\r\n   * Era code, used to populate the 'era' field of Temporal instances.\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   */\r\n  code: string;\r\n\r\n  /**\r\n   * Names are additionally accepted as alternate era codes on input, and the\r\n   * first name is also output in error messages (and may be the era code if\r\n   * desired.)\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   * If absent, this field defaults to a single element matching the code.\r\n   */\r\n  names?: string[];\r\n\r\n  /**\r\n   * Signed calendar year where this era begins.Will be\r\n   * 1 (or 0 for zero-based eras) for the anchor era assuming that `year`\r\n   * numbering starts at the beginning of the anchor era, which is true\r\n   * for all ICU calendars except Japanese. If an era starts mid-year\r\n   * then a calendar month and day are included. Otherwise\r\n   * `{ month: 1, day: 1 }` is assumed.\r\n   */\r\n  anchorEpoch?: CalendarYearOnly | CalendarYMD;\r\n\r\n  /** ISO date of the first day of this era */\r\n  isoEpoch?: { year: number; month: number; day: number };\r\n\r\n  /**\r\n   * If present, then this era counts years backwards like BC\r\n   * and this property points to the forward era. This must be\r\n   * the last (oldest) era in the array.\r\n   * */\r\n  reverseOf?: string;\r\n\r\n  /**\r\n   * If true, the era's years are 0-based. If omitted or false,\r\n   * then the era's years are 1-based.\r\n   * */\r\n  hasYearZero?: boolean;\r\n\r\n  /**\r\n   * Override if this era is the anchor. Not normally used because\r\n   * anchor eras are inferred.\r\n   * */\r\n  isAnchor?: boolean;\r\n}\r\n/**\r\n * Transformation of the `InputEra` type with all fields filled in by\r\n * `adjustEras()`\r\n * */\r\ninterface Era {\r\n  /**\r\n   * Era code, used to populate the 'era' field of Temporal instances.\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   */\r\n  code: string;\r\n\r\n  /**\r\n   * Names are additionally accepted as alternate era codes on input, and the\r\n   * first name is also output in error messages (and may be the era code if\r\n   * desired.)\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   * If absent, this field defaults to a single element matching the code.\r\n   */\r\n  names: string[];\r\n\r\n  /**\r\n   * alternate name of the era used in old versions of ICU data\r\n   * format is `era{n}` where n is the zero-based index of the era\r\n   * with the oldest era being 0.\r\n   * */\r\n  genericName: string;\r\n\r\n  /**\r\n   * Signed calendar year where this era begins. Will be 1 (or 0 for zero-based\r\n   * eras) for the anchor era assuming that `year` numbering starts at the\r\n   * beginning of the anchor era, which is true for all ICU calendars except\r\n   * Japanese. For input, the month and day are optional. If an era starts\r\n   * mid-year then a calendar month and day are included.\r\n   * Otherwise `{ month: 1, day: 1 }` is assumed.\r\n   */\r\n  anchorEpoch: CalendarYMD;\r\n\r\n  /** ISO date of the first day of this era */\r\n  isoEpoch: ISODate;\r\n\r\n  /**\r\n   * If present, then this era counts years backwards like BC\r\n   * and this property points to the forward era. This must be\r\n   * the last (oldest) era in the array.\r\n   * */\r\n  reverseOf?: Era;\r\n\r\n  /**\r\n   * If true, the era's years are 0-based. If omitted or false,\r\n   * then the era's years are 1-based.\r\n   * */\r\n  hasYearZero?: boolean;\r\n\r\n  /**\r\n   * Override if this era is the anchor. Not normally used because\r\n   * anchor eras are inferred.\r\n   * */\r\n  isAnchor?: boolean;\r\n}\r\n\r\n/**\r\n * This function adds additional metadata that makes it easier to work with\r\n * eras. Note that it mutates and normalizes the original era objects, which is\r\n * OK because this is non-observable, internal-only metadata.\r\n *\r\n * The result is an array of eras with the shape defined above.\r\n * */\r\nfunction adjustEras(erasParam: InputEra[]): { eras: Era[]; anchorEra: Era } {\r\n  let eras: (InputEra | Era)[] = erasParam;\r\n  if (eras.length === 0) {\r\n    throw new RangeError('Invalid era data: eras are required');\r\n  }\r\n  if (eras.length === 1 && eras[0].reverseOf) {\r\n    throw new RangeError('Invalid era data: anchor era cannot count years backwards');\r\n  }\r\n  if (eras.length === 1 && !eras[0].code) {\r\n    throw new RangeError('Invalid era data: at least one named era is required');\r\n  }\r\n  if (eras.filter((e) => e.reverseOf != null).length > 1) {\r\n    throw new RangeError('Invalid era data: only one era can count years backwards');\r\n  }\r\n\r\n  // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\r\n  // eras can never be anchors. The era without an `anchorEpoch` property is the\r\n  // anchor.\r\n  let anchorEra: Era | InputEra | undefined;\r\n  eras.forEach((e) => {\r\n    if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\r\n      if (anchorEra) throw new RangeError('Invalid era data: cannot have multiple anchor eras');\r\n      anchorEra = e;\r\n      e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\r\n    } else if (!e.code) {\r\n      throw new RangeError('If era name is blank, it must be the anchor era');\r\n    }\r\n  });\r\n\r\n  // If the era name is undefined, then it's an anchor that doesn't interact\r\n  // with eras at all. For example, Japanese `year` is always the same as ISO\r\n  // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\r\n  // Strip it from the list that's returned.\r\n  eras = eras.filter((e) => e.code);\r\n\r\n  eras.forEach((e) => {\r\n    // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\r\n    // Replace the string-valued \"reverseOf\" property with the actual era object\r\n    // that's reversed.\r\n    const { reverseOf } = e;\r\n    if (reverseOf) {\r\n      const reversedEra = eras.find((era) => era.code === reverseOf);\r\n      if (reversedEra === undefined) {\r\n        throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\r\n      }\r\n      e.reverseOf = reversedEra as Era; // genericName property added later\r\n      e.anchorEpoch = reversedEra.anchorEpoch;\r\n      e.isoEpoch = reversedEra.isoEpoch;\r\n    }\r\n    type YMD = {\r\n      year: number;\r\n      month: number;\r\n      day: number;\r\n    };\r\n    if ((e.anchorEpoch as YMD).month === undefined) (e.anchorEpoch as YMD).month = 1;\r\n    if ((e.anchorEpoch as YMD).day === undefined) (e.anchorEpoch as YMD).day = 1;\r\n  });\r\n\r\n  // Ensure that the latest epoch is first in the array. This lets us try to\r\n  // match eras in index order, with the last era getting the remaining older\r\n  // years. Any reverse-signed era must be at the end.\r\n  eras.sort((e1, e2) => {\r\n    if (e1.reverseOf) return 1;\r\n    if (e2.reverseOf) return -1;\r\n    if (!e1.isoEpoch || !e2.isoEpoch) throw new RangeError('Invalid era data: missing ISO epoch');\r\n    return e2.isoEpoch.year - e1.isoEpoch.year;\r\n  });\r\n\r\n  // If there's a reversed era, then the one before it must be the era that's\r\n  // being reversed.\r\n  const lastEraReversed = eras[eras.length - 1].reverseOf;\r\n  if (lastEraReversed) {\r\n    if (lastEraReversed !== eras[eras.length - 2]) {\r\n      throw new RangeError('Invalid era data: invalid reverse-sign era');\r\n    }\r\n  }\r\n\r\n  // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\r\n  // zero-based index, with the oldest era being zero. This format is used by\r\n  // older versions of ICU data.\r\n  eras.forEach((e, i) => {\r\n    (e as Era).genericName = `era${eras.length - 1 - i}`;\r\n  });\r\n\r\n  return { eras: eras as Era[], anchorEra: (anchorEra || eras[0]) as Era };\r\n}\r\n\r\nfunction isGregorianLeapYear(year: number) {\r\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\r\n}\r\n\r\n/** Base for all Gregorian-like calendars. */\r\nabstract class GregorianBaseHelperFixedEpoch extends HelperBase {\r\n  id: BuiltinCalendarId;\r\n  isoEpoch: ISODate;\r\n\r\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\r\n    super();\r\n    this.id = id;\r\n    this.isoEpoch = isoEpoch;\r\n  }\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\r\n    return isGregorianLeapYear(year);\r\n  }\r\n  monthsInYear(/* calendarDate */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM): number {\r\n    const { month } = calendarDate;\r\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\r\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM): number {\r\n    return this.minimumMonthLength(calendarDate);\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\r\n  }\r\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\r\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\r\n    return ES.RegulateISODate(\r\n      calendarDate.year + this.isoEpoch.year,\r\n      calendarDate.month + this.isoEpoch.month,\r\n      calendarDate.day + this.isoEpoch.day,\r\n      'constrain'\r\n    );\r\n  }\r\n}\r\n\r\n/** Base for Gregorian-like calendars with eras. */\r\nabstract class GregorianBaseHelper extends HelperBase {\r\n  id: BuiltinCalendarId;\r\n  anchorEra: Era;\r\n\r\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\r\n    super();\r\n    this.id = id;\r\n    const { eras, anchorEra } = adjustEras(originalEras);\r\n    this.anchorEra = anchorEra;\r\n    this.eras = eras;\r\n  }\r\n  override hasEra = true;\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    // Calendars that don't override this method use the same months and leap\r\n    // years as Gregorian. Once we know the ISO year corresponding to the\r\n    // calendar year, we'll know if it's a leap year or not.\r\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\r\n    return isGregorianLeapYear(year);\r\n  }\r\n  monthsInYear(/* calendarDate */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM): number {\r\n    const { month } = calendarDate;\r\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\r\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM): number {\r\n    return this.minimumMonthLength(calendarDate);\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\r\n  }\r\n  /** Fill in missing parts of the (year, era, eraYear) tuple */\r\n  completeEraYear(\r\n    calendarDate: FullCalendarDate\r\n  ): FullCalendarDate & Required<Pick<FullCalendarDate, 'era' | 'eraYear'>> {\r\n    const checkField = (property: keyof FullCalendarDate, value: string | number | undefined, names?: string[]) => {\r\n      const currentValue = calendarDate[property];\r\n      if (currentValue != null && currentValue != value && !((names || []) as unknown[]).includes(currentValue)) {\r\n        // Prefer displaying an era alias, instead of \"gregory-inverse\"\r\n        const preferredName = names?.[0];\r\n        const expected = preferredName ? `${value} (also called ${preferredName})` : value;\r\n        throw new RangeError(`Input ${property} ${currentValue} doesn't match calculated value ${expected}`);\r\n      }\r\n    };\r\n    const eraFromYear = (year: number) => {\r\n      let eraYear;\r\n      const adjustedCalendarDate = { ...calendarDate, year };\r\n      const matchingEra = this.eras.find((e, i) => {\r\n        if (i === this.eras.length - 1) {\r\n          if (e.reverseOf) {\r\n            // This is a reverse-sign era (like BCE) which must be the oldest\r\n            // era. Count years backwards.\r\n            if (year > 0) throw new RangeError(`Signed year ${year} is invalid for era ${e.code}`);\r\n            eraYear = e.anchorEpoch.year - year;\r\n            return true;\r\n          }\r\n          // last era always gets all \"leftover\" (older than epoch) years,\r\n          // so no need for a comparison like below.\r\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\r\n          return true;\r\n        }\r\n        const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\r\n        if (comparison >= 0) {\r\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n      if (!matchingEra) throw new RangeError(`Year ${year} was not matched by any era`);\r\n      return { eraYear: eraYear as unknown as number, era: matchingEra.code, eraNames: matchingEra.names };\r\n    };\r\n\r\n    let { year, eraYear, era } = calendarDate;\r\n    if (year != null) {\r\n      const matchData = eraFromYear(year);\r\n      ({ eraYear, era } = matchData);\r\n      checkField('era', era, matchData?.eraNames);\r\n      checkField('eraYear', eraYear);\r\n    } else if (eraYear != null) {\r\n      if (era === undefined) throw new RangeError('era and eraYear must be provided together');\r\n      // TS limitation: https://github.com/microsoft/TypeScript/issues/11498\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      const matchingEra = this.eras.find(({ code, names = [] }) => code === era || names.includes(era!));\r\n      if (!matchingEra) throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\r\n      if (matchingEra.reverseOf) {\r\n        year = matchingEra.anchorEpoch.year - eraYear;\r\n      } else {\r\n        year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\r\n      }\r\n      checkField('year', year);\r\n      // We'll accept dates where the month/day is earlier than the start of\r\n      // the era or after its end as long as it's in the same year. If that\r\n      // happens, we'll adjust the era/eraYear pair to be the correct era for\r\n      // the `year`.\r\n      ({ eraYear, era } = eraFromYear(year));\r\n    } else {\r\n      throw new RangeError('Either year or eraYear and era are required');\r\n    }\r\n    return { ...calendarDate, year, eraYear, era };\r\n  }\r\n  override adjustCalendarDate(\r\n    calendarDateParam: Partial<FullCalendarDate>,\r\n    cache?: OneObjectCache,\r\n    overflow: Overflow = 'constrain'\r\n  ): FullCalendarDate {\r\n    let calendarDate = calendarDateParam;\r\n    // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\r\n    const { month, monthCode } = calendarDate;\r\n    if (month === undefined) calendarDate = { ...calendarDate, month: nonLeapMonthCodeNumberPart(monthCode as string) };\r\n    this.validateCalendarDate(calendarDate);\r\n    calendarDate = this.completeEraYear(calendarDate);\r\n    return super.adjustCalendarDate(calendarDate, cache, overflow);\r\n  }\r\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\r\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\r\n    const { year, month, day } = calendarDate;\r\n    const { anchorEra } = this;\r\n    const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\r\n    return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\r\n  }\r\n}\r\n\r\n/**\r\n * Some calendars are identical to Gregorian except era and year. For these\r\n * calendars, we can avoid using Intl.DateTimeFormat and just calculate the\r\n * year, era, and eraYear. This is faster (because Intl.DateTimeFormat is slow\r\n * and uses a huge amount of RAM), and it avoids ICU bugs like\r\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\r\n */\r\nabstract class SameMonthDayAsGregorianBaseHelper extends GregorianBaseHelper {\r\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\r\n    super(id, originalEras);\r\n  }\r\n  override isoToCalendarDate(isoDate: ISODate): FullCalendarDate {\r\n    // Month and day are same as ISO, so bypass Intl.DateTimeFormat and\r\n    // calculate the year, era, and eraYear here.\r\n    const { year: isoYear, month, day } = isoDate;\r\n    const monthCode = buildMonthCode(month);\r\n    const year = isoYear - this.anchorEra.isoEpoch.year + 1;\r\n    return this.completeEraYear({ year, month, monthCode, day });\r\n  }\r\n}\r\nconst OrthodoxOps = {\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    // Leap years happen one year before the Julian leap year. Note that this\r\n    // calendar is based on the Julian calendar which has a leap year every 4\r\n    // years, unlike the Gregorian calendar which doesn't have leap years on\r\n    // years divisible by 100 except years divisible by 400.\r\n    //\r\n    // Note that we're assuming that leap years in before-epoch times match\r\n    // how leap years are defined now. This is probably not accurate but I'm\r\n    // not sure how better to do it.\r\n    const { year } = calendarDate;\r\n    return (year + 1) % 4 === 0;\r\n  },\r\n  monthsInYear(/* calendarDate */) {\r\n    return 13;\r\n  },\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\r\n    if (month === 13) return this.inLeapYear(calendarDate) ? 6 : 5;\r\n    return 30;\r\n  },\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    return this.minimumMonthLength(calendarDate);\r\n  },\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    return monthCode === 'M13' ? 6 : 30;\r\n  }\r\n};\r\nabstract class OrthodoxBaseHelperFixedEpoch extends GregorianBaseHelperFixedEpoch {\r\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\r\n    super(id, isoEpoch);\r\n  }\r\n  override inLeapYear = OrthodoxOps.inLeapYear;\r\n  override monthsInYear = OrthodoxOps.monthsInYear;\r\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\r\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\r\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\r\n}\r\nabstract class OrthodoxBaseHelper extends GregorianBaseHelper {\r\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\r\n    super(id, originalEras);\r\n  }\r\n  override inLeapYear = OrthodoxOps.inLeapYear;\r\n  override monthsInYear = OrthodoxOps.monthsInYear;\r\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\r\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\r\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\r\n}\r\n\r\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\r\n// with the following differences:\r\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\r\n//   two use negative year numbers before epoch)\r\n// - Coptic has a different epoch date\r\n// - Ethiopic has an additional second era that starts at the same date as the\r\n//   zero era of ethioaa.\r\nclass EthioaaHelper extends OrthodoxBaseHelperFixedEpoch {\r\n  constructor() {\r\n    super('ethioaa', { year: -5492, month: 7, day: 17 });\r\n  }\r\n}\r\nclass CopticHelper extends OrthodoxBaseHelper {\r\n  constructor() {\r\n    super('coptic', [\r\n      { code: 'coptic', isoEpoch: { year: 284, month: 8, day: 29 } },\r\n      { code: 'coptic-inverse', reverseOf: 'coptic' }\r\n    ]);\r\n  }\r\n}\r\n\r\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\r\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\r\nclass EthiopicHelper extends OrthodoxBaseHelper {\r\n  constructor() {\r\n    super('ethiopic', [\r\n      { code: 'ethioaa', names: ['ethiopic-amete-alem', 'mundi'], isoEpoch: { year: -5492, month: 7, day: 17 } },\r\n      { code: 'ethiopic', names: ['incar'], isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\r\n    ]);\r\n  }\r\n}\r\n\r\nclass RocHelper extends SameMonthDayAsGregorianBaseHelper {\r\n  constructor() {\r\n    super('roc', [\r\n      { code: 'roc', names: ['minguo'], isoEpoch: { year: 1912, month: 1, day: 1 } },\r\n      { code: 'roc-inverse', names: ['before-roc'], reverseOf: 'roc' }\r\n    ]);\r\n  }\r\n}\r\n\r\nclass BuddhistHelper extends GregorianBaseHelperFixedEpoch {\r\n  constructor() {\r\n    super('buddhist', { year: -543, month: 1, day: 1 });\r\n  }\r\n}\r\n\r\nclass GregoryHelper extends SameMonthDayAsGregorianBaseHelper {\r\n  constructor() {\r\n    super('gregory', [\r\n      { code: 'gregory', names: ['ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\r\n      { code: 'gregory-inverse', names: ['be', 'bce'], reverseOf: 'gregory' }\r\n    ]);\r\n  }\r\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T /*, isoDate: IsoDate*/): T {\r\n    let { era, eraYear } = calendarDate;\r\n    // Firefox 96 introduced a bug where the `'short'` format of the era\r\n    // option mistakenly returns the one-letter (narrow) format instead. The\r\n    // code below handles either the correct or Firefox-buggy format. See\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\r\n    if (era === 'b') era = 'gregory-inverse';\r\n    if (era === 'a') era = 'gregory';\r\n    return { era, eraYear } as T;\r\n  }\r\n}\r\n\r\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\r\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\r\n// eras include:\r\n// - Start/end dates of older eras are not precisely defined, which is\r\n//   challenging given Temporal's need for precision\r\n// - Some era dates and/or names are disputed by historians\r\n// - As historical research proceeds, new eras are discovered and existing era\r\n//   dates are modified, leading to considerable churn which is not good for\r\n//   Temporal use.\r\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\r\n//    on future historical scholarship\r\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\r\n//    that's not reflected in the ICU implementation.\r\n//\r\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\r\n//\r\n// Here's a full list of CLDR/ICU eras:\r\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\r\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\r\n//\r\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\r\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\r\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\r\n// Japanese calendar doesn't seem to take this into account, so neither do we:\r\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\r\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\r\n// '1 1, 6 Meiji, 12:00:00 PM'\r\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\r\n// '12 31, 5 Meiji, 12:00:00 PM'\r\nclass JapaneseHelper extends SameMonthDayAsGregorianBaseHelper {\r\n  constructor() {\r\n    super('japanese', [\r\n      // The Japanese calendar `year` is just the ISO year, because (unlike other\r\n      // ICU calendars) there's no obvious \"default era\", we use the ISO year.\r\n      { code: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\r\n      { code: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\r\n      { code: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\r\n      { code: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\r\n      { code: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\r\n      { code: 'japanese', names: ['japanese', 'gregory', 'ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\r\n      { code: 'japanese-inverse', names: ['japanese-inverse', 'gregory-inverse', 'bc', 'bce'], reverseOf: 'japanese' }\r\n    ]);\r\n  }\r\n\r\n  override erasBeginMidYear = true;\r\n\r\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T {\r\n    const { era, eraYear } = calendarDate;\r\n    const { year: isoYear } = isoDate;\r\n    if (this.eras.find((e) => e.code === era)) return { era, eraYear } as T;\r\n    return (\r\n      isoYear < 1 ? { era: 'japanese-inverse', eraYear: 1 - isoYear } : { era: 'japanese', eraYear: isoYear }\r\n    ) as T;\r\n  }\r\n}\r\n\r\ninterface ChineseMonthInfo {\r\n  [key: string]: { monthIndex: number; daysInMonth: number };\r\n}\r\ninterface ChineseDraftMonthInfo {\r\n  [key: string]: { monthIndex: number; daysInMonth?: number };\r\n}\r\n\r\nabstract class ChineseBaseHelper extends HelperBase {\r\n  abstract override id: BuiltinCalendarId;\r\n  calendarType = 'lunisolar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    const months = this.getMonthList(calendarDate.year, cache);\r\n    return Object.entries(months).length === 13;\r\n  }\r\n  monthsInYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    return this.inLeapYear(calendarDate, cache) ? 13 : 12;\r\n  }\r\n  minimumMonthLength(/* calendarDate */) {\r\n    return 29;\r\n  }\r\n  maximumMonthLength(/* calendarDate */) {\r\n    return 30;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    // See note below about ICU4C vs ICU4X. It is possible this override should\r\n    // always return 30.\r\n    return ['M01L', 'M09L', 'M10L', 'M11L', 'M12L'].includes(monthCode) ? 29 : 30;\r\n  }\r\n  override monthDaySearchStartYear(monthCode: string, day: number) {\r\n    // Note that ICU4C actually has _no_ years in which leap months M01L and\r\n    // M09L through M12L have 30 days. The values marked with (*) here are years\r\n    // in which the leap month occurs with 29 days. ICU4C disagrees with ICU4X\r\n    // here and it is not clear which is correct.\r\n    const monthMap: Record<string, [number, number]> = {\r\n      M01L: [1651, 1651], // *\r\n      M02L: [1947, 1765],\r\n      M03L: [1966, 1955],\r\n      M04L: [1963, 1944],\r\n      M05L: [1971, 1952],\r\n      M06L: [1960, 1941],\r\n      M07L: [1968, 1938],\r\n      M08L: [1957, 1718],\r\n      M09L: [1832, 1832], // *\r\n      M10L: [1870, 1870], // *\r\n      M11L: [1814, 1814], // *\r\n      M12L: [1890, 1890] // *\r\n    };\r\n    const years = monthMap[monthCode] ?? [1972, 1972];\r\n    return day < 30 ? years[0] : years[1];\r\n  }\r\n  getMonthList(calendarYear: number, cache: OneObjectCache): ChineseMonthInfo {\r\n    if (calendarYear === undefined) {\r\n      throw new TypeError('Missing year');\r\n    }\r\n    const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\r\n    const cached = cache.get(key);\r\n    if (cached) return cached;\r\n    const dateTimeFormat = this.getFormatter();\r\n    const getCalendarDate = (isoYear: number, daysPastFeb1: number) => {\r\n      const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\r\n      const legacyDate = new Date(isoStringFeb1);\r\n      // Now add the requested number of days, which may wrap to the next month.\r\n      legacyDate.setUTCDate(daysPastFeb1 + 1);\r\n      const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\r\n      // The 'month' and 'day' parts are guaranteed to be present because the\r\n      // formatter was created with month and day options.\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month')!.value;\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      const calendarDay = +newYearGuess.find((tv) => tv.type === 'day')!.value;\r\n      const calendarYearPartToVerify = newYearGuess.find((tv) => (tv.type as string) === 'relatedYear');\r\n      let calendarYearToVerify: number | undefined;\r\n      if (calendarYearPartToVerify !== undefined) {\r\n        calendarYearToVerify = +calendarYearPartToVerify.value;\r\n      } else {\r\n        // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\r\n        // output of Intl.DateTimeFormat.formatToParts.\r\n        throw new RangeError(\r\n          `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\r\n        );\r\n      }\r\n      return { calendarMonthString, calendarDay, calendarYearToVerify };\r\n    };\r\n\r\n    // First, find a date close to Chinese New Year. Feb 17 will either be in\r\n    // the first month or near the end of the last month of the previous year.\r\n    let isoDaysDelta = 17;\r\n    let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\r\n\r\n    // If we didn't guess the first month correctly, add (almost in some months)\r\n    // a lunar month\r\n    if (calendarMonthString !== '1') {\r\n      isoDaysDelta += 29;\r\n      ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\r\n    }\r\n\r\n    // Now back up to near the start of the first month, but not too near that\r\n    // off-by-one issues matter.\r\n    isoDaysDelta -= calendarDay - 5;\r\n    const result = {} as ChineseDraftMonthInfo;\r\n    let monthIndex = 1;\r\n    let oldCalendarDay: number | undefined;\r\n    let oldMonthString: string | undefined;\r\n    let done = false;\r\n    do {\r\n      ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\r\n      if (oldCalendarDay) {\r\n        result[oldMonthString as string].daysInMonth = oldCalendarDay + 30 - calendarDay;\r\n      }\r\n      if (calendarYearToVerify !== calendarYear) {\r\n        done = true;\r\n      } else {\r\n        result[calendarMonthString] = { monthIndex: monthIndex++ };\r\n        // Move to the next month. Because months are sometimes 29 days, the day of the\r\n        // calendar month will move forward slowly but not enough to flip over to a new\r\n        // month before the loop ends at 12-13 months.\r\n        isoDaysDelta += 30;\r\n      }\r\n      oldCalendarDay = calendarDay;\r\n      oldMonthString = calendarMonthString;\r\n    } while (!done);\r\n    result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\r\n\r\n    cache.set(key, result);\r\n    return result as ChineseMonthInfo;\r\n  }\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year, month } = calendarDate;\r\n    return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\r\n  }\r\n  override adjustCalendarDate(\r\n    calendarDate: Partial<FullCalendarDate>,\r\n    cache: OneObjectCache,\r\n    overflow: Overflow = 'constrain',\r\n    fromLegacyDate = false\r\n  ): FullCalendarDate {\r\n    let { year, month, monthExtra, day, monthCode } = calendarDate;\r\n    if (year === undefined) throw new TypeError('Missing property: year');\r\n    if (fromLegacyDate) {\r\n      // Legacy Date output returns a string that's an integer with an optional\r\n      // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\r\n      // month. Below we'll normalize the output.\r\n      if (monthExtra && monthExtra !== 'bis') throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\r\n      const monthCode = buildMonthCode(month as number, monthExtra !== undefined);\r\n      const monthString = `${month}${monthExtra || ''}`;\r\n      const months = this.getMonthList(year, cache);\r\n      const monthInfo = months[monthString];\r\n      if (monthInfo === undefined) throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\r\n      month = monthInfo.monthIndex;\r\n      return { year, month, day: day as number, monthCode };\r\n    } else {\r\n      // When called without input coming from legacy Date output,\r\n      // simply ensure that all fields are present.\r\n      this.validateCalendarDate(calendarDate);\r\n      if (month === undefined) {\r\n        ES.assertExists(monthCode);\r\n        const months = this.getMonthList(year, cache);\r\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\r\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\r\n        let monthInfo = months[numberPart];\r\n        month = monthInfo && monthInfo.monthIndex;\r\n\r\n        // If this leap month isn't present in this year, constrain to the same\r\n        // day of the previous month.\r\n        if (month === undefined && monthCode.endsWith('L') && monthCode != 'M13L' && overflow === 'constrain') {\r\n          const withoutML = +monthCode.replace(/^M0?|L$/g, '');\r\n          monthInfo = months[withoutML];\r\n          if (monthInfo) {\r\n            month = monthInfo.monthIndex;\r\n            monthCode = buildMonthCode(withoutML);\r\n          }\r\n        }\r\n        if (month === undefined) {\r\n          throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\r\n        }\r\n      } else if (monthCode === undefined) {\r\n        const months = this.getMonthList(year, cache);\r\n        const monthEntries = Object.entries(months);\r\n        const largestMonth = monthEntries.length;\r\n        if (overflow === 'reject') {\r\n          ES.RejectToRange(month, 1, largestMonth);\r\n          ES.RejectToRange(day as number, 1, this.maximumMonthLength());\r\n        } else {\r\n          month = ES.ConstrainToRange(month, 1, largestMonth);\r\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\r\n        }\r\n        const matchingMonthEntry = monthEntries.find((entry) => entry[1].monthIndex === month);\r\n        if (matchingMonthEntry === undefined) {\r\n          throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\r\n        }\r\n        monthCode = buildMonthCode(\r\n          +matchingMonthEntry[0].replace('bis', ''),\r\n          matchingMonthEntry[0].indexOf('bis') !== -1\r\n        );\r\n      } else {\r\n        // Both month and monthCode are present. Make sure they don't conflict.\r\n        const months = this.getMonthList(year, cache);\r\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\r\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\r\n        const monthInfo = months[numberPart];\r\n        if (!monthInfo) throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\r\n        if (month !== monthInfo.monthIndex) {\r\n          throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\r\n        }\r\n      }\r\n      return { ...calendarDate, year, month, monthCode, day: day as number };\r\n    }\r\n  }\r\n}\r\n\r\nclass ChineseHelper extends ChineseBaseHelper {\r\n  id = 'chinese' as const;\r\n}\r\n\r\n// Dangi (Korean) calendar has same implementation as Chinese\r\nclass DangiHelper extends ChineseBaseHelper {\r\n  id = 'dangi' as const;\r\n}\r\n\r\n/**\r\n * Common implementation of all non-ISO calendars.\r\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\r\n * This split allowed an easy separation between code that was similar between\r\n * ISO and non-ISO implementations vs. code that was very different.\r\n */\r\nclass NonIsoCalendar implements CalendarImpl {\r\n  constructor(private readonly helper: HelperBase) {}\r\n  extraFields(fields: FieldKey[]): FieldKey[] {\r\n    if (this.helper.hasEra && fields.includes('year')) {\r\n      return ['era', 'eraYear'];\r\n    }\r\n    return [];\r\n  }\r\n  resolveFields(fields: CalendarFieldsRecord /* , type */) {\r\n    if (this.helper.calendarType !== 'lunisolar') {\r\n      const cache = new OneObjectCache();\r\n      const largestMonth = this.helper.monthsInYear({ year: fields.year ?? 1972 }, cache);\r\n      resolveNonLunisolarMonth(fields, undefined, largestMonth);\r\n    }\r\n  }\r\n  dateToISO(fields: CalendarDateFields, overflow: Overflow) {\r\n    const cache = new OneObjectCache();\r\n    const result = this.helper.calendarToIsoDate(fields, overflow, cache);\r\n    cache.setObject(result);\r\n    return result;\r\n  }\r\n  monthDayToISOReferenceDate(fields: MonthDayFromFieldsObject, overflow: Overflow) {\r\n    const cache = new OneObjectCache();\r\n    const result = this.helper.monthDayFromFields(fields, overflow, cache);\r\n    // result.year is a reference year where this month/day exists in this calendar\r\n    cache.setObject(result);\r\n    return result;\r\n  }\r\n  fieldKeysToIgnore(\r\n    keys: Exclude<keyof Temporal.PlainDateLike, 'calendar'>[]\r\n  ): Exclude<keyof Temporal.PlainDateLike, 'calendar'>[] {\r\n    const result = new Set<(typeof keys)[number]>();\r\n    for (let ix = 0; ix < keys.length; ix++) {\r\n      const key = keys[ix];\r\n      result.add(key);\r\n      switch (key) {\r\n        case 'era':\r\n          result.add('eraYear');\r\n          result.add('year');\r\n          break;\r\n        case 'eraYear':\r\n          result.add('era');\r\n          result.add('year');\r\n          break;\r\n        case 'year':\r\n          result.add('era');\r\n          result.add('eraYear');\r\n          break;\r\n        case 'month':\r\n          result.add('monthCode');\r\n          // See https://github.com/tc39/proposal-temporal/issues/1784\r\n          if (this.helper.erasBeginMidYear) {\r\n            result.add('era');\r\n            result.add('eraYear');\r\n          }\r\n          break;\r\n        case 'monthCode':\r\n          result.add('month');\r\n          if (this.helper.erasBeginMidYear) {\r\n            result.add('era');\r\n            result.add('eraYear');\r\n          }\r\n          break;\r\n        case 'day':\r\n          if (this.helper.erasBeginMidYear) {\r\n            result.add('era');\r\n            result.add('eraYear');\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    return arrayFromSet(result);\r\n  }\r\n  dateAdd(isoDate: ISODate, { years, months, weeks, days }: DateDuration, overflow: Overflow) {\r\n    const cache = OneObjectCache.getCacheForObject(isoDate);\r\n    const calendarDate = this.helper.isoToCalendarDate(isoDate, cache);\r\n    const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\r\n    const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\r\n    // The new object's cache starts with the cache of the old object\r\n    if (!OneObjectCache.getCacheForObject(isoAdded)) {\r\n      const newCache = new OneObjectCache(cache);\r\n      newCache.setObject(isoAdded);\r\n    }\r\n    return isoAdded;\r\n  }\r\n  dateUntil(one: ISODate, two: ISODate, largestUnit: Temporal.DateUnit) {\r\n    const cacheOne = OneObjectCache.getCacheForObject(one);\r\n    const cacheTwo = OneObjectCache.getCacheForObject(two);\r\n    const calendarOne = this.helper.isoToCalendarDate(one, cacheOne);\r\n    const calendarTwo = this.helper.isoToCalendarDate(two, cacheTwo);\r\n    const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\r\n    return result;\r\n  }\r\n  isoToDate<\r\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\r\n    T extends {\r\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\r\n    }\r\n  >(isoDate: ISODate, requestedFields: Request): T {\r\n    const cache = OneObjectCache.getCacheForObject(isoDate);\r\n    const calendarDate: Partial<CalendarDateRecord> & FullCalendarDate = this.helper.isoToCalendarDate(isoDate, cache);\r\n    if (requestedFields.dayOfWeek) {\r\n      calendarDate.dayOfWeek = impl['iso8601'].isoToDate(isoDate, { dayOfWeek: true }).dayOfWeek;\r\n    }\r\n    if (requestedFields.dayOfYear) {\r\n      const startOfYear = this.helper.startOfCalendarYear(calendarDate);\r\n      const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\r\n      calendarDate.dayOfYear = diffDays + 1;\r\n    }\r\n    if (requestedFields.weekOfYear) calendarDate.weekOfYear = calendarDateWeekOfYear(this.helper.id, isoDate);\r\n    calendarDate.daysInWeek = 7;\r\n    if (requestedFields.daysInMonth) calendarDate.daysInMonth = this.helper.daysInMonth(calendarDate, cache);\r\n    if (requestedFields.daysInYear) {\r\n      const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\r\n      const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\r\n      calendarDate.daysInYear = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\r\n    }\r\n    if (requestedFields.monthsInYear) calendarDate.monthsInYear = this.helper.monthsInYear(calendarDate, cache);\r\n    if (requestedFields.inLeapYear) calendarDate.inLeapYear = this.helper.inLeapYear(calendarDate, cache);\r\n    return calendarDate as T;\r\n  }\r\n  getFirstDayOfWeek(): number | undefined {\r\n    return this.helper.getFirstDayOfWeek();\r\n  }\r\n  getMinimalDaysInFirstWeek(): number | undefined {\r\n    return this.helper.getMinimalDaysInFirstWeek();\r\n  }\r\n}\r\n\r\nfor (const Helper of [\r\n  HebrewHelper,\r\n  PersianHelper,\r\n  EthiopicHelper,\r\n  EthioaaHelper,\r\n  CopticHelper,\r\n  ChineseHelper,\r\n  DangiHelper,\r\n  RocHelper,\r\n  IndianHelper,\r\n  BuddhistHelper,\r\n  GregoryHelper,\r\n  JapaneseHelper,\r\n  IslamicHelper,\r\n  IslamicUmalquraHelper,\r\n  IslamicTblaHelper,\r\n  IslamicCivilHelper,\r\n  IslamicRgsaHelper,\r\n  IslamicCcHelper\r\n]) {\r\n  const helper = new Helper();\r\n  // Construct a new NonIsoCalendar instance with the given Helper implementation that contains\r\n  // per-calendar logic.\r\n  impl[helper.id] = new NonIsoCalendar(helper);\r\n}\r\n\r\nfunction calendarImpl(calendar: BuiltinCalendarId) {\r\n  return impl[calendar];\r\n}\r\n// Probably not what the intrinsics mechanism was intended for, but view this as\r\n// an export of calendarImpl while avoiding circular dependencies\r\nDefineIntrinsic('calendarImpl', calendarImpl);\r\n","import { assert } from './assert';\r\nimport * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport {\r\n  CAL_ID,\r\n  CALENDAR,\r\n  CreateSlots,\r\n  DATE,\r\n  DATETIME,\r\n  DAYS,\r\n  EPOCHNANOSECONDS,\r\n  GetSlot,\r\n  HasSlot,\r\n  HOURS,\r\n  INST,\r\n  ISO_DATE,\r\n  ISO_DATE_TIME,\r\n  LOCALE,\r\n  MD,\r\n  MICROSECONDS,\r\n  MILLISECONDS,\r\n  MINUTES,\r\n  MONTHS,\r\n  NANOSECONDS,\r\n  OPTIONS,\r\n  ORIGINAL,\r\n  ResetSlot,\r\n  SECONDS,\r\n  SetSlot,\r\n  TIME,\r\n  TIME_FMT,\r\n  TZ_CANONICAL,\r\n  TZ_ORIGINAL,\r\n  WEEKS,\r\n  YEARS,\r\n  YM\r\n} from './slots';\r\nimport type { Temporal } from '..';\r\nimport type { DateTimeFormatParams as Params, DateTimeFormatReturn as Return } from './internaltypes';\r\n\r\n// Save the original Intl.DateTimeFormat, it will likely be overwritten\r\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\r\n\r\ntype LazySlot = typeof DATE | typeof YM | typeof MD | typeof TIME_FMT | typeof DATETIME | typeof INST;\r\n\r\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\r\n// so we'll only create those instances when we need them.\r\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\r\nfunction getSlotLazy(obj: DateTimeFormatImpl, slot: LazySlot) {\r\n  let val = GetSlot(obj, slot);\r\n  if (typeof val === 'function') {\r\n    // If we get here, `val` is an \"amender function\". It will take the user's\r\n    // options and transform them into suitable options to be passed into the\r\n    // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\r\n    // will vary depending on the Temporal type, so that's why we store separate\r\n    // formatters in separate props on the polyfill's DateTimeFormat instances.\r\n    // The efficiency happens because we don't create an (expensive) formatter\r\n    // until the user calls toLocaleString for that Temporal type.\r\n    val = new OriginalIntlDateTimeFormat(GetSlot(obj, LOCALE), val(GetSlot(obj, OPTIONS)));\r\n    ResetSlot(obj, slot, val);\r\n  }\r\n  return val;\r\n}\r\n\r\nfunction createDateTimeFormat(\r\n  dtf: DateTimeFormatImpl,\r\n  locale: Params['constructor'][0],\r\n  optionsParam: Params['constructor'][1]\r\n) {\r\n  const hasOptions = typeof optionsParam !== 'undefined';\r\n  let options: Intl.DateTimeFormatOptions;\r\n  if (hasOptions) {\r\n    // Read all the options in the expected order and copy them to a\r\n    // null-prototype object with which we can do further operations\r\n    // unobservably\r\n    const props: (keyof Intl.DateTimeFormatOptions)[] = [\r\n      'localeMatcher',\r\n      'calendar',\r\n      'numberingSystem',\r\n      'hour12',\r\n      'hourCycle',\r\n      'timeZone',\r\n      'weekday',\r\n      'era',\r\n      'year',\r\n      'month',\r\n      'day',\r\n      'dayPeriod',\r\n      'hour',\r\n      'minute',\r\n      'second',\r\n      'fractionalSecondDigits',\r\n      'timeZoneName',\r\n      'formatMatcher',\r\n      'dateStyle',\r\n      'timeStyle'\r\n    ];\r\n    options = ES.ToObject(optionsParam);\r\n    const newOptions = Object.create(null);\r\n    for (let i = 0; i < props.length; i++) {\r\n      const prop = props[i];\r\n      if (Object.prototype.hasOwnProperty.call(options, prop)) {\r\n        newOptions[prop] = options[prop];\r\n      }\r\n    }\r\n    options = newOptions;\r\n  } else {\r\n    options = Object.create(null);\r\n  }\r\n  const original = new OriginalIntlDateTimeFormat(locale, options);\r\n  const ro = original.resolvedOptions();\r\n\r\n  CreateSlots(dtf);\r\n\r\n  // DateTimeFormat instances are very expensive to create. Therefore, they will\r\n  // be lazily created only when needed, using the locale and options provided.\r\n  // But it's possible for callers to mutate those inputs before lazy creation\r\n  // happens. For this reason, we clone the inputs instead of caching the\r\n  // original objects. To avoid the complexity of deep cloning any inputs that\r\n  // are themselves objects (e.g. the locales array, or options property values\r\n  // that will be coerced to strings), we rely on `resolvedOptions()` to do the\r\n  // coercion and cloning for us. Unfortunately, we can't just use the resolved\r\n  // options as-is because our options-amending logic adds additional fields if\r\n  // the user doesn't supply any unit fields like year, month, day, hour, etc.\r\n  // Therefore, we limit the properties in the clone to properties that were\r\n  // present in the original input.\r\n  if (hasOptions) {\r\n    const clonedResolved = Object.assign(Object.create(null), ro);\r\n    for (const prop in clonedResolved) {\r\n      if (!Object.prototype.hasOwnProperty.call(options, prop)) {\r\n        delete clonedResolved[prop as keyof typeof clonedResolved];\r\n      }\r\n    }\r\n    // hour12/hourCycle don't show up in resolvedOptions() unless the chosen\r\n    // format includes an hour component, so copy them explicitly in case they\r\n    // would otherwise be lost\r\n    clonedResolved.hour12 = options.hour12;\r\n    clonedResolved.hourCycle = options.hourCycle;\r\n    SetSlot(dtf, OPTIONS, clonedResolved);\r\n  } else {\r\n    SetSlot(dtf, OPTIONS, options);\r\n  }\r\n\r\n  SetSlot(dtf, LOCALE, ro.locale);\r\n  SetSlot(dtf, ORIGINAL, original);\r\n  SetSlot(dtf, TZ_CANONICAL, ro.timeZone);\r\n  SetSlot(dtf, CAL_ID, ro.calendar);\r\n  SetSlot(dtf, DATE, dateAmend);\r\n  SetSlot(dtf, YM, yearMonthAmend);\r\n  SetSlot(dtf, MD, monthDayAmend);\r\n  SetSlot(dtf, TIME_FMT, timeAmend);\r\n  SetSlot(dtf, DATETIME, datetimeAmend);\r\n  SetSlot(dtf, INST, instantAmend);\r\n\r\n  // Save the original time zone, for a few reasons:\r\n  // - Clearer error messages\r\n  // - More clearly follows the spec for InitializeDateTimeFormat\r\n  // - Because it follows the spec more closely, will make it easier to integrate\r\n  //   support of offset strings and other potential changes like proposal-canonical-tz.\r\n  const timeZoneOption = hasOptions ? options.timeZone : undefined;\r\n  if (timeZoneOption === undefined) {\r\n    SetSlot(dtf, TZ_ORIGINAL, ro.timeZone);\r\n  } else {\r\n    const id = ES.ToString(timeZoneOption);\r\n    if (id.startsWith('−')) {\r\n      // The initial (Node 23) implementation of offset time zones allowed use\r\n      // of the Unicode minus sign, which was disallowed by a later spec change.\r\n      throw new RangeError('Unicode minus (U+2212) is not supported in time zone offsets');\r\n    }\r\n    // store a normalized identifier\r\n    SetSlot(dtf, TZ_ORIGINAL, ES.ToTemporalTimeZoneIdentifier(id));\r\n  }\r\n  return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\r\n}\r\n\r\nfunction IsPatchedDateTimeFormat(item: unknown): item is DateTimeFormatImpl {\r\n  return HasSlot(item, ORIGINAL);\r\n}\r\n\r\nclass DateTimeFormatImpl {\r\n  constructor(locales: Params['constructor'][0] = undefined, options: Params['constructor'][1] = undefined) {\r\n    createDateTimeFormat(this, locales, options);\r\n  }\r\n\r\n  get format() {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    const boundFormat = format.bind(this);\r\n    Object.defineProperties(boundFormat, {\r\n      length: { value: 1, enumerable: false, writable: false, configurable: true },\r\n      name: { value: '', enumerable: false, writable: false, configurable: true }\r\n    });\r\n    return boundFormat;\r\n  }\r\n\r\n  formatRange(a: Params['formatRange'][0], b: Params['formatRange'][1]): Return['formatRange'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return formatRange.call(this, a, b);\r\n  }\r\n\r\n  formatToParts?<P extends readonly unknown[]>(\r\n    datetime: Params['formatToParts'][0],\r\n    ...rest: P\r\n  ): Return['formatToParts'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return formatToParts.call(this, datetime, ...rest);\r\n  }\r\n\r\n  formatRangeToParts?(\r\n    a: Params['formatRangeToParts'][0],\r\n    b: Params['formatRangeToParts'][1]\r\n  ): Return['formatRangeToParts'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return formatRangeToParts.call(this, a, b);\r\n  }\r\n\r\n  resolvedOptions(): Return['resolvedOptions'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return resolvedOptions.call(this);\r\n  }\r\n}\r\n\r\nif (!('formatToParts' in OriginalIntlDateTimeFormat.prototype)) {\r\n  delete DateTimeFormatImpl.prototype.formatToParts;\r\n}\r\n\r\nif (!('formatRangeToParts' in OriginalIntlDateTimeFormat.prototype)) {\r\n  delete DateTimeFormatImpl.prototype.formatRangeToParts;\r\n}\r\nexport type { DateTimeFormatImpl };\r\n\r\ninterface DateTimeFormatInterface {\r\n  (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\r\n  new (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\r\n  supportedLocalesOf: typeof Intl.DateTimeFormat.supportedLocalesOf;\r\n}\r\n\r\n// A non-class constructor is needed because Intl.DateTimeFormat must be able to\r\n// be called without 'new'\r\nexport const DateTimeFormat = function (\r\n  locales: Params['constructor'][0] = undefined,\r\n  options: Params['constructor'][1] = undefined\r\n): DateTimeFormatImpl {\r\n  return new DateTimeFormatImpl(locales, options);\r\n} as unknown as DateTimeFormatInterface;\r\nDateTimeFormatImpl.prototype.constructor = DateTimeFormat;\r\n\r\nObject.defineProperty(DateTimeFormat, 'prototype', {\r\n  value: DateTimeFormatImpl.prototype,\r\n  writable: false,\r\n  enumerable: false,\r\n  configurable: false\r\n});\r\nDateTimeFormat.supportedLocalesOf = OriginalIntlDateTimeFormat.supportedLocalesOf;\r\nMakeIntrinsicClass(DateTimeFormat as unknown as typeof Intl.DateTimeFormat, 'Intl.DateTimeFormat');\r\n\r\nfunction resolvedOptions(this: DateTimeFormatImpl): Return['resolvedOptions'] {\r\n  const resolved = GetSlot(this, ORIGINAL).resolvedOptions();\r\n  resolved.timeZone = GetSlot(this, TZ_ORIGINAL);\r\n  return resolved;\r\n}\r\n\r\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\r\n// And if so, why doesn't formatRange also accept extra params?\r\nfunction format<P extends readonly unknown[]>(\r\n  this: DateTimeFormatImpl,\r\n  datetime: Params['format'][0],\r\n  ...rest: P\r\n): Return['format'] {\r\n  let overrides = extractOverrides(datetime, this);\r\n  let formatter, formatArgs: [Params['format'][0], ...unknown[]];\r\n  if (overrides.formatter) {\r\n    formatter = overrides.formatter;\r\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\r\n  } else {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n    formatArgs = [datetime, ...rest];\r\n  }\r\n  return formatter.format(...(formatArgs as [number | Date | undefined]));\r\n}\r\n\r\nfunction formatToParts<P extends readonly unknown[]>(\r\n  this: DateTimeFormatImpl,\r\n  datetime: Params['formatToParts'][0],\r\n  ...rest: P\r\n): Return['formatToParts'] {\r\n  let overrides = extractOverrides(datetime, this);\r\n  let formatter, formatArgs;\r\n  if (overrides.formatter) {\r\n    formatter = overrides.formatter;\r\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\r\n  } else {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n    formatArgs = [datetime, ...rest];\r\n  }\r\n  return formatter.formatToParts(...(formatArgs as [number | Date | undefined]));\r\n}\r\n\r\nfunction formatRange(this: DateTimeFormatImpl, aParam: Params['formatRange'][0], bParam: Params['formatRange'][1]) {\r\n  if (aParam === undefined || bParam === undefined) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\r\n  }\r\n  const a = toDateTimeFormattable(aParam);\r\n  const b = toDateTimeFormattable(bParam);\r\n  let formatArgs = [a, b] as const;\r\n  let formatter;\r\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\r\n  }\r\n  if (isTemporalObject(a)) {\r\n    if (!sameTemporalType(a, b)) {\r\n      throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\r\n    }\r\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\r\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\r\n    if (aformatter) {\r\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\r\n      formatter = aformatter;\r\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\r\n    }\r\n  }\r\n  if (!formatter) {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n  }\r\n  return formatter.formatRange(...(formatArgs as [number, number]));\r\n}\r\n\r\nfunction formatRangeToParts(\r\n  this: DateTimeFormatImpl,\r\n  aParam: Params['formatRangeToParts'][0],\r\n  bParam: Params['formatRangeToParts'][1]\r\n) {\r\n  if (aParam === undefined || bParam === undefined) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\r\n  }\r\n  const a = toDateTimeFormattable(aParam);\r\n  const b = toDateTimeFormattable(bParam);\r\n  let formatArgs = [a, b] as const;\r\n  let formatter;\r\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\r\n  }\r\n  if (isTemporalObject(a)) {\r\n    if (!sameTemporalType(a, b)) {\r\n      throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\r\n    }\r\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\r\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\r\n    if (aformatter) {\r\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\r\n      formatter = aformatter;\r\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\r\n    }\r\n  }\r\n  if (!formatter) {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n  }\r\n  return formatter.formatRangeToParts(...(formatArgs as [number, number]));\r\n}\r\n\r\n// \"false\" is a signal to delete this option\r\ntype MaybeFalseOptions = {\r\n  [K in keyof Intl.DateTimeFormatOptions]?: Intl.DateTimeFormatOptions[K] | false;\r\n};\r\n\r\nfunction amend(optionsParam: Intl.DateTimeFormatOptions = {}, amended: MaybeFalseOptions = {}) {\r\n  const options = Object.assign({}, optionsParam);\r\n  const props = [\r\n    'year',\r\n    'month',\r\n    'day',\r\n    'hour',\r\n    'minute',\r\n    'second',\r\n    'weekday',\r\n    'dayPeriod',\r\n    'timeZoneName',\r\n    'dateStyle',\r\n    'timeStyle'\r\n  ] as const;\r\n  for (let i = 0; i < props.length; i++) {\r\n    const opt = props[i];\r\n    // TODO: can this be typed more cleanly?\r\n    type OptionMaybeFalse = (typeof options)[typeof opt] | false;\r\n    (options[opt] as OptionMaybeFalse) = opt in amended ? amended[opt] : options[opt];\r\n    if ((options[opt] as OptionMaybeFalse) === false || options[opt] === undefined) delete options[opt];\r\n  }\r\n  return options;\r\n}\r\n\r\ntype OptionsType<T extends TypesWithToLocaleString> = NonNullable<Parameters<T['toLocaleString']>[1]>;\r\n\r\nfunction timeAmend(originalOptions: OptionsType<Temporal.PlainTime>) {\r\n  const options = amend(originalOptions, {\r\n    year: false,\r\n    month: false,\r\n    day: false,\r\n    weekday: false,\r\n    timeZoneName: false,\r\n    dateStyle: false\r\n  });\r\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\r\n    // Try to fake what timeStyle should do if not printing the time zone name\r\n    delete options.timeStyle;\r\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\r\n  }\r\n  if (!hasTimeOptions(options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format Temporal.PlainTime with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, {\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction yearMonthAmend(originalOptions: OptionsType<Temporal.PlainYearMonth>) {\r\n  // Try to fake what dateStyle should do for dates without a day. This is not\r\n  // accurate for locales that always print the era\r\n  const dateStyleHacks = {\r\n    short: { year: '2-digit', month: 'numeric' },\r\n    medium: { year: 'numeric', month: 'short' },\r\n    long: { year: 'numeric', month: 'long' },\r\n    full: { year: 'numeric', month: 'long' }\r\n  };\r\n  const options = amend(originalOptions, {\r\n    day: false,\r\n    hour: false,\r\n    minute: false,\r\n    second: false,\r\n    weekday: false,\r\n    dayPeriod: false,\r\n    timeZoneName: false,\r\n    timeStyle: false\r\n  });\r\n  if ('dateStyle' in options && options.dateStyle) {\r\n    const style = options.dateStyle;\r\n    delete options.dateStyle;\r\n    Object.assign(options, dateStyleHacks[style]);\r\n  }\r\n  if (!('year' in options || 'month' in options || 'era' in options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainYearMonth with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, { year: 'numeric', month: 'numeric' });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction monthDayAmend(originalOptions: OptionsType<Temporal.PlainMonthDay>) {\r\n  // Try to fake what dateStyle should do for dates without a day\r\n  const dateStyleHacks = {\r\n    short: { month: 'numeric', day: 'numeric' },\r\n    medium: { month: 'short', day: 'numeric' },\r\n    long: { month: 'long', day: 'numeric' },\r\n    full: { month: 'long', day: 'numeric' }\r\n  };\r\n  const options = amend(originalOptions, {\r\n    year: false,\r\n    hour: false,\r\n    minute: false,\r\n    second: false,\r\n    weekday: false,\r\n    dayPeriod: false,\r\n    timeZoneName: false,\r\n    timeStyle: false\r\n  });\r\n  if ('dateStyle' in options && options.dateStyle) {\r\n    const style = options.dateStyle;\r\n    delete options.dateStyle;\r\n    Object.assign(options, dateStyleHacks[style]);\r\n  }\r\n  if (!('month' in options || 'day' in options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainMonthDay with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, { month: 'numeric', day: 'numeric' });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction dateAmend(originalOptions: OptionsType<Temporal.PlainDate>) {\r\n  const options = amend(originalOptions, {\r\n    hour: false,\r\n    minute: false,\r\n    second: false,\r\n    dayPeriod: false,\r\n    timeZoneName: false,\r\n    timeStyle: false\r\n  });\r\n  if (!hasDateOptions(options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainDate with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, {\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction datetimeAmend(originalOptions: OptionsType<Temporal.PlainDateTime>) {\r\n  const options = amend(originalOptions, { timeZoneName: false });\r\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\r\n    // Try to fake what timeStyle should do if not printing the time zone name\r\n    delete options.timeStyle;\r\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\r\n\r\n    // If moving to a fake timeStyle while dateStyle is present, we also have to\r\n    // move to a fake dateStyle. dateStyle is mutually exclusive with hour etc.\r\n    if (options.dateStyle) {\r\n      const dateStyleHacks = {\r\n        short: { year: 'numeric', month: 'numeric', day: 'numeric' },\r\n        medium: { year: 'numeric', month: 'short', day: 'numeric' },\r\n        long: { year: 'numeric', month: 'long', day: 'numeric' },\r\n        full: { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' }\r\n      };\r\n      Object.assign(options, dateStyleHacks[options.dateStyle]);\r\n      delete options.dateStyle;\r\n    }\r\n  }\r\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainDateTime with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, {\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction instantAmend(optionsParam: OptionsType<Temporal.Instant>) {\r\n  let options = optionsParam;\r\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\r\n    options = Object.assign({}, options, {\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction hasDateOptions(options: OptionsType<TypesWithToLocaleString>) {\r\n  return (\r\n    'year' in options ||\r\n    'month' in options ||\r\n    'day' in options ||\r\n    'weekday' in options ||\r\n    'dateStyle' in options ||\r\n    'era' in options\r\n  );\r\n}\r\n\r\nfunction hasTimeOptions(options: OptionsType<TypesWithToLocaleString>) {\r\n  return (\r\n    'hour' in options ||\r\n    'minute' in options ||\r\n    'second' in options ||\r\n    'timeStyle' in options ||\r\n    'dayPeriod' in options ||\r\n    'fractionalSecondDigits' in options\r\n  );\r\n}\r\n\r\nfunction hasAnyDateTimeOptions(originalOptions: OptionsType<TypesWithToLocaleString>) {\r\n  return (\r\n    hasDateOptions(originalOptions) ||\r\n    hasTimeOptions(originalOptions) ||\r\n    'dateStyle' in originalOptions ||\r\n    'timeStyle' in originalOptions ||\r\n    'timeZoneName' in originalOptions\r\n  );\r\n}\r\n\r\nfunction isTemporalObject(\r\n  obj: unknown\r\n): obj is\r\n  | Temporal.PlainDate\r\n  | Temporal.PlainTime\r\n  | Temporal.PlainDateTime\r\n  | Temporal.ZonedDateTime\r\n  | Temporal.PlainYearMonth\r\n  | Temporal.PlainMonthDay\r\n  | Temporal.Instant {\r\n  return (\r\n    ES.IsTemporalDate(obj) ||\r\n    ES.IsTemporalTime(obj) ||\r\n    ES.IsTemporalDateTime(obj) ||\r\n    ES.IsTemporalZonedDateTime(obj) ||\r\n    ES.IsTemporalYearMonth(obj) ||\r\n    ES.IsTemporalMonthDay(obj) ||\r\n    ES.IsTemporalInstant(obj)\r\n  );\r\n}\r\n\r\nfunction toDateTimeFormattable(value: unknown) {\r\n  if (isTemporalObject(value)) return value;\r\n  return ES.ToNumber(value);\r\n}\r\n\r\nfunction sameTemporalType(x: unknown, y: unknown) {\r\n  if (!isTemporalObject(x) || !isTemporalObject(y)) return false;\r\n  if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y)) return false;\r\n  if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y)) return false;\r\n  if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y)) return false;\r\n  if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y)) return false;\r\n  if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y)) return false;\r\n  if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y)) return false;\r\n  if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y)) return false;\r\n  return true;\r\n}\r\n\r\ntype TypesWithToLocaleString =\r\n  | Temporal.PlainDateTime\r\n  | Temporal.PlainDate\r\n  | Temporal.PlainTime\r\n  | Temporal.PlainYearMonth\r\n  | Temporal.PlainMonthDay\r\n  | Temporal.ZonedDateTime\r\n  | Temporal.Instant;\r\n\r\nfunction extractOverrides(temporalObj: Params['format'][0], main: DateTimeFormatImpl) {\r\n  if (ES.IsTemporalTime(temporalObj)) {\r\n    const isoDateTime = {\r\n      isoDate: { year: 1970, month: 1, day: 1 },\r\n      time: GetSlot(temporalObj, TIME)\r\n    };\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, TIME_FMT)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalYearMonth(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== mainCalendar) {\r\n      throw new RangeError(\r\n        `cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${mainCalendar}`\r\n      );\r\n    }\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, YM)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalMonthDay(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== mainCalendar) {\r\n      throw new RangeError(\r\n        `cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${mainCalendar}`\r\n      );\r\n    }\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, MD)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalDate(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\r\n      throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${mainCalendar}`);\r\n    }\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, DATE)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalDateTime(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\r\n      throw new RangeError(\r\n        `cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${mainCalendar}`\r\n      );\r\n    }\r\n    const isoDateTime = GetSlot(temporalObj, ISO_DATE_TIME);\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, DATETIME)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalZonedDateTime(temporalObj)) {\r\n    throw new TypeError(\r\n      'Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.'\r\n    );\r\n  }\r\n\r\n  if (ES.IsTemporalInstant(temporalObj)) {\r\n    return {\r\n      epochNs: GetSlot(temporalObj, EPOCHNANOSECONDS),\r\n      formatter: getSlotLazy(main, INST)\r\n    };\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\nfunction temporalDurationToCompatibilityRecord(duration: Temporal.Duration) {\r\n  const record = Object.create(null);\r\n  record.years = GetSlot(duration, YEARS);\r\n  record.months = GetSlot(duration, MONTHS);\r\n  record.weeks = GetSlot(duration, WEEKS);\r\n  record.days = GetSlot(duration, DAYS);\r\n  record.hours = GetSlot(duration, HOURS);\r\n  record.minutes = GetSlot(duration, MINUTES);\r\n  record.seconds = GetSlot(duration, SECONDS);\r\n  record.milliseconds = GetSlot(duration, MILLISECONDS);\r\n  record.microseconds = GetSlot(duration, MICROSECONDS);\r\n  record.nanoseconds = GetSlot(duration, NANOSECONDS);\r\n  return record;\r\n}\r\n\r\nconst { format: IntlDurationFormatPrototypeFormat, formatToParts: IntlDurationFormatPrototypeFormatToParts } =\r\n  Intl.DurationFormat?.prototype ?? Object.create(null);\r\n\r\nexport function ModifiedIntlDurationFormatPrototypeFormat(\r\n  this: Intl.DurationFormat,\r\n  durationLike: Temporal.DurationLike\r\n) {\r\n  Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\r\n  const duration = ES.ToTemporalDuration(durationLike);\r\n  const record = temporalDurationToCompatibilityRecord(duration);\r\n  return IntlDurationFormatPrototypeFormat.call(this, record);\r\n}\r\n\r\nif (Intl.DurationFormat?.prototype) {\r\n  Intl.DurationFormat.prototype.format = ModifiedIntlDurationFormatPrototypeFormat;\r\n  Intl.DurationFormat.prototype.formatToParts = function formatToParts(durationLike: Temporal.DurationLike) {\r\n    Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\r\n    const duration = ES.ToTemporalDuration(durationLike);\r\n    const record = temporalDurationToCompatibilityRecord(duration);\r\n    return IntlDurationFormatPrototypeFormatToParts.call(this, record);\r\n  };\r\n}\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { EPOCHNANOSECONDS, GetSlot } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { InstantParams as Params, InstantReturn as Return } from './internaltypes';\r\n\r\nimport JSBI from 'jsbi';\r\n\r\nexport class Instant implements Temporal.Instant {\r\n  constructor(epochNanoseconds: bigint | JSBI) {\r\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\r\n    //       to improve the error message.\r\n    if (arguments.length < 1) {\r\n      throw new TypeError('missing argument: epochNanoseconds is required');\r\n    }\r\n\r\n    const ns = ES.ToBigInt(epochNanoseconds);\r\n    ES.CreateTemporalInstantSlots(this, ns);\r\n  }\r\n\r\n  get epochMilliseconds(): Return['epochMilliseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const value = GetSlot(this, EPOCHNANOSECONDS);\r\n    return ES.epochNsToMs(value, 'floor');\r\n  }\r\n  get epochNanoseconds(): Return['epochNanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\r\n  }\r\n\r\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.AddDurationToInstant('add', this, temporalDurationLike);\r\n  }\r\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.AddDurationToInstant('subtract', this, temporalDurationLike);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.DifferenceTemporalInstant('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.DifferenceTemporalInstant('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\r\n    const maximumIncrements = {\r\n      hour: 24,\r\n      minute: 1440,\r\n      second: 86400,\r\n      millisecond: 86400e3,\r\n      microsecond: 86400e6,\r\n      nanosecond: 86400e9\r\n    };\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximumIncrements[smallestUnit], true);\r\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\r\n    const roundedNs = ES.RoundTemporalInstant(ns, roundingIncrement, smallestUnit, roundingMode);\r\n    return ES.CreateTemporalInstant(roundedNs);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const other = ES.ToTemporalInstant(otherParam);\r\n    const one = GetSlot(this, EPOCHNANOSECONDS);\r\n    const two = GetSlot(other, EPOCHNANOSECONDS);\r\n    return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    let timeZone = resolvedOptions.timeZone;\r\n    if (timeZone !== undefined) timeZone = ES.ToTemporalTimeZoneIdentifier(timeZone);\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\r\n    const roundedNs = ES.RoundTemporalInstant(ns, increment, unit, roundingMode);\r\n    const roundedInstant = ES.CreateTemporalInstant(roundedNs);\r\n    return ES.TemporalInstantToString(roundedInstant, timeZone, precision);\r\n  }\r\n  toJSON(): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.TemporalInstantToString(this, undefined, 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('Instant');\r\n  }\r\n  toZonedDateTimeISO(timeZoneParam: Params['toZonedDateTimeISO'][0]): Return['toZonedDateTimeISO'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\r\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, 'iso8601');\r\n  }\r\n\r\n  static fromEpochMilliseconds(epochMilliseconds: Params['fromEpochMilliseconds'][0]): Return['fromEpochMilliseconds'] {\r\n    const epochNanoseconds = ES.epochMsToNs(ES.ToNumber(epochMilliseconds));\r\n    return ES.CreateTemporalInstant(epochNanoseconds);\r\n  }\r\n  static fromEpochNanoseconds(\r\n    epochNanosecondsParam: Params['fromEpochNanoseconds'][0]\r\n  ): Return['fromEpochNanoseconds'] {\r\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\r\n    return ES.CreateTemporalInstant(epochNanoseconds);\r\n  }\r\n  static from(item: Params['from'][0]): Return['from'] {\r\n    return ES.ToTemporalInstant(item);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalInstant(oneParam);\r\n    const two = ES.ToTemporalInstant(twoParam);\r\n    const oneNs = GetSlot(one, EPOCHNANOSECONDS);\r\n    const twoNs = GetSlot(two, EPOCHNANOSECONDS);\r\n    if (JSBI.lessThan(oneNs, twoNs)) return -1;\r\n    if (JSBI.greaterThan(oneNs, twoNs)) return 1;\r\n    return 0;\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.Instant';\r\n}\r\n\r\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, GetSlot, ISO_DATE, TIME } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { CalendarDateRecord, PlainDateParams as Params, PlainDateReturn as Return } from './internaltypes';\r\n\r\nexport class PlainDate implements Temporal.PlainDate {\r\n  constructor(\r\n    isoYear: Params['constructor'][0],\r\n    isoMonth: Params['constructor'][1],\r\n    isoDay: Params['constructor'][2],\r\n    calendarParam: Params['constructor'][3] = 'iso8601'\r\n  ) {\r\n    const year = ES.ToIntegerWithTruncation(isoYear);\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const day = ES.ToIntegerWithTruncation(isoDay);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n    ES.RejectISODate(year, month, day);\r\n\r\n    ES.CreateTemporalDateSlots(this, { year, month, day }, calendar);\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get dayOfWeek(): Return['dayOfWeek'] {\r\n    return getCalendarProperty(this, 'dayOfWeek');\r\n  }\r\n  get dayOfYear(): Return['dayOfYear'] {\r\n    return getCalendarProperty(this, 'dayOfYear');\r\n  }\r\n  get weekOfYear(): Return['weekOfYear'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.week;\r\n  }\r\n  get yearOfWeek(): Return['yearOfWeek'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.year;\r\n  }\r\n  get daysInWeek(): Return['daysInWeek'] {\r\n    return getCalendarProperty(this, 'daysInWeek');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  with(temporalDateLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    if (!ES.IsObject(temporalDateLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalDateLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\r\n    const partialDate = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalDateLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      [],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialDate);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const isoDate = ES.CalendarDateFromFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalDate(isoDate, calendar);\r\n  }\r\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\r\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE), calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.AddDurationToDate('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.AddDurationToDate('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.DifferenceTemporalPlainDate('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.DifferenceTemporalPlainDate('since', this, other, options);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const other = ES.ToTemporalDate(otherParam);\r\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    return ES.TemporalDateToString(this, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.TemporalDateToString(this);\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainDate');\r\n  }\r\n  toPlainDateTime(temporalTime: Params['toPlainDateTime'][0] = undefined): Return['toPlainDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE), time);\r\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\r\n  }\r\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n\r\n    let timeZone, temporalTime;\r\n    if (ES.IsObject(item)) {\r\n      const timeZoneLike = item.timeZone;\r\n      if (timeZoneLike === undefined) {\r\n        timeZone = ES.ToTemporalTimeZoneIdentifier(item);\r\n      } else {\r\n        timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneLike);\r\n        temporalTime = item.plainTime;\r\n      }\r\n    } else {\r\n      timeZone = ES.ToTemporalTimeZoneIdentifier(item);\r\n    }\r\n\r\n    const isoDate = GetSlot(this, ISO_DATE);\r\n    let epochNs;\r\n    if (temporalTime === undefined) {\r\n      epochNs = ES.GetStartOfDay(timeZone, isoDate);\r\n    } else {\r\n      temporalTime = ES.ToTemporalTime(temporalTime);\r\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoDate, GetSlot(temporalTime, TIME));\r\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, isoDateTime, 'compatible');\r\n    }\r\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\r\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, 'constrain');\r\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\r\n  }\r\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\r\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, 'constrain');\r\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalDate(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalDate(oneParam);\r\n    const two = ES.ToTemporalDate(twoParam);\r\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainDate';\r\n}\r\n\r\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  date: Temporal.PlainDate,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(date, ES.IsTemporalDate);\r\n  const isoDate = GetSlot(date, ISO_DATE);\r\n  return ES.calendarImplForObj(date).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\n\r\nimport { CALENDAR, GetSlot, ISO_DATE_TIME } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { CalendarDateRecord, PlainDateTimeParams as Params, PlainDateTimeReturn as Return } from './internaltypes';\r\n\r\nexport class PlainDateTime implements Temporal.PlainDateTime {\r\n  constructor(\r\n    isoYear: Params['constructor'][0],\r\n    isoMonth: Params['constructor'][1],\r\n    isoDay: Params['constructor'][2],\r\n    hourParam: Params['constructor'][3] = 0,\r\n    minuteParam: Params['constructor'][4] = 0,\r\n    secondParam: Params['constructor'][5] = 0,\r\n    millisecondParam: Params['constructor'][6] = 0,\r\n    microsecondParam: Params['constructor'][7] = 0,\r\n    nanosecondParam: Params['constructor'][8] = 0,\r\n    calendarParam: Params['constructor'][9] = 'iso8601'\r\n  ) {\r\n    const year = ES.ToIntegerWithTruncation(isoYear);\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const day = ES.ToIntegerWithTruncation(isoDay);\r\n    const hour = hourParam === undefined ? 0 : ES.ToIntegerWithTruncation(hourParam);\r\n    const minute = minuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(minuteParam);\r\n    const second = secondParam === undefined ? 0 : ES.ToIntegerWithTruncation(secondParam);\r\n    const millisecond = millisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(millisecondParam);\r\n    const microsecond = microsecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(microsecondParam);\r\n    const nanosecond = nanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(nanosecondParam);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n\r\n    ES.RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\r\n\r\n    ES.CreateTemporalDateTimeSlots(\r\n      this,\r\n      { isoDate: { year, month, day }, time: { hour, minute, second, millisecond, microsecond, nanosecond } },\r\n      calendar\r\n    );\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get hour(): Return['hour'] {\r\n    return getTimeProperty(this, 'hour');\r\n  }\r\n  get minute(): Return['minute'] {\r\n    return getTimeProperty(this, 'minute');\r\n  }\r\n  get second(): Return['second'] {\r\n    return getTimeProperty(this, 'second');\r\n  }\r\n  get millisecond(): Return['millisecond'] {\r\n    return getTimeProperty(this, 'millisecond');\r\n  }\r\n  get microsecond(): Return['microsecond'] {\r\n    return getTimeProperty(this, 'microsecond');\r\n  }\r\n  get nanosecond(): Return['nanosecond'] {\r\n    return getTimeProperty(this, 'nanosecond');\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get dayOfWeek(): Return['dayOfWeek'] {\r\n    return getCalendarProperty(this, 'dayOfWeek');\r\n  }\r\n  get dayOfYear(): Return['dayOfYear'] {\r\n    return getCalendarProperty(this, 'dayOfYear');\r\n  }\r\n  get weekOfYear(): Return['weekOfYear'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.week;\r\n  }\r\n  get yearOfWeek(): Return['yearOfWeek'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.year;\r\n  }\r\n  get daysInWeek(): Return['daysInWeek'] {\r\n    return getCalendarProperty(this, 'daysInWeek');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  with(temporalDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    if (!ES.IsObject(temporalDateTimeLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalDateTimeLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\r\n    let fields = {\r\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\r\n      ...isoDateTime.time\r\n    };\r\n    const partialDateTime = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalDateTimeLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialDateTime);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalDateTime(newDateTime, calendar);\r\n  }\r\n  withPlainTime(temporalTime: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE_TIME).isoDate, time);\r\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\r\n  }\r\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\r\n    return ES.CreateTemporalDateTime(GetSlot(this, ISO_DATE_TIME), calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.AddDurationToDateTime('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.AddDurationToDateTime('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.DifferenceTemporalPlainDateTime('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.DifferenceTemporalPlainDateTime('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\r\n    const maximumIncrements = {\r\n      day: 1,\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    };\r\n    const maximum = maximumIncrements[smallestUnit];\r\n    const inclusive = maximum === 1;\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\r\n\r\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\r\n    if (roundingIncrement === 1 && smallestUnit === 'nanosecond') {\r\n      return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\r\n    }\r\n    const result = ES.RoundISODateTime(isoDateTime, roundingIncrement, smallestUnit, roundingMode);\r\n\r\n    return ES.CreateTemporalDateTime(result, GetSlot(this, CALENDAR));\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const other = ES.ToTemporalDateTime(otherParam);\r\n    if (ES.CompareISODateTime(GetSlot(this, ISO_DATE_TIME), GetSlot(other, ISO_DATE_TIME)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    const result = ES.RoundISODateTime(GetSlot(this, ISO_DATE_TIME), increment, unit, roundingMode);\r\n    ES.RejectDateTimeRange(result);\r\n    return ES.ISODateTimeToString(result, GetSlot(this, CALENDAR), precision, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.ISODateTimeToString(GetSlot(this, ISO_DATE_TIME), GetSlot(this, CALENDAR), 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainDateTime');\r\n  }\r\n\r\n  toZonedDateTime(\r\n    temporalTimeZoneLike: Params['toZonedDateTime'][0],\r\n    options: Params['toZonedDateTime'][1] = undefined\r\n  ): Return['toZonedDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\r\n    const epochNs = ES.GetEpochNanosecondsFor(timeZone, GetSlot(this, ISO_DATE_TIME), disambiguation);\r\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainDate(): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE_TIME).isoDate, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainTime(): Return['toPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.CreateTemporalTime(GetSlot(this, ISO_DATE_TIME).time);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalDateTime(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalDateTime(oneParam);\r\n    const two = ES.ToTemporalDateTime(twoParam);\r\n    return ES.CompareISODateTime(GetSlot(one, ISO_DATE_TIME), GetSlot(two, ISO_DATE_TIME));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainDateTime';\r\n}\r\n\r\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  dt: Temporal.PlainDateTime,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\r\n  const isoDate = GetSlot(dt, ISO_DATE_TIME).isoDate;\r\n  return ES.calendarImplForObj(dt).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n\r\nfunction getTimeProperty(dt: Temporal.PlainDateTime, prop: Temporal.TimeUnit) {\r\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\r\n  return GetSlot(dt, ISO_DATE_TIME).time[prop];\r\n}\r\n","import { DEBUG } from './debug';\r\nimport { assert } from './assert';\r\nimport * as ES from './ecmascript';\r\nimport { ModifiedIntlDurationFormatPrototypeFormat } from './intl';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport {\r\n  YEARS,\r\n  MONTHS,\r\n  WEEKS,\r\n  DAYS,\r\n  HOURS,\r\n  MINUTES,\r\n  SECONDS,\r\n  MILLISECONDS,\r\n  MICROSECONDS,\r\n  NANOSECONDS,\r\n  CALENDAR,\r\n  EPOCHNANOSECONDS,\r\n  CreateSlots,\r\n  GetSlot,\r\n  ISO_DATE,\r\n  SetSlot,\r\n  TIME_ZONE\r\n} from './slots';\r\nimport { TimeDuration } from './timeduration';\r\nimport type { Temporal } from '..';\r\nimport type { DurationParams as Params, DurationReturn as Return } from './internaltypes';\r\nimport JSBI from 'jsbi';\r\n\r\nexport class Duration implements Temporal.Duration {\r\n  constructor(\r\n    yearsParam: Params['constructor'][0] = 0,\r\n    monthsParam: Params['constructor'][1] = 0,\r\n    weeksParam: Params['constructor'][2] = 0,\r\n    daysParam: Params['constructor'][3] = 0,\r\n    hoursParam: Params['constructor'][4] = 0,\r\n    minutesParam: Params['constructor'][5] = 0,\r\n    secondsParam: Params['constructor'][6] = 0,\r\n    millisecondsParam: Params['constructor'][7] = 0,\r\n    microsecondsParam: Params['constructor'][8] = 0,\r\n    nanosecondsParam: Params['constructor'][9] = 0\r\n  ) {\r\n    const years = yearsParam === undefined ? 0 : ES.ToIntegerIfIntegral(yearsParam);\r\n    const months = monthsParam === undefined ? 0 : ES.ToIntegerIfIntegral(monthsParam);\r\n    const weeks = weeksParam === undefined ? 0 : ES.ToIntegerIfIntegral(weeksParam);\r\n    const days = daysParam === undefined ? 0 : ES.ToIntegerIfIntegral(daysParam);\r\n    const hours = hoursParam === undefined ? 0 : ES.ToIntegerIfIntegral(hoursParam);\r\n    const minutes = minutesParam === undefined ? 0 : ES.ToIntegerIfIntegral(minutesParam);\r\n    const seconds = secondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(secondsParam);\r\n    const milliseconds = millisecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(millisecondsParam);\r\n    const microseconds = microsecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(microsecondsParam);\r\n    const nanoseconds = nanosecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(nanosecondsParam);\r\n\r\n    ES.RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n\r\n    CreateSlots(this);\r\n    SetSlot(this, YEARS, years);\r\n    SetSlot(this, MONTHS, months);\r\n    SetSlot(this, WEEKS, weeks);\r\n    SetSlot(this, DAYS, days);\r\n    SetSlot(this, HOURS, hours);\r\n    SetSlot(this, MINUTES, minutes);\r\n    SetSlot(this, SECONDS, seconds);\r\n    SetSlot(this, MILLISECONDS, milliseconds);\r\n    SetSlot(this, MICROSECONDS, microseconds);\r\n    SetSlot(this, NANOSECONDS, nanoseconds);\r\n\r\n    if (DEBUG) {\r\n      Object.defineProperty(this, '_repr_', {\r\n        value: `Temporal.Duration <${ES.TemporalDurationToString(this, 'auto')}>`,\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: false\r\n      });\r\n    }\r\n  }\r\n  get years(): Return['years'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, YEARS);\r\n  }\r\n  get months(): Return['months'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MONTHS);\r\n  }\r\n  get weeks(): Return['weeks'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, WEEKS);\r\n  }\r\n  get days(): Return['days'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, DAYS);\r\n  }\r\n  get hours(): Return['hours'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, HOURS);\r\n  }\r\n  get minutes(): Return['minutes'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MINUTES);\r\n  }\r\n  get seconds(): Return['seconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, SECONDS);\r\n  }\r\n  get milliseconds(): Return['milliseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MILLISECONDS);\r\n  }\r\n  get microseconds(): Return['microseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MICROSECONDS);\r\n  }\r\n  get nanoseconds(): Return['nanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, NANOSECONDS);\r\n  }\r\n  get sign(): Return['sign'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.DurationSign(this);\r\n  }\r\n  get blank(): Return['blank'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.DurationSign(this) === 0;\r\n  }\r\n  with(durationLike: Params['with'][0]): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    const partialDuration = ES.ToTemporalPartialDurationRecord(durationLike);\r\n    const {\r\n      years = GetSlot(this, YEARS),\r\n      months = GetSlot(this, MONTHS),\r\n      weeks = GetSlot(this, WEEKS),\r\n      days = GetSlot(this, DAYS),\r\n      hours = GetSlot(this, HOURS),\r\n      minutes = GetSlot(this, MINUTES),\r\n      seconds = GetSlot(this, SECONDS),\r\n      milliseconds = GetSlot(this, MILLISECONDS),\r\n      microseconds = GetSlot(this, MICROSECONDS),\r\n      nanoseconds = GetSlot(this, NANOSECONDS)\r\n    } = partialDuration;\r\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n  }\r\n  negated(): Return['negated'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.CreateNegatedTemporalDuration(this);\r\n  }\r\n  abs(): Return['abs'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return new Duration(\r\n      Math.abs(GetSlot(this, YEARS)),\r\n      Math.abs(GetSlot(this, MONTHS)),\r\n      Math.abs(GetSlot(this, WEEKS)),\r\n      Math.abs(GetSlot(this, DAYS)),\r\n      Math.abs(GetSlot(this, HOURS)),\r\n      Math.abs(GetSlot(this, MINUTES)),\r\n      Math.abs(GetSlot(this, SECONDS)),\r\n      Math.abs(GetSlot(this, MILLISECONDS)),\r\n      Math.abs(GetSlot(this, MICROSECONDS)),\r\n      Math.abs(GetSlot(this, NANOSECONDS))\r\n    );\r\n  }\r\n  add(other: Params['add'][0]): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.AddDurations('add', this, other);\r\n  }\r\n  subtract(other: Params['subtract'][0]): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.AddDurations('subtract', this, other);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n\r\n    const existingLargestUnit = ES.DefaultTemporalLargestUnit(this);\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n\r\n    let largestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'largestUnit', 'datetime', undefined, ['auto']);\r\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(roundTo);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    let smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'datetime', undefined);\r\n\r\n    let smallestUnitPresent = true;\r\n    if (!smallestUnit) {\r\n      smallestUnitPresent = false;\r\n      smallestUnit = 'nanosecond';\r\n    }\r\n    const defaultLargestUnit = ES.LargerOfTwoTemporalUnits(existingLargestUnit, smallestUnit);\r\n    let largestUnitPresent = true;\r\n    if (!largestUnit) {\r\n      largestUnitPresent = false;\r\n      largestUnit = defaultLargestUnit;\r\n    }\r\n    if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\r\n    if (!smallestUnitPresent && !largestUnitPresent) {\r\n      throw new RangeError('at least one of smallestUnit or largestUnit is required');\r\n    }\r\n    if (ES.LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\r\n      throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\r\n    }\r\n\r\n    const maximumIncrements = {\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    } as { [k in Temporal.DateTimeUnit]?: number };\r\n    const maximum = maximumIncrements[smallestUnit];\r\n    if (maximum !== undefined) ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\r\n    if (roundingIncrement > 1 && ES.TemporalUnitCategory(smallestUnit) === 'date' && largestUnit !== smallestUnit) {\r\n      throw new RangeError('For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit');\r\n    }\r\n\r\n    if (zonedRelativeTo) {\r\n      let duration = ES.ToInternalDurationRecord(this);\r\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\r\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\r\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\r\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\r\n      duration = ES.DifferenceZonedDateTimeWithRounding(\r\n        relativeEpochNs,\r\n        targetEpochNs,\r\n        timeZone,\r\n        calendar,\r\n        largestUnit,\r\n        roundingIncrement,\r\n        smallestUnit,\r\n        roundingMode\r\n      );\r\n      if (ES.TemporalUnitCategory(largestUnit) === 'date') largestUnit = 'hour';\r\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\r\n    }\r\n\r\n    if (plainRelativeTo) {\r\n      let duration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n      const targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\r\n\r\n      // Delegate the date part addition to the calendar\r\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\r\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\r\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\r\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\r\n\r\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\r\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\r\n      duration = ES.DifferencePlainDateTimeWithRounding(\r\n        isoDateTime,\r\n        targetDateTime,\r\n        calendar,\r\n        largestUnit,\r\n        roundingIncrement,\r\n        smallestUnit,\r\n        roundingMode\r\n      );\r\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\r\n    }\r\n\r\n    // No reference date to calculate difference relative to\r\n    if (ES.IsCalendarUnit(existingLargestUnit)) {\r\n      throw new RangeError(`a starting point is required for ${existingLargestUnit}s balancing`);\r\n    }\r\n    if (ES.IsCalendarUnit(largestUnit)) {\r\n      throw new RangeError(`a starting point is required for ${largestUnit}s balancing`);\r\n    }\r\n    assert(!ES.IsCalendarUnit(smallestUnit), 'smallestUnit was larger than largestUnit');\r\n    let internalDuration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n    if (smallestUnit === 'day') {\r\n      // First convert time units up to days\r\n      const { quotient, remainder } = internalDuration.time.divmod(ES.DAY_NANOS);\r\n      let days = internalDuration.date.days + quotient + ES.TotalTimeDuration(remainder, 'day');\r\n      days = ES.RoundNumberToIncrement(days, roundingIncrement, roundingMode);\r\n      const dateDuration = { years: 0, months: 0, weeks: 0, days };\r\n      internalDuration = ES.CombineDateAndTimeDuration(dateDuration, TimeDuration.ZERO);\r\n    } else {\r\n      const timeDuration = ES.RoundTimeDuration(internalDuration.time, roundingIncrement, smallestUnit, roundingMode);\r\n      internalDuration = ES.CombineDateAndTimeDuration(ES.ZeroDateDuration(), timeDuration);\r\n    }\r\n    return ES.TemporalDurationFromInternal(internalDuration, largestUnit);\r\n  }\r\n  total(optionsParam: Params['total'][0]): Return['total'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n\r\n    if (optionsParam === undefined) throw new TypeError('options argument is required');\r\n    const options =\r\n      typeof optionsParam === 'string'\r\n        ? (ES.CreateOnePropObject('unit', optionsParam) as Exclude<typeof optionsParam, string>)\r\n        : ES.GetOptionsObject(optionsParam);\r\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(options);\r\n    const unit = ES.GetTemporalUnitValuedOption(options, 'unit', 'datetime', ES.REQUIRED);\r\n\r\n    if (zonedRelativeTo) {\r\n      const duration = ES.ToInternalDurationRecord(this);\r\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\r\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\r\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\r\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\r\n      return ES.DifferenceZonedDateTimeWithTotal(relativeEpochNs, targetEpochNs, timeZone, calendar, unit);\r\n    }\r\n\r\n    if (plainRelativeTo) {\r\n      const duration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n      let targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\r\n\r\n      // Delegate the date part addition to the calendar\r\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\r\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\r\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\r\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\r\n\r\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\r\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\r\n      return ES.DifferencePlainDateTimeWithTotal(isoDateTime, targetDateTime, calendar, unit);\r\n    }\r\n\r\n    // No reference date to calculate difference relative to\r\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\r\n    if (ES.IsCalendarUnit(largestUnit)) {\r\n      throw new RangeError(`a starting point is required for ${largestUnit}s total`);\r\n    }\r\n    if (ES.IsCalendarUnit(unit)) {\r\n      throw new RangeError(`a starting point is required for ${unit}s total`);\r\n    }\r\n    const duration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n    return ES.TotalTimeDuration(duration.time, unit);\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour' || smallestUnit === 'minute') {\r\n      throw new RangeError('smallestUnit must be a time unit other than \"hours\" or \"minutes\"');\r\n    }\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    ES.uncheckedAssertNarrowedType<Exclude<typeof precision, 'minute'>>(\r\n      precision,\r\n      'Precision cannot be \"minute\" because of RangeError above'\r\n    );\r\n\r\n    if (unit === 'nanosecond' && increment === 1) return ES.TemporalDurationToString(this, precision);\r\n\r\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\r\n    let internalDuration = ES.ToInternalDurationRecord(this);\r\n    const timeDuration = ES.RoundTimeDuration(internalDuration.time, increment, unit, roundingMode);\r\n    internalDuration = ES.CombineDateAndTimeDuration(internalDuration.date, timeDuration);\r\n    const roundedDuration = ES.TemporalDurationFromInternal(\r\n      internalDuration,\r\n      ES.LargerOfTwoTemporalUnits(largestUnit, 'second')\r\n    );\r\n    return ES.TemporalDurationToString(roundedDuration, precision);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.TemporalDurationToString(this, 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    if (typeof Intl.DurationFormat === 'function') {\r\n      const formatter = new Intl.DurationFormat(locales, options as Intl.DurationFormatOptions);\r\n      return ModifiedIntlDurationFormatPrototypeFormat.call(formatter, this);\r\n    }\r\n    console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\r\n    return ES.TemporalDurationToString(this, 'auto');\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('Duration');\r\n  }\r\n  static from(item: Params['from'][0]): Return['from'] {\r\n    return ES.ToTemporalDuration(item);\r\n  }\r\n  static compare(\r\n    oneParam: Params['compare'][0],\r\n    twoParam: Params['compare'][1],\r\n    options: Params['compare'][2] = undefined\r\n  ): Return['compare'] {\r\n    const one = ES.ToTemporalDuration(oneParam);\r\n    const two = ES.ToTemporalDuration(twoParam);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(resolvedOptions);\r\n\r\n    if (\r\n      GetSlot(one, YEARS) === GetSlot(two, YEARS) &&\r\n      GetSlot(one, MONTHS) === GetSlot(two, MONTHS) &&\r\n      GetSlot(one, WEEKS) === GetSlot(two, WEEKS) &&\r\n      GetSlot(one, DAYS) === GetSlot(two, DAYS) &&\r\n      GetSlot(one, HOURS) === GetSlot(two, HOURS) &&\r\n      GetSlot(one, MINUTES) === GetSlot(two, MINUTES) &&\r\n      GetSlot(one, SECONDS) === GetSlot(two, SECONDS) &&\r\n      GetSlot(one, MILLISECONDS) === GetSlot(two, MILLISECONDS) &&\r\n      GetSlot(one, MICROSECONDS) === GetSlot(two, MICROSECONDS) &&\r\n      GetSlot(one, NANOSECONDS) === GetSlot(two, NANOSECONDS)\r\n    ) {\r\n      return 0;\r\n    }\r\n\r\n    const largestUnit1 = ES.DefaultTemporalLargestUnit(one);\r\n    const largestUnit2 = ES.DefaultTemporalLargestUnit(two);\r\n    const duration1 = ES.ToInternalDurationRecord(one);\r\n    const duration2 = ES.ToInternalDurationRecord(two);\r\n\r\n    if (\r\n      zonedRelativeTo &&\r\n      (ES.TemporalUnitCategory(largestUnit1) === 'date' || ES.TemporalUnitCategory(largestUnit2) === 'date')\r\n    ) {\r\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\r\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\r\n      const epochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\r\n\r\n      const after1 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration1);\r\n      const after2 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration2);\r\n      return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(after1, after2)));\r\n    }\r\n\r\n    let d1 = duration1.date.days;\r\n    let d2 = duration2.date.days;\r\n    if (ES.IsCalendarUnit(largestUnit1) || ES.IsCalendarUnit(largestUnit2)) {\r\n      if (!plainRelativeTo) {\r\n        throw new RangeError('A starting point is required for years, months, or weeks comparison');\r\n      }\r\n      d1 = ES.DateDurationDays(duration1.date, plainRelativeTo);\r\n      d2 = ES.DateDurationDays(duration2.date, plainRelativeTo);\r\n    }\r\n    const timeDuration1 = duration1.time.add24HourDays(d1);\r\n    const timeDuration2 = duration2.time.add24HourDays(d2);\r\n    return timeDuration1.cmp(timeDuration2);\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.Duration';\r\n}\r\n\r\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { CalendarDateRecord, PlainMonthDayParams as Params, PlainMonthDayReturn as Return } from './internaltypes';\r\n\r\nexport class PlainMonthDay implements Temporal.PlainMonthDay {\r\n  constructor(\r\n    isoMonth: Params['constructor'][0],\r\n    isoDay: Params['constructor'][0],\r\n    calendarParam = 'iso8601',\r\n    referenceISOYear = 1972\r\n  ) {\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const day = ES.ToIntegerWithTruncation(isoDay);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n    const year = ES.ToIntegerWithTruncation(referenceISOYear);\r\n\r\n    ES.RejectISODate(year, month, day);\r\n    ES.CreateTemporalMonthDaySlots(this, { year, month, day }, calendar);\r\n  }\r\n\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n\r\n  with(temporalMonthDayLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    if (!ES.IsObject(temporalMonthDayLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalMonthDayLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\r\n    const partialMonthDay = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalMonthDayLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      [],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialMonthDay);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    const other = ES.ToTemporalMonthDay(otherParam);\r\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    return ES.TemporalMonthDayToString(this, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    return ES.TemporalMonthDayToString(this);\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainMonthDay');\r\n  }\r\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\r\n    const calendar = GetSlot(this, CALENDAR);\r\n\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\r\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['year'], [], []);\r\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\r\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\r\n    return ES.CreateTemporalDate(isoDate, calendar);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalMonthDay(item, options);\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainMonthDay';\r\n}\r\n\r\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  md: Temporal.PlainMonthDay,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(md, ES.IsTemporalMonthDay);\r\n  const isoDate = GetSlot(md, ISO_DATE);\r\n  return ES.calendarImplForObj(md).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n","import * as ES from './ecmascript';\r\nimport type { Temporal } from '..';\r\n\r\nfunction SystemDateTime(timeZone: string) {\r\n  return ES.GetISODateTimeFor(timeZone, ES.SystemUTCEpochNanoSeconds());\r\n}\r\n\r\nconst instant: (typeof Temporal.Now)['instant'] = () => {\r\n  return ES.CreateTemporalInstant(ES.SystemUTCEpochNanoSeconds());\r\n};\r\nconst plainDateTimeISO: (typeof Temporal.Now)['plainDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  const isoDateTime = SystemDateTime(timeZone);\r\n  return ES.CreateTemporalDateTime(isoDateTime, 'iso8601');\r\n};\r\nconst zonedDateTimeISO: (typeof Temporal.Now)['zonedDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), timeZone, 'iso8601');\r\n};\r\nconst plainDateISO: (typeof Temporal.Now)['plainDateISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  const isoDateTime = SystemDateTime(timeZone);\r\n  return ES.CreateTemporalDate(isoDateTime.isoDate, 'iso8601');\r\n};\r\nconst plainTimeISO: (typeof Temporal.Now)['plainTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  const isoDateTime = SystemDateTime(timeZone);\r\n  return ES.CreateTemporalTime(isoDateTime.time);\r\n};\r\nconst timeZoneId: (typeof Temporal.Now)['timeZoneId'] = () => {\r\n  return ES.DefaultTimeZone();\r\n};\r\n\r\nexport const Now: typeof Temporal.Now = {\r\n  instant,\r\n  plainDateTimeISO,\r\n  plainDateISO,\r\n  plainTimeISO,\r\n  timeZoneId,\r\n  zonedDateTimeISO,\r\n  [Symbol.toStringTag]: 'Temporal.Now'\r\n};\r\nObject.defineProperty(Now, Symbol.toStringTag, {\r\n  value: 'Temporal.Now',\r\n  writable: false,\r\n  enumerable: false,\r\n  configurable: true\r\n});\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\n\r\nimport { GetSlot, TIME } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { PlainTimeParams as Params, PlainTimeReturn as Return } from './internaltypes';\r\n\r\nexport class PlainTime implements Temporal.PlainTime {\r\n  constructor(isoHour = 0, isoMinute = 0, isoSecond = 0, isoMillisecond = 0, isoMicrosecond = 0, isoNanosecond = 0) {\r\n    const hour = isoHour === undefined ? 0 : ES.ToIntegerWithTruncation(isoHour);\r\n    const minute = isoMinute === undefined ? 0 : ES.ToIntegerWithTruncation(isoMinute);\r\n    const second = isoSecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoSecond);\r\n    const millisecond = isoMillisecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMillisecond);\r\n    const microsecond = isoMicrosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMicrosecond);\r\n    const nanosecond = isoNanosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoNanosecond);\r\n\r\n    ES.RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n    const time = { hour, minute, second, millisecond, microsecond, nanosecond };\r\n\r\n    ES.CreateTemporalTimeSlots(this, time);\r\n  }\r\n\r\n  get hour(): Return['hour'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).hour;\r\n  }\r\n  get minute(): Return['minute'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).minute;\r\n  }\r\n  get second(): Return['second'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).second;\r\n  }\r\n  get millisecond(): Return['millisecond'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).millisecond;\r\n  }\r\n  get microsecond(): Return['microsecond'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).microsecond;\r\n  }\r\n  get nanosecond(): Return['nanosecond'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).nanosecond;\r\n  }\r\n\r\n  with(temporalTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    if (!ES.IsObject(temporalTimeLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalTimeLike);\r\n\r\n    const partialTime = ES.ToTemporalTimeRecord(temporalTimeLike, 'partial');\r\n\r\n    const fields = ES.ToTemporalTimeRecord(this);\r\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = Object.assign(fields, partialTime);\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(\r\n      hour,\r\n      minute,\r\n      second,\r\n      millisecond,\r\n      microsecond,\r\n      nanosecond,\r\n      overflow\r\n    ));\r\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.AddDurationToTime('add', this, temporalDurationLike);\r\n  }\r\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.AddDurationToTime('subtract', this, temporalDurationLike);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.DifferenceTemporalPlainTime('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.DifferenceTemporalPlainTime('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\r\n    const MAX_INCREMENTS = {\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    };\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, MAX_INCREMENTS[smallestUnit], false);\r\n\r\n    const time = ES.RoundTime(GetSlot(this, TIME), roundingIncrement, smallestUnit, roundingMode);\r\n    return ES.CreateTemporalTime(time);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    const other = ES.ToTemporalTime(otherParam);\r\n    return ES.CompareTimeRecord(GetSlot(this, TIME), GetSlot(other, TIME)) === 0;\r\n  }\r\n\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    const time = ES.RoundTime(GetSlot(this, TIME), increment, unit, roundingMode);\r\n    return ES.TimeRecordToString(time, precision);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.TimeRecordToString(GetSlot(this, TIME), 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainTime');\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalTime(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalTime(oneParam);\r\n    const two = ES.ToTemporalTime(twoParam);\r\n    return ES.CompareTimeRecord(GetSlot(one, TIME), GetSlot(two, TIME));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainTime';\r\n}\r\n\r\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type {\r\n  CalendarDateRecord,\r\n  PlainYearMonthParams as Params,\r\n  PlainYearMonthReturn as Return\r\n} from './internaltypes';\r\n\r\nexport class PlainYearMonth implements Temporal.PlainYearMonth {\r\n  constructor(\r\n    isoYear: Params['constructor'][0],\r\n    isoMonth: Params['constructor'][1],\r\n    calendarParam: Params['constructor'][2] = 'iso8601',\r\n    referenceISODay: Params['constructor'][3] = 1\r\n  ) {\r\n    const year = ES.ToIntegerWithTruncation(isoYear);\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n    const day = ES.ToIntegerWithTruncation(referenceISODay);\r\n\r\n    ES.RejectISODate(year, month, day);\r\n    ES.CreateTemporalYearMonthSlots(this, { year, month, day }, calendar);\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  with(temporalYearMonthLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    if (!ES.IsObject(temporalYearMonthLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalYearMonthLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\r\n    const partialYearMonth = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalYearMonthLike,\r\n      ['year', 'month', 'monthCode'],\r\n      [],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialYearMonth);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.AddDurationToYearMonth('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.AddDurationToYearMonth('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.DifferenceTemporalPlainYearMonth('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.DifferenceTemporalPlainYearMonth('since', this, other, options);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    const other = ES.ToTemporalYearMonth(otherParam);\r\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    return ES.TemporalYearMonthToString(this, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.TemporalYearMonthToString(this);\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainYearMonth');\r\n  }\r\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\r\n    const calendar = GetSlot(this, CALENDAR);\r\n\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\r\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['day'], [], []);\r\n    const mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\r\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\r\n    return ES.CreateTemporalDate(isoDate, calendar);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalYearMonth(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalYearMonth(oneParam);\r\n    const two = ES.ToTemporalYearMonth(twoParam);\r\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainYearMonth';\r\n}\r\n\r\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  ym: Temporal.PlainYearMonth,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(ym, ES.IsTemporalYearMonth);\r\n  const isoDate = GetSlot(ym, ISO_DATE);\r\n  return ES.calendarImplForObj(ym).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n","import { assert } from './assert';\r\nimport * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, EPOCHNANOSECONDS, TIME, TIME_ZONE, GetSlot } from './slots';\r\nimport { TimeDuration } from './timeduration';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type {\r\n  BuiltinCalendarId,\r\n  CalendarDateRecord,\r\n  ZonedDateTimeParams as Params,\r\n  ZonedDateTimeReturn as Return\r\n} from './internaltypes';\r\n\r\nimport JSBI from 'jsbi';\r\n\r\nconst customResolvedOptions = DateTimeFormat.prototype.resolvedOptions as Intl.DateTimeFormat['resolvedOptions'];\r\n\r\nexport class ZonedDateTime implements Temporal.ZonedDateTime {\r\n  constructor(epochNanosecondsParam: bigint | JSBI, timeZoneParam: string, calendarParam = 'iso8601') {\r\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\r\n    //       to improve the error message.\r\n    if (arguments.length < 1) {\r\n      throw new TypeError('missing argument: epochNanoseconds is required');\r\n    }\r\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\r\n    let timeZone = ES.RequireString(timeZoneParam);\r\n    const { tzName, offsetMinutes } = ES.ParseTimeZoneIdentifier(timeZone);\r\n    if (offsetMinutes === undefined) {\r\n      // if offsetMinutes is undefined, then tzName must be present\r\n      const record = ES.GetAvailableNamedTimeZoneIdentifier(tzName);\r\n      if (!record) throw new RangeError(`unknown time zone ${tzName}`);\r\n      timeZone = record.identifier;\r\n    } else {\r\n      timeZone = ES.FormatOffsetTimeZoneIdentifier(offsetMinutes);\r\n    }\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n\r\n    ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get timeZoneId(): Return['timeZoneId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return GetSlot(this, TIME_ZONE);\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get hour(): Return['hour'] {\r\n    return getTimeProperty(this, 'hour');\r\n  }\r\n  get minute(): Return['minute'] {\r\n    return getTimeProperty(this, 'minute');\r\n  }\r\n  get second(): Return['second'] {\r\n    return getTimeProperty(this, 'second');\r\n  }\r\n  get millisecond(): Return['millisecond'] {\r\n    return getTimeProperty(this, 'millisecond');\r\n  }\r\n  get microsecond(): Return['microsecond'] {\r\n    return getTimeProperty(this, 'microsecond');\r\n  }\r\n  get nanosecond(): Return['nanosecond'] {\r\n    return getTimeProperty(this, 'nanosecond');\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get epochMilliseconds(): Return['epochMilliseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const value = GetSlot(this, EPOCHNANOSECONDS);\r\n    return ES.epochNsToMs(value, 'floor');\r\n  }\r\n  get epochNanoseconds(): Return['epochNanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\r\n  }\r\n  get dayOfWeek(): Return['dayOfWeek'] {\r\n    return getCalendarProperty(this, 'dayOfWeek');\r\n  }\r\n  get dayOfYear(): Return['dayOfYear'] {\r\n    return getCalendarProperty(this, 'dayOfYear');\r\n  }\r\n  get weekOfYear(): Return['weekOfYear'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.week;\r\n  }\r\n  get yearOfWeek(): Return['yearOfWeek'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.year;\r\n  }\r\n  get hoursInDay(): Return['hoursInDay'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const today = dateTime(this).isoDate;\r\n    const tomorrow = ES.BalanceISODate(today.year, today.month, today.day + 1);\r\n    const todayNs = ES.GetStartOfDay(timeZone, today);\r\n    const tomorrowNs = ES.GetStartOfDay(timeZone, tomorrow);\r\n    const diff = TimeDuration.fromEpochNsDiff(tomorrowNs, todayNs);\r\n    return ES.TotalTimeDuration(diff, 'hour');\r\n  }\r\n  get daysInWeek(): Return['daysInWeek'] {\r\n    return getCalendarProperty(this, 'daysInWeek');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  get offset(): Return['offset'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const offsetNs = ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\r\n    return ES.FormatUTCOffsetNanoseconds(offsetNs);\r\n  }\r\n  get offsetNanoseconds(): Return['offsetNanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\r\n  }\r\n  with(temporalZonedDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    if (!ES.IsObject(temporalZonedDateTimeLike)) {\r\n      throw new TypeError('invalid zoned-date-time-like');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalZonedDateTimeLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const epochNs = GetSlot(this, EPOCHNANOSECONDS);\r\n    const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, epochNs);\r\n    const isoDateTime = dateTime(this);\r\n    let fields = {\r\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\r\n      ...isoDateTime.time,\r\n      offset: ES.FormatUTCOffsetNanoseconds(offsetNs)\r\n    };\r\n    const partialZonedDateTime = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalZonedDateTimeLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset'],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialZonedDateTime);\r\n\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\r\n    const offset = ES.GetTemporalOffsetOption(resolvedOptions, 'prefer');\r\n    const overflow = ES.GetTemporalOverflowOption(resolvedOptions);\r\n\r\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\r\n    const newOffsetNs = ES.ParseDateTimeUTCOffset(fields.offset);\r\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\r\n      newDateTime.isoDate,\r\n      newDateTime.time,\r\n      'option',\r\n      newOffsetNs,\r\n      timeZone,\r\n      disambiguation,\r\n      offset,\r\n      /* matchMinute = */ false\r\n    );\r\n\r\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\r\n  }\r\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const iso = dateTime(this).isoDate;\r\n\r\n    let epochNs;\r\n    if (temporalTimeParam === undefined) {\r\n      epochNs = ES.GetStartOfDay(timeZone, iso);\r\n    } else {\r\n      const temporalTime = ES.ToTemporalTime(temporalTimeParam);\r\n      const dt = ES.CombineISODateAndTimeRecord(iso, GetSlot(temporalTime, TIME));\r\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, dt, 'compatible');\r\n    }\r\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, calendar);\r\n  }\r\n  withTimeZone(timeZoneParam: Params['withTimeZone'][0]): Return['withTimeZone'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\r\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\r\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.AddDurationToZonedDateTime('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.AddDurationToZonedDateTime('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.DifferenceTemporalZonedDateTime('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.DifferenceTemporalZonedDateTime('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\r\n    const maximumIncrements = {\r\n      day: 1,\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    };\r\n    const maximum = maximumIncrements[smallestUnit];\r\n    const inclusive = maximum === 1;\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\r\n\r\n    if (smallestUnit === 'nanosecond' && roundingIncrement === 1) {\r\n      return ES.CreateTemporalZonedDateTime(\r\n        GetSlot(this, EPOCHNANOSECONDS),\r\n        GetSlot(this, TIME_ZONE),\r\n        GetSlot(this, CALENDAR)\r\n      );\r\n    }\r\n\r\n    // first, round the underlying DateTime fields\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const thisNs = GetSlot(this, EPOCHNANOSECONDS);\r\n    const iso = dateTime(this);\r\n    let epochNanoseconds;\r\n\r\n    if (smallestUnit === 'day') {\r\n      // Compute Instants for start-of-day and end-of-day\r\n      // Determine how far the current instant has progressed through this span.\r\n      const dateStart = iso.isoDate;\r\n      const dateEnd = ES.BalanceISODate(dateStart.year, dateStart.month, dateStart.day + 1);\r\n\r\n      const startNs = ES.GetStartOfDay(timeZone, dateStart);\r\n      assert(\r\n        JSBI.greaterThanOrEqual(thisNs, startNs),\r\n        'cannot produce an instant during a day that occurs before start-of-day instant'\r\n      );\r\n\r\n      const endNs = ES.GetStartOfDay(timeZone, dateEnd);\r\n      assert(\r\n        JSBI.lessThan(thisNs, endNs),\r\n        'cannot produce an instant during a day that occurs on or after end-of-day instant'\r\n      );\r\n\r\n      const dayLengthNs = JSBI.subtract(endNs, startNs);\r\n      const dayProgressNs = TimeDuration.fromEpochNsDiff(thisNs, startNs);\r\n      const roundedDayNs = dayProgressNs.round(dayLengthNs, roundingMode);\r\n      epochNanoseconds = roundedDayNs.addToEpochNs(startNs);\r\n    } else {\r\n      // smallestUnit < day\r\n      // Round based on ISO-calendar time units\r\n      const roundedDateTime = ES.RoundISODateTime(iso, roundingIncrement, smallestUnit, roundingMode);\r\n\r\n      // Now reset all DateTime fields but leave the TimeZone. The offset will\r\n      // also be retained if the new date/time values are still OK with the old\r\n      // offset. Otherwise the offset will be changed to be compatible with the\r\n      // new date/time values. If DST disambiguation is required, the `compatible`\r\n      // disambiguation algorithm will be used.\r\n      const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, thisNs);\r\n      epochNanoseconds = ES.InterpretISODateTimeOffset(\r\n        roundedDateTime.isoDate,\r\n        roundedDateTime.time,\r\n        'option',\r\n        offsetNs,\r\n        timeZone,\r\n        'compatible',\r\n        'prefer',\r\n        /* matchMinute = */ false\r\n      );\r\n    }\r\n\r\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const other = ES.ToTemporalZonedDateTime(otherParam);\r\n    const one = GetSlot(this, EPOCHNANOSECONDS);\r\n    const two = GetSlot(other, EPOCHNANOSECONDS);\r\n    if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two))) return false;\r\n    if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE))) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const showOffset = ES.GetTemporalShowOffsetOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    const showTimeZone = ES.GetTemporalShowTimeZoneNameOption(resolvedOptions);\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\r\n      unit,\r\n      increment,\r\n      roundingMode\r\n    });\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n\r\n    // This is not quite per specification, but this polyfill's DateTimeFormat\r\n    // already doesn't match the InitializeDateTimeFormat operation, and the\r\n    // access order might change anyway;\r\n    // see https://github.com/tc39/ecma402/issues/747\r\n    const optionsCopy = Object.create(null);\r\n    ES.CopyDataProperties(optionsCopy, resolvedOptions, ['timeZone']);\r\n\r\n    if (resolvedOptions.timeZone !== undefined) {\r\n      throw new TypeError('ZonedDateTime toLocaleString does not accept a timeZone option');\r\n    }\r\n\r\n    if (\r\n      optionsCopy.year === undefined &&\r\n      optionsCopy.month === undefined &&\r\n      optionsCopy.day === undefined &&\r\n      optionsCopy.era === undefined &&\r\n      optionsCopy.weekday === undefined &&\r\n      optionsCopy.dateStyle === undefined &&\r\n      optionsCopy.hour === undefined &&\r\n      optionsCopy.minute === undefined &&\r\n      optionsCopy.second === undefined &&\r\n      optionsCopy.fractionalSecondDigits === undefined &&\r\n      optionsCopy.timeStyle === undefined &&\r\n      optionsCopy.dayPeriod === undefined &&\r\n      optionsCopy.timeZoneName === undefined\r\n    ) {\r\n      optionsCopy.timeZoneName = 'short';\r\n      // The rest of the defaults will be filled in by formatting the Instant\r\n    }\r\n\r\n    optionsCopy.timeZone = GetSlot(this, TIME_ZONE);\r\n    if (ES.IsOffsetTimeZoneIdentifier(optionsCopy.timeZone)) {\r\n      // Note: https://github.com/tc39/ecma402/issues/683 will remove this\r\n      throw new RangeError('toLocaleString does not currently support offset time zones');\r\n    }\r\n\r\n    const formatter = new DateTimeFormat(locales, optionsCopy);\r\n\r\n    const localeCalendarIdentifier = customResolvedOptions.call(formatter).calendar as BuiltinCalendarId;\r\n    const calendarIdentifier = GetSlot(this, CALENDAR);\r\n    if (\r\n      calendarIdentifier !== 'iso8601' &&\r\n      localeCalendarIdentifier !== 'iso8601' &&\r\n      !ES.CalendarEquals(localeCalendarIdentifier, calendarIdentifier)\r\n    ) {\r\n      throw new RangeError(\r\n        `cannot format ZonedDateTime with calendar ${calendarIdentifier}` +\r\n          ` in locale with calendar ${localeCalendarIdentifier}`\r\n      );\r\n    }\r\n\r\n    return formatter.format(ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS)));\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.TemporalZonedDateTimeToString(this, 'auto');\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('ZonedDateTime');\r\n  }\r\n  startOfDay(): Return['startOfDay'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const isoDate = dateTime(this).isoDate;\r\n    const epochNanoseconds = ES.GetStartOfDay(timeZone, isoDate);\r\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  getTimeZoneTransition(directionParam: Params['getTimeZoneTransition'][0]): Return['getTimeZoneTransition'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n\r\n    if (directionParam === undefined) throw new TypeError('options parameter is required');\r\n    const direction = ES.GetDirectionOption(\r\n      typeof directionParam === 'string'\r\n        ? (ES.CreateOnePropObject('direction', directionParam) as Exclude<typeof directionParam, string>)\r\n        : ES.GetOptionsObject(directionParam)\r\n    );\r\n    if (direction === undefined) throw new TypeError('direction option is required');\r\n\r\n    // Offset time zones or UTC have no transitions\r\n    if (ES.IsOffsetTimeZoneIdentifier(timeZone) || timeZone === 'UTC') {\r\n      return null;\r\n    }\r\n\r\n    const thisEpochNanoseconds = GetSlot(this, EPOCHNANOSECONDS);\r\n    const epochNanoseconds =\r\n      direction === 'next'\r\n        ? ES.GetNamedTimeZoneNextTransition(timeZone, thisEpochNanoseconds)\r\n        : ES.GetNamedTimeZonePreviousTransition(timeZone, thisEpochNanoseconds);\r\n    return epochNanoseconds === null\r\n      ? null\r\n      : ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  toInstant(): Return['toInstant'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\r\n  }\r\n  toPlainDate(): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalDate(dateTime(this).isoDate, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainTime(): Return['toPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalTime(dateTime(this).time);\r\n  }\r\n  toPlainDateTime(): Return['toPlainDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalDateTime(dateTime(this), GetSlot(this, CALENDAR));\r\n  }\r\n\r\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalZonedDateTime(item, optionsParam);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalZonedDateTime(oneParam);\r\n    const two = ES.ToTemporalZonedDateTime(twoParam);\r\n    const ns1 = GetSlot(one, EPOCHNANOSECONDS);\r\n    const ns2 = GetSlot(two, EPOCHNANOSECONDS);\r\n    if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return -1;\r\n    if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return 1;\r\n    return 0;\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.ZonedDateTime';\r\n}\r\n\r\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\r\n\r\nfunction dateTime(zdt: Temporal.ZonedDateTime) {\r\n  return ES.GetISODateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, EPOCHNANOSECONDS));\r\n}\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  zdt: Temporal.ZonedDateTime,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\r\n  const isoDate = dateTime(zdt).isoDate;\r\n  return ES.calendarImplForObj(zdt).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n\r\nfunction getTimeProperty(zdt: Temporal.ZonedDateTime, prop: Temporal.TimeUnit) {\r\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\r\n  return dateTime(zdt).time[prop];\r\n}\r\n","import * as ES from './ecmascript';\r\n\r\n// By default, a plain function can be called as a constructor. A method such as\r\n// Date.prototype.toTemporalInstant should not be able to. We could check\r\n// new.target in the body of toTemporalInstant, but that is not sufficient for\r\n// preventing construction when passing it as the newTarget parameter of\r\n// Reflect.construct. So we create it as a method of an otherwise unused class,\r\n// and monkeypatch it onto Date.prototype.\r\n\r\nclass LegacyDateImpl {\r\n  toTemporalInstant(this: Date) {\r\n    const epochNanoseconds = ES.epochMsToNs(Date.prototype.valueOf.call(this));\r\n    return ES.CreateTemporalInstant(epochNanoseconds);\r\n  }\r\n}\r\n\r\nexport const toTemporalInstant = LegacyDateImpl.prototype.toTemporalInstant;\r\n","// This entry point treats Temporal as a library, and does not polyfill it onto\r\n// the global object.\r\n// This is in order to avoid breaking the web in the future, if the polyfill\r\n// gains wide adoption before the API is finalized. We do not want checks such\r\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\r\n// shipping the finalized API.\r\n\r\nimport * as Temporal from './temporal';\r\nimport * as Intl from './intl';\r\nimport { toTemporalInstant } from './legacydate';\r\n\r\n// Work around https://github.com/babel/babel/issues/2025.\r\nconst types = [\r\n  Temporal.Instant,\r\n  Temporal.PlainDate,\r\n  Temporal.PlainDateTime,\r\n  Temporal.Duration,\r\n  Temporal.PlainMonthDay,\r\n  // Temporal.Now, // plain object (not a constructor), so no `prototype`\r\n  Temporal.PlainTime,\r\n  Temporal.PlainYearMonth,\r\n  Temporal.ZonedDateTime\r\n];\r\nfor (const type of types) {\r\n  const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype') as PropertyDescriptor;\r\n  if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\r\n    descriptor.configurable = false;\r\n    descriptor.enumerable = false;\r\n    descriptor.writable = false;\r\n    Object.defineProperty(type, 'prototype', descriptor);\r\n  }\r\n}\r\n\r\nexport { Temporal, Intl, toTemporalInstant };\r\n"],"names":["assert","condition","message","Error","concat","assertNotReached","reason","ZERO","JSBI","BigInt","ONE","TWO","TEN","TWENTY_FOUR","SIXTY","THOUSAND","MILLION","BILLION","HOUR_SECONDS","HOUR_NANOS","multiply","MINUTE_NANOS_JSBI","DAY_NANOS_JSBI","ensureJSBI","value","toString","isEven","equal","remainder","abs","x","lessThan","unaryMinus","compare","y","greaterThan","EPOCHNANOSECONDS","ISO_DATE","ISO_DATE_TIME","TIME","CALENDAR","DATE_BRAND","YEAR_MONTH_BRAND","MONTH_DAY_BRAND","TIME_ZONE","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","SECONDS","MILLISECONDS","MICROSECONDS","NANOSECONDS","DATE","YM","MD","INST","ORIGINAL","TZ_CANONICAL","TZ_ORIGINAL","CAL_ID","OPTIONS","INTRINSICS","_customUtilInspectFor","_defineProperty","IntlDateTimeFormat","depth","options","inspect","GetSlot","_objectSpread","TemporalDuration","descr","stylize","_repr_","props","i","length","prop","TruncatingDivModByPowerOf10","xParam","p","div","mod","sign","Math","xDigits","trunc","log10","xStr","toPrecision","Number","parseInt","slice","FMAPowerOf10","zParam","z","repeat","zStr","resStr","padStart","GetUnsignedRoundingMode","isNegative","mode","TimeDuration","totalNs","_classCallCheck","lessThanOrEqual","MAX","sec","toNumber","subsec","isSafeInteger","_createClass","key","add","other","validateNew","days","isInteger","addToEpochNs","epochNs","divmod","n","q","r","operation","RangeError","fromEpochNsDiff","epochNs2","diff","epochNs1","h","min","s","ms","µs","ns","offsetIdentifierNoCapture","tzComponent","timeZoneID","RegExp","source","yearpart","monthpart","daypart","datesplit","timesplit","offsetWithParts","offset","offsetpart","offsetIdentifier","annotation","zoneddatetime","join","time","DAY_MS","DAY_NANOS","MINUTE_NANOS","MS_MAX","NS_MAX","epochMsToNs","NS_MIN","DATETIME_NS_MIN","subtract","DATETIME_NS_MAX","BUILTIN_CALENDAR_IDS","ICU_LEGACY_TIME_ZONE_IDS","Set","assertExists","arg","castExists","IsObject","_typeof","ToNumber","TypeError","IsIntegralNumber","argument","isNaN","Infinity","absValue","ToString","String","ToIntegerWithTruncation","number","integer","ToPositiveIntegerWithTruncation","valueParam","property","undefined","ToIntegerIfIntegral","ToZeroPaddedDecimalString","minLength","RequireString","ToSyntacticallyValidMonthCode","ToPrimitive","indexOf","ToOffsetString","ParseDateTimeUTCOffset","preferredType","result","CALENDAR_FIELD_KEYS","BUILTIN_CASTS","era","eraYear","year","month","monthCode","day","hour","minute","millisecond","microsecond","nanosecond","timeZone","ToTemporalTimeZoneIdentifier","BUILTIN_DEFAULTS","second","SINGULAR_FOR","Object","fromEntries","TEMPORAL_UNITS","map","e","PLURAL_FOR","_ref","_ref2","_slicedToArray","UNITS_DESCENDING","_ref3","_ref4","NS_PER_TIME_UNIT","DURATION_FIELDS","OriginalIntlDateTimeFormat","Intl","DateTimeFormat","IntlDateTimeFormatEnUsCache","Map","getIntlDateTimeFormatEnUsForTimeZone","timeZoneIdentifier","lowercaseIdentifier","ASCIILowercase","instance","get","hour12","set","ToObject","CopyDataProperties","excludedKeys","excludedValues","keys","Reflect","ownKeys","_loop","nextKey","index","some","is","propertyIsEnumerable","call","propValue","target","_ret","IsTemporalInstant","item","HasSlot","IsTemporalDuration","IsTemporalDate","IsTemporalTime","IsTemporalDateTime","IsTemporalYearMonth","IsTemporalMonthDay","IsTemporalZonedDateTime","CheckReceiver","test","RejectTemporalLikeObject","calendar","FormatCalendarAnnotation","id","showCalendar","flag","processAnnotations","annotations","PARSE","lastIndex","match","exec","_match","critical","calendarWasCritical","ParseISODateTime","isoString","_ref5","_match$","_ref6","_match$2","_match$3","_ref7","_match$4","_ref8","_match$5","_ref9","_match$6","yearString","hasTime","fraction","tzAnnotation","RejectDateTime","ParseTemporalInstantString","ParseTemporalZonedDateTimeString","ParseTemporalDateTimeString","ParseTemporalDateString","ParseTemporalTimeString","_match$7","_ref10","_match$8","_ref11","_match$9","_ref12","_match$10","_ParseISODateTime","_time","RejectTime","_ParseTemporalMonthDa","ParseTemporalMonthDayString","RejectISODate","_unused","_ParseTemporalYearMon","ParseTemporalYearMonthString","_unused2","referenceISODay","_ParseISODateTime2","referenceISOYear","_ParseISODateTime3","TIMEZONE_IDENTIFIER","OFFSET_IDENTIFIER","throwBadTimeZoneStringError","timeZoneString","msg","OFFSET","ParseTimeZoneIdentifier","identifier","offsetNanoseconds","offsetMinutes","tzName","ParseTemporalTimeZoneStringRaw","_ParseISODateTime4","_unused3","stringIdent","_ParseTemporalTimeZon","ParseTemporalDurationStringRaw","every","part","years","months","weeks","hours","fHours","minutesStr","fMinutes","secondsStr","fSeconds","excessNanoseconds","_ref13","_ref14","_ref15","_ref16","seconds","nanoseconds","milliseconds","minutes","RejectDuration","microseconds","ParseTemporalDurationString","_ParseTemporalDuratio","GetIntrinsic","RegulateISODate","yearParam","monthParam","dayParam","overflow","_ConstrainISODate","ConstrainISODate","RegulateTime","minuteParam","secondParam","millisecondParam","microsecondParam","nanosecondParam","ConstrainToRange","ToTemporalPartialDurationRecord","temporalDurationLike","any","AdjustDateDurationRecord","_ref17","newDays","newWeeks","newMonths","ZeroDateDuration","CombineISODateAndTimeRecord","isoDate","MidnightTimeRecord","deltaDays","NoonTimeRecord","GetTemporalOverflowOption","GetOption","GetTemporalDisambiguationOption","GetRoundingModeOption","fallback","NegateRoundingMode","roundingMode","GetTemporalOffsetOption","GetTemporalShowCalendarNameOption","GetTemporalShowTimeZoneNameOption","GetTemporalShowOffsetOption","GetDirectionOption","REQUIRED","GetTemporalRoundingIncrementOption","increment","roundingIncrement","integerIncrement","ValidateTemporalRoundingIncrement","dividend","inclusive","maximum","GetTemporalFractionalSecondDigitsOption","normalizedOptions","digitsValue","fractionalSecondDigits","digitCount","floor","ToSecondsStringPrecisionRecord","smallestUnit","precision","unit","pow","Symbol","GetTemporalUnitValuedOption","unitGroup","allowedSingular","unitInfo","singular","category","defaultVal","requiredOrDefault","push","allowedValues","plural","retval","GetTemporalRelativeToOption","relativeTo","offsetBehaviour","matchMinutes","zonedRelativeTo","plainRelativeTo","CreateTemporalDate","GetTemporalCalendarIdentifierWithISODefault","fields","PrepareCalendarFields","_InterpretTemporalDat","InterpretTemporalDateTimeFields","_ParseISODateTime5","CanonicalizeCalendar","offsetNs","epochNanoseconds","InterpretISODateTimeOffset","CreateTemporalZonedDateTime","DefaultTemporalLargestUnit","duration","LargerOfTwoTemporalUnits","unit1","i1","i2","unit2","IsCalendarUnit","TemporalUnitCategory","calendarImplForID","calendarImplForObj","temporalObj","ISODateToFields","type","arguments","create","calendarImpl","calendarDate","isoToDate","bag","extraFieldNames","extraFields","calendarFieldNames","nonCalendarFieldNames","sort","requiredFields","includes","ToTemporalTimeRecord","field","ToTemporalDate","GetOptionsObject","isoDateTime","GetISODateTimeFor","CalendarDateFromFields","_ParseTemporalDateStr","ToTemporalDateTime","CreateTemporalDateTime","_InterpretTemporalDat2","_ParseTemporalDateTim","ToTemporalDuration","partial","ToTemporalInstant","itemParam","CreateTemporalInstant","_ParseTemporalInstant","_ref18$hour","_ref18$minute","_ref18","_ref18$second","_ref18$millisecond","_ref18$microsecond","_ref18$nanosecond","balanced","CheckISODaysRange","GetUTCEpochNanoseconds","ToTemporalMonthDay","CreateTemporalMonthDay","CalendarMonthDayFromFields","_ParseTemporalMonthDa2","isoCalendarReferenceYear","ToTemporalTime","CreateTemporalTime","_ToTemporalTimeRecord","ToTimeRecordOrMidnight","ToTemporalYearMonth","CreateTemporalYearMonth","CalendarYearMonthFromFields","_ParseTemporalYearMon2","RejectYearMonthRange","disambiguation","offsetOpt","matchMinute","GetStartOfDay","dt","GetEpochNanosecondsFor","BalanceISODateTime","ValidateEpochNanoseconds","utcEpochNs","possibleEpochNs","candidate","candidateOffset","roundedCandidateOffset","RoundNumberToIncrement","offsetStr","FormatUTCOffsetNanoseconds","dtStr","ISODateTimeToString","DisambiguatePossibleEpochNanoseconds","ToTemporalZonedDateTime","resolvedOptions","_InterpretTemporalDat3","_ParseTemporalZonedDa","CreateTemporalDateSlots","CreateSlots","SetSlot","repr","writable","enumerable","configurable","TemporalPlainDate","prototype","CreateTemporalDateTimeSlots","defineProperty","TemporalPlainDateTime","CreateTemporalMonthDaySlots","RejectDateRange","TemporalPlainMonthDay","CreateTemporalTimeSlots","TemporalPlainTime","CreateTemporalYearMonthSlots","TemporalYearMonthToString","TemporalPlainYearMonth","CreateTemporalInstantSlots","GetISOPartsFromEpoch","toStringTag","TemporalInstant","CreateTemporalZonedDateTimeSlots","TemporalZonedDateTimeToString","TemporalZonedDateTime","CalendarFieldKeysPresent","filter","CalendarMergeFields","additionalKeys","additionalFields","overriddenKeys","fieldKeysToIgnore","merged","fieldsKeys","ix","CalendarDateAdd","dateAdd","dateDuration","CalendarDateUntil","dateUntil","isoOtherDate","largestUnit","ToTemporalCalendarIdentifier","calendarLike","_unused4","_ParseISODateTime6","_unused5","_ParseTemporalTimeStr","_unused6","_ParseTemporalYearMon3","_unused7","_ParseTemporalMonthDa3","CalendarEquals","one","two","resolveFields","dateToISO","monthDayToISOReferenceDate","temporalTimeZoneLike","_ParseTemporalTimeZon2","ParseTemporalTimeZoneString","FormatOffsetTimeZoneIdentifier","record","GetAvailableNamedTimeZoneIdentifier","TimeZoneEquals","offsetMinutes1","offsetMinutes2","idRecord2","idRecord1","primaryIdentifier","GetOffsetNanosecondsFor","GetNamedTimeZoneOffsetNanoseconds","absoluteNs","subSecondNs","timeString","FormatTimeString","_GetISOPartsFromEpoch2","_GetISOPartsFromEpoch","_GetISOPartsFromEpoch3","GetPossibleEpochNanoseconds","numInstants","utcns","dayBefore","dayAfter","offsetAfter","offsetBefore","fromComponents","AddTime","timeDuration","earlierDate","BalanceISODate","earlierTime","earlier","laterTime","laterDate","later","possible","GetNamedTimeZoneEpochNanoseconds","GetNamedTimeZoneNextTransition","ISOYearString","yearNumber","ISODateTimePartString","FormatFractionalSeconds","subSecondNanoseconds","fractionFullPrecision","replace","TemporalInstantToString","outputTimeZone","instant","iso","dateTimeString","FormatDateTimeUTCOffsetRounded","TemporalDurationToString","DurationSign","datePart","timePart","secondsDuration","isZero","secondsPart","subSecondsPart","TemporalDateToString","date","_GetSlot","monthString","dayString","TimeRecordToString","_ref19","_isoDateTime$isoDate","_isoDateTime$time","calendarString","TemporalMonthDayToString","monthDay","_GetSlot2","resultString","yearMonth","_GetSlot3","zdt","showTimeZone","showOffset","RoundTemporalInstant","tz","IsOffsetTimeZoneIdentifier","string","OFFSET_WITH_PARTS","canonicalTimeZoneIdsCache","isTZIDSep","assign","_canonicalTimeZoneIds","_specialCases$get","_specialCases$get2","_Intl$supportedValues","_Intl","canonicalTimeZoneIds","supportedValuesOf","lower","formatter","_unused8","has","chars","_toConsumableArray","c","toUpperCase","standardCase","segments","split","etcName","specialCases","GetNamedTimeZoneOffsetNanosecondsImpl","epochMilliseconds","_GetFormatterParts","GetFormatterParts","GetUTCEpochMilliseconds","epochNsToMs","absoluteMinutes","offsetNanosecondsParam","_ref20","_ref20$isoDate","_ref20$time","reducedYear","yearCycles","legacyDate","Date","setUTCHours","setUTCFullYear","getTime","subMs","nanos","getUTCFullYear","getUTCDate","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","GetNamedTimeZoneDateTimeParts","_GetISOPartsFromEpoch4","_GetISOPartsFromEpoch5","_GetFormatterParts2","searchWindowForTransitions","BEFORE_FIRST_DST","now","base","max","uppercap","leftMs","rightOffsetNs","leftOffsetNs","rightMs","searchWindow","bisect","epochMs","GetNamedTimeZonePreviousTransition","lookahead","prevBeforeLookahead","UTC","lastPrecomputed","parseFromEnUsFormat","datetime","splits","isFinite","format","nsEarlier","nsLater","earlierOffsetNs","laterOffsetNs","found","candidates","parts","CompareISODateTime","LeapYear","isDiv4","isDiv100","isDiv400","ISODaysInMonth","DoM","standard","leapyear","DateDurationSign","fieldNames","InternalDurationSign","dateSign","BalanceISOYearMonth","_BalanceISOYearMonth","daysIn400YearCycle","nCycles","testYear","daysInYear","_BalanceISOYearMonth2","_BalanceISOYearMonth3","BalanceTime","hourParam","_TruncatingDivModByPo","_TruncatingDivModByPo2","DateDurationDays","yearsMonthsWeeksDuration","epochDaysEarlier","ISODateToEpochDays","epochDaysLater","yearsMonthsWeeksInDays","CreateNegatedTemporalDuration","RejectToRange","RejectDateTimeRange","AssertISODateTimeWithinLimits","greaterThanOrEqual","_ref21","YEAR_MIN","YEAR_MAX","w","d","mon","propSign","msResult","µsResult","nsResult","remainderSec","totalSec","ToInternalDurationRecord","ToInternalDurationRecordWith24HourDays","add24HourDays","ToDateDurationRecordWithoutTime","internalDuration","TemporalDurationFromInternal","CombineDateAndTimeDuration","timeSign","_ref22","DifferenceTime","time1","time2","DifferenceInstant","ns1","ns2","DifferenceISODateTime","isoDateTime1","isoDateTime2","CompareISODate","adjustedDate","dateLargestUnit","dateDifference","DifferenceZonedDateTime","nsDiff","isoDtStart","isoDtEnd","dayCorrection","intermediateDateTime","maxDayCorrection","intermediateDate","intermediateNs","NudgeToCalendarUnit","durationParam","r2","startDuration","endDuration","r1","yearsMonths","weeksStart","weeksEnd","untilResult","start","end","startEpochNs","startDateTime","endDateTime","endEpochNs","destEpochNs","numerator","denominator","unsignedRoundingMode","cmp","even","roundedUnit","ApplyUnsignedRoundingMode","fakeNumerator","total","fdiv","didExpandCalendarUnit","nudgeResult","nudgedEpochNs","NudgeToZonedTime","endDate","daySpan","arrayFromSet","src","calendarDateWeekOfYear","impl","yow","_calendar$isoToDate","dayOfWeek","dayOfYear","fdow","getFirstDayOfWeek","mdow","getMinimalDaysInFirstWeek","relDow","relDowJan1","prevYearCalendar","prevDoy","woy","weekNumber","lastDoy","lastRelDow","week","y1","isoDate2","m1","resolveNonLunisolarMonth","_fields$year","_ES$RegulateISODate","ES","_ref$years","_ref$months","_ref$weeks","_ref$days","_ES$BalanceISOYearMon","_ES$RegulateISODate2","intermediate","candidateYears","ISODateSurpasses","candidateMonths","constrained","requestedFields","daysInWeek","monthsInYear","buildMonthCode","shiftedMonth","shiftedYear","century","yearInCentury","monthTerm","yearTerm","centuryTerm","dow","m","startsWith","leap","leapMarker","digitPart","monthsPerYear","numberPart","nonLeapMonthCodeNumberPart","firstDayOfWeek","minimalDaysInFirstWeek","desiredDay","periodStartDayOfWeek","weekNo","OneObjectCache","cacheToClone","calls","hits","_iterator","_createForOfIteratorHelper","entries","_step","_this$map","entry","MAX_CACHE_ENTRIES","apply","err","f","report","misses","objectMap","obj","getCacheForObject","cache","WeakMap","toUtcIsoDateString","isoYear","isoMonth","isoDay","simpleDateDiff","HelperBase","getFormatter","getCalendarParts","dateTimeFormat","locale","isoToCalendarDate","_this","JSON","stringify","func","cached","matches","hasEra","normalize","replacement","eras","find","genericName","code","reviseIntlEra","_this$reviseIntlEra","checkIcuBugs","adjustCalendarDate","keyReverse","forEach","cacheReverse","monthExtra","_resolveNonLunisolarM","largestMonth","regulateMonthDayNaive","maximumMonthLength","calendarToIsoDate","_this2","originalDate","dateParam","_date","keyOriginal","estimateIsoDate","calculateSameMonthResult","diffDays","testIsoEstimate","addDaysIso","isoEstimate","minimumMonthLength","testCalendarDate","roundtripEstimate","diffTotalDaysEstimate","compareCalendarDates","oldRoundtripEstimate","oldSign","order","date1","date2","added","addedIso","addedCalendar","calendarDateParam","_calendarDate","absMonths","oldCalendarDate","daysInPreviousMonth","daysInMonth","monthsInOldYear","regulateDate","addCalendar","_ref4$years","_ref4$months","_ref4$weeks","_ref4$days","addedYears","addedMonths","addMonthsCalendar","addedDays","addDaysCalendar","initialDays","calendarTwo","calendarDaysUntil","calendarOne","totalDays","diffYears","diffInYearSign","isOneFurtherInYear","yearsAdded","current","next","remainingDays","addedIsoDate","addedCalendarDate","endOfMonthIso","endOfMonthCalendar","previousMonthYear","previousMonthDate","previousMonth","lastDayOfPreviousMonthIso","lastDayOfPreviousMonthCalendar","startOfCalendarMonth","oneIso","twoIso","monthDayFromFields","_this$isoToCalendarDa","closestCalendar","monthDaySearchStartYear","startDateIso","calendarYear","calendarOfStartDateIso","roundTripCalendarDate","maxDayForMonthCode","closestIso","HebrewHelper","_HelperBase","_inherits","_super","_createSuper","_this3","regular","Kislev","Tevet","Nisan","Iyar","Sivan","Tamuz","Elul","minMaxMonthLength","minOrMax","monthInfo","maxLengthOfMonthCodeInAnyYear","inLeapYear","fromLegacyDate","getMonthCode","validateCalendarDate","endsWith","calculatedMonthCode","IslamicBaseHelper","_HelperBase2","_super2","_this4","DAYS_PER_ISLAMIC_YEAR","DAYS_PER_ISO_YEAR","startOfYearCalendar","startOfNextYearCalendar","_this$adjustCalendarD","IslamicHelper","_IslamicBaseHelper","_super3","_this5","IslamicUmalquraHelper","_IslamicBaseHelper2","_super4","_this6","IslamicTblaHelper","_IslamicBaseHelper3","_super5","_this7","IslamicCivilHelper","_IslamicBaseHelper4","_super6","_this8","IslamicRgsaHelper","_IslamicBaseHelper5","_super7","_this9","IslamicCcHelper","_IslamicBaseHelper6","_super8","_this10","_HelperBase3","PersianHelper","_super9","_this11","calendarType","_this$adjustCalendarD2","IndianHelper","_HelperBase4","_super10","_this12","nextYear","vulnerableToBceBug","toLocaleDateString","isGregorianLeapYear","getMonthInfo","_monthInfo$leap","adjustEras","erasParam","reverseOf","anchorEra","isAnchor","anchorEpoch","hasYearZero","reversedEra","isoEpoch","e1","e2","lastEraReversed","GregorianBaseHelperFixedEpoch","_HelperBase5","_super11","_this13","_this$estimateIsoDate","GregorianBaseHelper","originalEras","_this14","_super12","_adjustEras","_this$estimateIsoDate2","_this15","checkField","names","currentValue","preferredName","expected","eraFromYear","adjustedCalendarDate","matchingEra","comparison","eraNames","matchData","_ref5$names","_eraFromYear","_calendarDate3","completeEraYear","_get","_getPrototypeOf","isoYearEstimate","SameMonthDayAsGregorianBaseHelper","_GregorianBaseHelper","_super13","OrthodoxBaseHelperFixedEpoch","_GregorianBaseHelperF","_super14","_this16","OrthodoxOps","_GregorianBaseHelper2","OrthodoxBaseHelper","_super15","_this17","_OrthodoxBaseHelperFi","EthioaaHelper","_super16","CopticHelper","_OrthodoxBaseHelper","_super17","EthiopicHelper","_super18","BuddhistHelper","_GregorianBaseHelperF2","_super20","GregoryHelper","_SameMonthDayAsGregor2","_super21","JapaneseHelper","_SameMonthDayAsGregor3","_super22","_this18","ChineseBaseHelper","_HelperBase7","_super23","_this19","getMonthList","_monthMap$monthCode","monthMap","M02L","M04L","M05L","M06L","M07L","M08L","M09L","M10L","M11L","M12L","_this20","getCalendarDate","daysPastFeb1","isoStringFeb1","setUTCDate","newYearGuess","formatToParts","calendarMonthString","tv","calendarDay","calendarYearPartToVerify","calendarYearToVerify","getSlotLazy","slot","val","LOCALE","ResetSlot","createDateTimeFormat","dtf","optionsParam","hasOptions","newOptions","hasOwnProperty","original","ro","clonedResolved","hourCycle","dateAmend","yearMonthAmend","monthDayAmend","TIME_FMT","timeAmend","DATETIME","datetimeAmend","instantAmend","timeZoneOption","IsPatchedDateTimeFormat","DateTimeFormatImpl","locales","boundFormat","bind","defineProperties","name","formatRange","a","b","_len","rest","Array","_key","formatRangeToParts","supportedLocalesOf","MakeIntrinsicClass","resolved","overrides","extractOverrides","formatArgs","_len2","_formatter","_formatter2","_len3","_key3","aParam","bParam","_formatter3","toDateTimeFormattable","isTemporalObject","sameTemporalType","_extractOverrides","aa","aformatter","_extractOverrides2","bb","bformatter","_formatter4","_extractOverrides3","_extractOverrides4","amend","amended","opt","originalOptions","weekday","timeZoneName","dateStyle","timeStyle","hasTimeOptions","hasAnyDateTimeOptions","dateStyleHacks","short","medium","long","full","dayPeriod","style","hasDateOptions","Instant","since","roundToParam","roundTo","maximumIncrements","roundedNs","otherParam","digits","_ES$ToSecondsStringPr","roundedInstant","toLocaleString","timeZoneParam","fromEpochMilliseconds","epochNanosecondsParam","from","oneParam","twoParam","PlainDate","calendarParam","getCalendarProperty","_getCalendarProperty","_getCalendarProperty2","temporalDateLike","partialDate","withCalendar","valueOf","temporalTime","toZonedDateTime","timeZoneLike","plainTime","PlainDateTime","getTimeProperty","_with","temporalDateTimeLike","partialDateTime","newDateTime","until","round","Duration","yearsParam","monthsParam","weeksParam","hoursParam","minutesParam","secondsParam","millisecondsParam","microsecondsParam","nanosecondsParam","daysParam","durationLike","partialDuration","_partialDuration$year","_partialDuration$mont","_partialDuration$week","_partialDuration$days","_partialDuration$hour","_partialDuration$minu","_partialDuration$seco","_partialDuration$mill","_partialDuration$micr","_partialDuration$nano","_ES$GetTemporalRelati","smallestUnitPresent","defaultLargestUnit","largestUnitPresent","relativeEpochNs","targetEpochNs","targetTime","isoRelativeToDate","targetDateTime","targetDate","existingLargestUnit","quotient","_internalDuration$tim","_ES$GetTemporalRelati2","PlainMonthDay","temporalMonthDayLike","partialMonthDay","equals","toJSON","toPlainDate","SystemDateTime","plainDateTimeISO","zonedDateTimeISO","plainDateISO","plainTimeISO","timeZoneId","Now","PlainTime","isoHour","isoMinute","isoSecond","isoMillisecond","isoNanosecond","isoMicrosecond","temporalTimeLike","partialTime","_Object$assign","_ES$RegulateTime","MAX_INCREMENTS","PlainYearMonth","temporalYearMonthLike","partialYearMonth","ZonedDateTime","_ES$ParseTimeZoneIden","today","dateTime","tomorrow","todayNs","tomorrowNs","temporalZonedDateTimeLike","partialZonedDateTime","newOffsetNs","temporalTimeParam","thisNs","dateEnd","dateStart","startNs","endNs","dayLengthNs","dayProgressNs","roundedDayNs","roundedDateTime","optionsCopy","localeCalendarIdentifier","customResolvedOptions","calendarIdentifier","startOfDay","LegacyDateImpl","toTemporalInstant","types","Temporal","_i","_types","descriptor","getOwnPropertyDescriptor"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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"}