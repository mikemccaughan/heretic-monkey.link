{"version":3,"file":"index.umd.js","sources":["../lib/assert.ts","../lib/bigintmath.ts","../lib/slots.ts","../lib/intrinsicclass.ts","../lib/math.ts","../lib/timeduration.ts","../lib/regex.ts","../lib/ecmascript.ts","../lib/calendar.ts","../lib/intl.ts","../lib/instant.ts","../lib/plaindate.ts","../lib/plaindatetime.ts","../lib/duration.ts","../lib/plainmonthday.ts","../lib/now.ts","../lib/plaintime.ts","../lib/plainyearmonth.ts","../lib/zoneddatetime.ts","../lib/legacydate.ts","../lib/index.ts"],"sourcesContent":["export function assert(condition: boolean, message: string): asserts condition {\r\n  if (!condition) throw new Error(`assertion failure: ${message}`);\r\n}\r\n\r\nexport function assertNotReached(message?: string): never {\r\n  const reason = message ? ` because ${message}` : '';\r\n  throw new Error(`assertion failure: code should not be reached${reason}`);\r\n}\r\n","export const ZERO = 0n;\r\nexport const ONE = 1n;\r\nexport const TWO = 2n;\r\nexport const TEN = 10n;\r\nconst TWENTY_FOUR = 24n;\r\nconst SIXTY = 60n;\r\nexport const THOUSAND = 1_000n;\r\nexport const MILLION = 1_000_000n;\r\nexport const BILLION = 1_000_000_000n;\r\nconst HOUR_SECONDS = 3600n;\r\nexport const HOUR_NANOS = HOUR_SECONDS * BILLION;\r\nexport const MINUTE_NANOS = SIXTY * BILLION;\r\nexport const DAY_NANOS = HOUR_NANOS * TWENTY_FOUR;\r\n\r\nexport function isEven(value: bigint): boolean {\r\n  return value % 2n === 0n;\r\n}\r\n\r\nexport function abs(x: bigint): bigint {\r\n  return x < 0n ? -x : x;\r\n}\r\n\r\nexport function compare(x: bigint, y: bigint): -1 | 0 | 1 {\r\n  return x < y ? -1 : x > y ? 1 : 0;\r\n}\r\n\r\nexport function divmod(x: bigint, y: bigint): { quotient: bigint; remainder: bigint } {\r\n  const quotient = x / y;\r\n  const remainder = x % y;\r\n  return { quotient, remainder };\r\n}\r\n","import type { Temporal } from '..';\r\nimport type {\r\n  BuiltinCalendarId,\r\n  AnySlottedType,\r\n  FormatterOrAmender,\r\n  ISODate,\r\n  ISODateTime,\r\n  TimeRecord\r\n} from './internaltypes';\r\nimport type { DateTimeFormatImpl } from './intl';\r\n\r\n// Instant\r\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\r\n\r\n// DateTime, Date, Time, YearMonth, MonthDay\r\nexport const ISO_DATE = 'slot-iso-date';\r\nexport const ISO_DATE_TIME = 'slot-iso-date-time';\r\nexport const TIME = 'slot-time';\r\nexport const CALENDAR = 'slot-calendar';\r\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\r\nexport const DATE_BRAND = 'slot-date-brand';\r\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\r\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\r\n\r\n// ZonedDateTime\r\nexport const TIME_ZONE = 'slot-time-zone';\r\n\r\n// Duration\r\nexport const YEARS = 'slot-years';\r\nexport const MONTHS = 'slot-months';\r\nexport const WEEKS = 'slot-weeks';\r\nexport const DAYS = 'slot-days';\r\nexport const HOURS = 'slot-hours';\r\nexport const MINUTES = 'slot-minutes';\r\nexport const SECONDS = 'slot-seconds';\r\nexport const MILLISECONDS = 'slot-milliseconds';\r\nexport const MICROSECONDS = 'slot-microseconds';\r\nexport const NANOSECONDS = 'slot-nanoseconds';\r\n\r\n// DateTimeFormatImpl\r\nexport const DATE = 'date';\r\nexport const YM = 'ym';\r\nexport const MD = 'md';\r\nexport const TIME_FMT = 'time';\r\nexport const DATETIME = 'datetime';\r\nexport const INST = 'instant';\r\nexport const ORIGINAL = 'original';\r\nexport const TZ_CANONICAL = 'timezone-canonical';\r\nexport const TZ_ORIGINAL = 'timezone-original';\r\nexport const CAL_ID = 'calendar-id';\r\nexport const LOCALE = 'locale';\r\nexport const OPTIONS = 'options';\r\n\r\ninterface SlotInfo<ValueType, UsedByType extends AnySlottedType> {\r\n  value: ValueType;\r\n  usedBy: UsedByType;\r\n}\r\n\r\ninterface SlotInfoRecord {\r\n  [k: string]: SlotInfo<unknown, AnySlottedType>;\r\n}\r\n\r\ninterface Slots extends SlotInfoRecord {\r\n  // Instant\r\n  [EPOCHNANOSECONDS]: SlotInfo<bigint, Temporal.Instant | Temporal.ZonedDateTime>; \r\n\r\n  // DateTime, Date, Time, YearMonth, MonthDay\r\n  [ISO_DATE]: SlotInfo<ISODate, Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth>;\r\n  [ISO_DATE_TIME]: SlotInfo<ISODateTime, Temporal.PlainDateTime>;\r\n  [TIME]: SlotInfo<TimeRecord, Temporal.PlainTime>;\r\n  [CALENDAR]: SlotInfo<BuiltinCalendarId, TypesWithCalendarUnits>;\r\n\r\n  // Date, YearMonth, MonthDay common slots\r\n  [DATE_BRAND]: SlotInfo<true, Temporal.PlainDate>;\r\n  [YEAR_MONTH_BRAND]: SlotInfo<true, Temporal.PlainYearMonth>;\r\n  [MONTH_DAY_BRAND]: SlotInfo<true, Temporal.PlainMonthDay>;\r\n\r\n  // ZonedDateTime\r\n  [TIME_ZONE]: SlotInfo<string, Temporal.ZonedDateTime>;\r\n\r\n  // Duration\r\n  [YEARS]: SlotInfo<number, Temporal.Duration>;\r\n  [MONTHS]: SlotInfo<number, Temporal.Duration>;\r\n  [WEEKS]: SlotInfo<number, Temporal.Duration>;\r\n  [DAYS]: SlotInfo<number, Temporal.Duration>;\r\n  [HOURS]: SlotInfo<number, Temporal.Duration>;\r\n  [MINUTES]: SlotInfo<number, Temporal.Duration>;\r\n  [SECONDS]: SlotInfo<number, Temporal.Duration>;\r\n  [MILLISECONDS]: SlotInfo<number, Temporal.Duration>;\r\n  [MICROSECONDS]: SlotInfo<number, Temporal.Duration>;\r\n  [NANOSECONDS]: SlotInfo<number, Temporal.Duration>;\r\n\r\n  // DateTimeFormatImpl\r\n  [DATE]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [YM]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [MD]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [TIME_FMT]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [DATETIME]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [INST]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\r\n  [ORIGINAL]: SlotInfo<globalThis.Intl.DateTimeFormat, DateTimeFormatImpl>;\r\n  [TZ_CANONICAL]: SlotInfo<string, DateTimeFormatImpl>;\r\n  [TZ_ORIGINAL]: SlotInfo<string, DateTimeFormatImpl>;\r\n  [CAL_ID]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['calendar'], DateTimeFormatImpl>;\r\n  [LOCALE]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['locale'], DateTimeFormatImpl>;\r\n  [OPTIONS]: SlotInfo<Intl.DateTimeFormatOptions, DateTimeFormatImpl>;\r\n}\r\n\r\ntype TypesWithCalendarUnits =\r\n  | Temporal.PlainDateTime\r\n  | Temporal.PlainDate\r\n  | Temporal.PlainYearMonth\r\n  | Temporal.PlainMonthDay\r\n  | Temporal.ZonedDateTime;\r\n\r\ninterface SlotsToTypes {\r\n  // Instant\r\n  [EPOCHNANOSECONDS]: Temporal.Instant;\r\n\r\n  // DateTime, Date, Time, YearMonth, MonthDay\r\n  [ISO_DATE]: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay;\r\n  [ISO_DATE_TIME]: Temporal.PlainDateTime;\r\n  [TIME]: Temporal.PlainTime;\r\n  [CALENDAR]: TypesWithCalendarUnits;\r\n\r\n  // Date, YearMonth, MonthDay common slots\r\n  [DATE_BRAND]: Temporal.PlainDate;\r\n  [YEAR_MONTH_BRAND]: Temporal.PlainYearMonth;\r\n  [MONTH_DAY_BRAND]: Temporal.PlainMonthDay;\r\n\r\n  // ZonedDateTime\r\n  [TIME_ZONE]: Temporal.ZonedDateTime;\r\n\r\n  // Duration\r\n  [YEARS]: Temporal.Duration;\r\n  [MONTHS]: Temporal.Duration;\r\n  [WEEKS]: Temporal.Duration;\r\n  [DAYS]: Temporal.Duration;\r\n  [HOURS]: Temporal.Duration;\r\n  [MINUTES]: Temporal.Duration;\r\n  [SECONDS]: Temporal.Duration;\r\n  [MILLISECONDS]: Temporal.Duration;\r\n  [MICROSECONDS]: Temporal.Duration;\r\n  [NANOSECONDS]: Temporal.Duration;\r\n\r\n  // DateTimeFormatImpl\r\n  [DATE]: DateTimeFormatImpl;\r\n  [YM]: DateTimeFormatImpl;\r\n  [MD]: DateTimeFormatImpl;\r\n  [TIME_FMT]: DateTimeFormatImpl;\r\n  [DATETIME]: DateTimeFormatImpl;\r\n  [INST]: DateTimeFormatImpl;\r\n  [ORIGINAL]: DateTimeFormatImpl;\r\n  [TZ_CANONICAL]: DateTimeFormatImpl;\r\n  [TZ_ORIGINAL]: DateTimeFormatImpl;\r\n  [CAL_ID]: DateTimeFormatImpl;\r\n  [LOCALE]: DateTimeFormatImpl;\r\n  [OPTIONS]: DateTimeFormatImpl;\r\n}\r\n\r\ntype SlotKey = keyof SlotsToTypes;\r\n\r\nconst globalSlots = new WeakMap<Slots[keyof Slots]['usedBy'], Record<keyof Slots, Slots[keyof Slots]['value']>>();\r\n\r\nfunction _GetSlots(container: Slots[keyof Slots]['usedBy']) {\r\n  return globalSlots.get(container);\r\n}\r\n\r\nconst GetSlotsSymbol = Symbol.for('@@Temporal__GetSlots');\r\n\r\n// expose GetSlots to avoid dual package hazards\r\n(globalThis as any)[GetSlotsSymbol] ||= _GetSlots;\r\n\r\nconst GetSlots = (globalThis as any)[GetSlotsSymbol] as typeof _GetSlots;\r\n\r\nfunction _CreateSlots(container: Slots[keyof Slots]['usedBy']): void {\r\n  globalSlots.set(container, Object.create(null));\r\n}\r\n\r\nconst CreateSlotsSymbol = Symbol.for('@@Temporal__CreateSlots');\r\n\r\n// expose CreateSlots to avoid dual package hazards\r\n(globalThis as any)[CreateSlotsSymbol] ||= _CreateSlots;\r\n\r\nexport const CreateSlots = (globalThis as any)[CreateSlotsSymbol] as typeof _CreateSlots;\r\n\r\n// TODO: is there a better way than 9 overloads to make HasSlot into a type\r\n// guard that takes a variable number of parameters?\r\nexport function HasSlot<ID1 extends SlotKey>(container: unknown, id1: ID1): container is Slots[ID1]['usedBy'];\r\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2\r\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'];\r\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3\r\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'] | Slots[ID3]['usedBy'];\r\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey, ID4 extends SlotKey>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4\r\n): container is Slots[ID1 | ID2 | ID3 | ID4]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey,\r\n  ID7 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6,\r\n  id7: ID7\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey,\r\n  ID7 extends SlotKey,\r\n  ID8 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6,\r\n  id7: ID7,\r\n  id8: ID8\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8]['usedBy'];\r\nexport function HasSlot<\r\n  ID1 extends SlotKey,\r\n  ID2 extends SlotKey,\r\n  ID3 extends SlotKey,\r\n  ID4 extends SlotKey,\r\n  ID5 extends SlotKey,\r\n  ID6 extends SlotKey,\r\n  ID7 extends SlotKey,\r\n  ID8 extends SlotKey,\r\n  ID9 extends SlotKey\r\n>(\r\n  container: unknown,\r\n  id1: ID1,\r\n  id2: ID2,\r\n  id3: ID3,\r\n  id4: ID4,\r\n  id5: ID5,\r\n  id6: ID6,\r\n  id7: ID7,\r\n  id8: ID8,\r\n  id9: ID9\r\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8 | ID9]['usedBy'];\r\nexport function HasSlot(container: unknown, ...ids: (keyof Slots)[]): boolean {\r\n  if (!container || 'object' !== typeof container) return false;\r\n  const myslots = GetSlots(container as AnySlottedType);\r\n  return !!myslots && ids.every((id) => id in myslots);\r\n}\r\nexport function GetSlot<KeyT extends keyof Slots>(\r\n  container: Slots[typeof id]['usedBy'],\r\n  id: KeyT\r\n): Slots[KeyT]['value'] {\r\n  const value = GetSlots(container)?.[id];\r\n  if (value === undefined) throw new TypeError(`Missing internal slot ${id}`);\r\n  return value;\r\n}\r\nexport function SetSlot<KeyT extends SlotKey>(\r\n  container: Slots[KeyT]['usedBy'],\r\n  id: KeyT,\r\n  value: Slots[KeyT]['value']\r\n): void {\r\n  const slots = GetSlots(container);\r\n\r\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\r\n\r\n  const existingSlot = slots[id];\r\n\r\n  if (existingSlot) throw new TypeError(`${id} already has set`);\r\n\r\n  slots[id] = value;\r\n}\r\n\r\nexport function ResetSlot<KeyT extends SlotKey>(\r\n  container: DateTimeFormatImpl,\r\n  id: KeyT,\r\n  value: Slots[KeyT]['value']\r\n): void {\r\n  const slots = GetSlots(container);\r\n\r\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\r\n\r\n  const existingSlot = slots[id];\r\n\r\n  if (existingSlot === undefined) throw new TypeError(`tried to reset ${id} which was not set`);\r\n\r\n  slots[id] = value;\r\n}\r\n","import type { Temporal } from '..';\r\nimport type { CalendarImpl } from './calendar';\r\nimport type { BuiltinCalendarId } from './internaltypes';\r\nimport type { DateTimeFormatImpl } from './intl';\r\n\r\nimport { DEBUG } from './debug';\r\nimport { GetSlot, ORIGINAL } from './slots';\r\n\r\ntype OmitConstructor<T> = { [P in keyof T as T[P] extends new (...args: any[]) => any ? P : never]: T[P] };\r\n\r\ntype TemporalIntrinsics = {\r\n  ['Intl.DateTimeFormat']: typeof globalThis.Intl.DateTimeFormat;\r\n  ['Temporal.Duration']: typeof Temporal.Duration;\r\n  ['Temporal.Instant']: OmitConstructor<Temporal.Instant> &\r\n    (new (epochNanoseconds: bigint) => Temporal.Instant) & { prototype: typeof Temporal.Instant.prototype };\r\n  ['Temporal.PlainDate']: typeof Temporal.PlainDate;\r\n  ['Temporal.PlainDateTime']: typeof Temporal.PlainDateTime;\r\n  ['Temporal.PlainMonthDay']: typeof Temporal.PlainMonthDay;\r\n  ['Temporal.PlainTime']: typeof Temporal.PlainTime;\r\n  ['Temporal.PlainYearMonth']: typeof Temporal.PlainYearMonth;\r\n  ['Temporal.ZonedDateTime']: OmitConstructor<Temporal.ZonedDateTime> &\r\n    (new (epochNanoseconds: bigint, timeZone: string, calendar?: string) => Temporal.ZonedDateTime) & {\r\n      prototype: typeof Temporal.ZonedDateTime.prototype;\r\n      from: typeof Temporal.ZonedDateTime.from;\r\n      compare: typeof Temporal.ZonedDateTime.compare;\r\n    };\r\n};\r\ntype TemporalIntrinsicRegistrations = {\r\n  [key in keyof TemporalIntrinsics]: TemporalIntrinsics[key];\r\n};\r\ntype TemporalIntrinsicPrototypeRegistrations = {\r\n  [key in keyof TemporalIntrinsics as `${key}.prototype`]: TemporalIntrinsics[key]['prototype'];\r\n};\r\ntype TemporalIntrinsicRegisteredKeys = {\r\n  [key in keyof TemporalIntrinsicRegistrations as `%${key}%`]: TemporalIntrinsicRegistrations[key];\r\n};\r\ntype TemporalIntrinsicPrototypeRegisteredKeys = {\r\n  [key in keyof TemporalIntrinsicPrototypeRegistrations as `%${key}%`]: TemporalIntrinsicPrototypeRegistrations[key];\r\n};\r\n\r\ntype OtherIntrinsics = {\r\n  calendarImpl: (id: BuiltinCalendarId) => CalendarImpl;\r\n};\r\ntype OtherIntrinsicKeys = { [key in keyof OtherIntrinsics as `%${key}%`]: OtherIntrinsics[key] };\r\n\r\nconst INTRINSICS = {} as TemporalIntrinsicRegisteredKeys &\r\n  TemporalIntrinsicPrototypeRegisteredKeys &\r\n  OtherIntrinsicKeys;\r\n\r\ntype StylizeOption = (value: unknown, type: 'number' | 'special') => string;\r\n\r\ntype customFormatFunction<T> = (\r\n  this: T & { _repr_: string }, // _repr_ is present if DEBUG\r\n  depth: number,\r\n  options: { stylize: StylizeOption },\r\n  inspect: (object: T, options?: { depth: number; stylize: StylizeOption }) => string\r\n) => string;\r\nconst customUtilInspectFormatters: Partial<{\r\n  [key in keyof TemporalIntrinsicRegistrations]: customFormatFunction<\r\n    InstanceType<TemporalIntrinsicRegistrations[key]>\r\n  >;\r\n}> = {\r\n  ['Intl.DateTimeFormat'](depth, options, inspect) {\r\n    return inspect(GetSlot(this as DateTimeFormatImpl, ORIGINAL), { depth, ...options });\r\n  },\r\n  ['Temporal.Duration'](depth, options) {\r\n    const descr = options.stylize(this._repr_, 'special');\r\n    if (depth < 1) return descr;\r\n    const entries: string[] = [];\r\n    const props = [\r\n      'years',\r\n      'months',\r\n      'weeks',\r\n      'days',\r\n      'hours',\r\n      'minutes',\r\n      'seconds',\r\n      'milliseconds',\r\n      'microseconds',\r\n      'nanoseconds'\r\n    ] as const;\r\n    for (let i = 0; i < props.length; i++) {\r\n      const prop = props[i];\r\n      if (this[prop] !== 0) {\r\n        entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\r\n      }\r\n    }\r\n    return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\r\n  }\r\n};\r\n\r\ntype InspectFormatterOptions = { stylize: (str: string, styleType: string) => string };\r\nfunction defaultUtilInspectFormatter(this: any, depth: number, options: InspectFormatterOptions) {\r\n  return options.stylize(this._repr_, 'special');\r\n}\r\n\r\nexport function MakeIntrinsicClass(\r\n  Class: TemporalIntrinsicRegistrations[typeof name],\r\n  name: keyof TemporalIntrinsicRegistrations\r\n) {\r\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\r\n    value: name,\r\n    writable: false,\r\n    enumerable: false,\r\n    configurable: true\r\n  });\r\n  if (DEBUG) {\r\n    Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\r\n      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: true\r\n    });\r\n  }\r\n  const staticNames = Object.getOwnPropertyNames(Class);\r\n  for (let i = 0; i < staticNames.length; i++) {\r\n    const prop = staticNames[i];\r\n    // we know that `prop` is present, so the descriptor is never undefined\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    const desc = Object.getOwnPropertyDescriptor(Class, prop)!;\r\n    if (!desc.configurable || !desc.enumerable) continue;\r\n    desc.enumerable = false;\r\n    Object.defineProperty(Class, prop, desc);\r\n  }\r\n  const protoNames = Object.getOwnPropertyNames(Class.prototype);\r\n  for (let i = 0; i < protoNames.length; i++) {\r\n    const prop = protoNames[i];\r\n    // we know that `prop` is present, so the descriptor is never undefined\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop)!;\r\n    if (!desc.configurable || !desc.enumerable) continue;\r\n    desc.enumerable = false;\r\n    Object.defineProperty(Class.prototype, prop, desc);\r\n  }\r\n\r\n  DefineIntrinsic(name, Class);\r\n  DefineIntrinsic(`${name}.prototype`, Class.prototype);\r\n}\r\n\r\ntype IntrinsicDefinitionKeys =\r\n  | keyof TemporalIntrinsicRegistrations\r\n  | keyof TemporalIntrinsicPrototypeRegistrations\r\n  | keyof OtherIntrinsics;\r\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicRegistrations>(\r\n  name: KeyT,\r\n  value: TemporalIntrinsicRegistrations[KeyT]\r\n): void;\r\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicPrototypeRegistrations>(\r\n  name: KeyT,\r\n  value: TemporalIntrinsicPrototypeRegistrations[KeyT]\r\n): void;\r\nexport function DefineIntrinsic<KeyT extends keyof OtherIntrinsics>(name: KeyT, value: OtherIntrinsics[KeyT]): void;\r\nexport function DefineIntrinsic<KeyT>(name: KeyT, value: never): void;\r\nexport function DefineIntrinsic<KeyT extends IntrinsicDefinitionKeys>(name: KeyT, value: unknown): void {\r\n  const key: `%${IntrinsicDefinitionKeys}%` = `%${name}%`;\r\n  if (INTRINSICS[key] !== undefined) throw new Error(`intrinsic ${name} already exists`);\r\n  INTRINSICS[key] = value;\r\n}\r\nexport function GetIntrinsic<KeyT extends keyof typeof INTRINSICS>(intrinsic: KeyT): (typeof INTRINSICS)[KeyT] {\r\n  return INTRINSICS[intrinsic];\r\n}\r\n","import type { Temporal } from '..';\r\n\r\n// Computes trunc(x / 10**p) and x % 10**p, returning { div, mod }, with\r\n// precision loss only once in the quotient, by string manipulation. If the\r\n// quotient and remainder are safe integers, then they are exact. x must be an\r\n// integer. p must be a non-negative integer. Both div and mod have the sign of\r\n// x.\r\nexport function TruncatingDivModByPowerOf10(xParam: number, p: number) {\r\n  let x = xParam;\r\n  if (x === 0) return { div: x, mod: x }; // preserves signed zero\r\n\r\n  const sign = Math.sign(x);\r\n  x = Math.abs(x);\r\n\r\n  const xDigits = Math.trunc(1 + Math.log10(x));\r\n  if (p >= xDigits) return { div: sign * 0, mod: sign * x };\r\n  if (p === 0) return { div: sign * x, mod: sign * 0 };\r\n\r\n  // would perform nearest rounding if x was not an integer:\r\n  const xStr = x.toPrecision(xDigits);\r\n  const div = sign * Number.parseInt(xStr.slice(0, xDigits - p), 10);\r\n  const mod = sign * Number.parseInt(xStr.slice(xDigits - p), 10);\r\n\r\n  return { div, mod };\r\n}\r\n\r\n// Computes x * 10**p + z with precision loss only at the end, by string\r\n// manipulation. If the result is a safe integer, then it is exact. x must be\r\n// an integer. p must be a non-negative integer. z must have the same sign as\r\n// x and be less than 10**p.\r\nexport function FMAPowerOf10(xParam: number, p: number, zParam: number) {\r\n  let x = xParam;\r\n  let z = zParam;\r\n  if (x === 0) return z;\r\n\r\n  const sign = Math.sign(x) || Math.sign(z);\r\n  x = Math.abs(x);\r\n  z = Math.abs(z);\r\n\r\n  const xStr = x.toPrecision(Math.trunc(1 + Math.log10(x)));\r\n\r\n  if (z === 0) return sign * Number.parseInt(xStr + '0'.repeat(p), 10);\r\n\r\n  const zStr = z.toPrecision(Math.trunc(1 + Math.log10(z)));\r\n\r\n  const resStr = xStr + zStr.padStart(p, '0');\r\n  return sign * Number.parseInt(resStr, 10);\r\n}\r\n\r\ntype UnsignedRoundingMode = 'half-even' | 'half-infinity' | 'half-zero' | 'infinity' | 'zero';\r\n\r\nexport function GetUnsignedRoundingMode(\r\n  mode: Temporal.RoundingMode,\r\n  sign: 'positive' | 'negative'\r\n): UnsignedRoundingMode {\r\n  const isNegative = sign === 'negative';\r\n  switch (mode) {\r\n    case 'ceil':\r\n      return isNegative ? 'zero' : 'infinity';\r\n    case 'floor':\r\n      return isNegative ? 'infinity' : 'zero';\r\n    case 'expand':\r\n      return 'infinity';\r\n    case 'trunc':\r\n      return 'zero';\r\n    case 'halfCeil':\r\n      return isNegative ? 'half-zero' : 'half-infinity';\r\n    case 'halfFloor':\r\n      return isNegative ? 'half-infinity' : 'half-zero';\r\n    case 'halfExpand':\r\n      return 'half-infinity';\r\n    case 'halfTrunc':\r\n      return 'half-zero';\r\n    case 'halfEven':\r\n      return 'half-even';\r\n  }\r\n}\r\n\r\n// Omits first step from spec algorithm so that it can be used both for\r\n// RoundNumberToIncrement and RoundTimeDurationToIncrement\r\nexport function ApplyUnsignedRoundingMode<T extends number | bigint>(\r\n  r1: T,\r\n  r2: T,\r\n  cmp: -1 | 0 | 1,\r\n  evenCardinality: boolean,\r\n  unsignedRoundingMode: UnsignedRoundingMode\r\n) {\r\n  if (unsignedRoundingMode === 'zero') return r1;\r\n  if (unsignedRoundingMode === 'infinity') return r2;\r\n  if (cmp < 0) return r1;\r\n  if (cmp > 0) return r2;\r\n  if (unsignedRoundingMode === 'half-zero') return r1;\r\n  if (unsignedRoundingMode === 'half-infinity') return r2;\r\n  return evenCardinality ? r1 : r2;\r\n}\r\n","import { assert } from './assert';\r\nimport {\r\n  abs,\r\n  BILLION,\r\n  compare,\r\n  divmod,\r\n  DAY_NANOS,\r\n  HOUR_NANOS,\r\n  MINUTE_NANOS,\r\n  isEven,\r\n  MILLION,\r\n  ONE,\r\n  TEN,\r\n  THOUSAND,\r\n  TWO,\r\n  ZERO\r\n} from './bigintmath';\r\nimport { ApplyUnsignedRoundingMode, GetUnsignedRoundingMode } from './math';\r\nimport type { Temporal } from '..';\r\n\r\nexport class TimeDuration {\r\n  static MAX = 9007199254740991999999999n;\r\n  static ZERO = new TimeDuration(ZERO);\r\n\r\n  totalNs: bigint;\r\n  sec: number;\r\n  subsec: number;\r\n\r\n  constructor(totalNs: bigint) {\r\n    assert(typeof totalNs !== 'bigint', 'big integer required');\r\n    this.totalNs = totalNs;\r\n    assert(abs(this.totalNs) <= TimeDuration.MAX, 'integer too big');\r\n\r\n    this.sec = Number(this.totalNs / BILLION);\r\n    this.subsec = Number(this.totalNs % BILLION);\r\n    assert(Number.isSafeInteger(this.sec), 'seconds too big');\r\n    assert(Math.abs(this.subsec) <= 999_999_999, 'subseconds too big');\r\n  }\r\n\r\n  static validateNew(totalNs: bigint, operation: string) {\r\n    if (abs(totalNs) > TimeDuration.MAX) {\r\n      throw new RangeError(`${operation} of duration time units cannot exceed ${TimeDuration.MAX} s`);\r\n    }\r\n    return new TimeDuration(totalNs);\r\n  }\r\n\r\n  static fromEpochNsDiff(epochNs1: bigint, epochNs2: bigint) {\r\n    const diff = epochNs1 - epochNs2;\r\n    // No extra validate step. Should instead fail assertion if too big\r\n    return new TimeDuration(diff);\r\n  }\r\n\r\n  static fromComponents(h: number, min: number, s: number, ms: number, µs: number, ns: number) {\r\n    const totalNs =\r\n      BigInt(ns) +\r\n      BigInt(µs) * THOUSAND +\r\n      BigInt(ms) * MILLION +\r\n      BigInt(s) * BILLION +\r\n      BigInt(min) * MINUTE_NANOS +\r\n      BigInt(h) * HOUR_NANOS;\r\n    return TimeDuration.validateNew(totalNs, 'total');\r\n  }\r\n\r\n  abs() {\r\n    return new TimeDuration(abs(this.totalNs));\r\n  }\r\n\r\n  add(other: TimeDuration) {\r\n    return TimeDuration.validateNew(this.totalNs + other.totalNs, 'sum');\r\n  }\r\n\r\n  add24HourDays(days: number) {\r\n    assert(Number.isInteger(days), 'days must be an integer');\r\n    return TimeDuration.validateNew(this.totalNs + BigInt(days) * DAY_NANOS, 'sum');\r\n  }\r\n\r\n  addToEpochNs(epochNs: bigint) {\r\n    return epochNs + this.totalNs;\r\n  }\r\n\r\n  cmp(other: TimeDuration) {\r\n    return compare(this.totalNs, other.totalNs);\r\n  }\r\n\r\n  divmod(n: number) {\r\n    assert(n !== 0, 'division by zero');\r\n    const { quotient, remainder } = divmod(this.totalNs, BigInt(n));\r\n    const q = quotient;\r\n    const r = new TimeDuration(remainder);\r\n    return { quotient: q, remainder: r };\r\n  }\r\n\r\n  fdiv(nParam: bigint) {\r\n    const n = nParam;\r\n    assert(n !== ZERO, 'division by zero');\r\n    const nBigInt = BigInt(n);\r\n    let { quotient, remainder } = divmod(this.totalNs, nBigInt);\r\n\r\n    // Perform long division to calculate the fractional part of the quotient\r\n    // remainder / n with more accuracy than 64-bit floating point division\r\n    const precision = 50;\r\n    const decimalDigits: number[] = [];\r\n    let digit;\r\n    const sign = (this.totalNs < 0n ? -1 : 1) * Math.sign(Number(n));\r\n    while (remainder !== 0n && decimalDigits.length < precision) {\r\n      remainder = remainder * TEN;\r\n      ({ quotient: digit, remainder } = divmod(remainder, nBigInt));\r\n      decimalDigits.push(Math.abs(Number(digit)));\r\n    }\r\n    return sign * Number(abs(quotient).toString() + '.' + decimalDigits.join(''));\r\n  }\r\n\r\n  isZero() {\r\n    return this.totalNs === ZERO;\r\n  }\r\n\r\n  round(incrementParam: bigint, mode: Temporal.RoundingMode) {\r\n    const increment = incrementParam;\r\n    if (increment === ONE) return this;\r\n    const { quotient, remainder } = divmod(this.totalNs, increment);\r\n    const sign = this.totalNs < 0n ? 'negative' : 'positive';\r\n    const r1 = abs(quotient) * increment;\r\n    const r2 = r1 + increment;\r\n    const cmp = compare(abs(remainder * TWO), increment);\r\n    const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\r\n    const rounded = \r\n      remainder === 0n ? r1 : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(quotient), unsignedRoundingMode);\r\n    const result = sign === 'positive' ? rounded : -rounded;\r\n    return TimeDuration.validateNew(result, 'rounding');\r\n  }\r\n\r\n  sign() {\r\n    return this.cmp(new TimeDuration(ZERO));\r\n  }\r\n\r\n  subtract(other: TimeDuration) {\r\n    return TimeDuration.validateNew(this.totalNs - other.totalNs, 'difference');\r\n  }\r\n}\r\n","const offsetIdentifierNoCapture = /(?:[+-](?:[01][0-9]|2[0-3])(?::?[0-5][0-9])?)/;\r\nconst tzComponent = /[A-Za-z._][A-Za-z._0-9+-]*/;\r\nexport const timeZoneID = new RegExp(\r\n  `(?:${offsetIdentifierNoCapture.source}|(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*)`\r\n);\r\n\r\nconst yearpart = /(?:[+-]\\d{6}|\\d{4})/;\r\nconst monthpart = /(?:0[1-9]|1[0-2])/;\r\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\r\nconst datesplit = new RegExp(\r\n  `(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`\r\n);\r\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\r\nexport const offsetWithParts = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\r\nexport const offset = /((?:[+-])(?:[01][0-9]|2[0-3])(?::?(?:[0-5][0-9])(?::?(?:[0-5][0-9])(?:[.,](?:\\d{1,9}))?)?)?)/;\r\nconst offsetpart = new RegExp(`([zZ])|${offset.source}?`);\r\nexport const offsetIdentifier = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])?)?/;\r\nexport const annotation = /\\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\\]/g;\r\n\r\nexport const zoneddatetime = new RegExp(\r\n  [\r\n    `^${datesplit.source}`,\r\n    `(?:(?:[tT]|\\\\s+)${timesplit.source}(?:${offsetpart.source})?)?`,\r\n    `(?:\\\\[!?(${timeZoneID.source})\\\\])?`,\r\n    `((?:${annotation.source})*)$`\r\n  ].join('')\r\n);\r\n\r\nexport const time = new RegExp(\r\n  [\r\n    `^[tT]?${timesplit.source}`,\r\n    `(?:${offsetpart.source})?`,\r\n    `(?:\\\\[!?${timeZoneID.source}\\\\])?`,\r\n    `((?:${annotation.source})*)$`\r\n  ].join('')\r\n);\r\n\r\n// The short forms of YearMonth and MonthDay are only for the ISO calendar, but\r\n// annotations are still allowed, and will throw if the calendar annotation is\r\n// not ISO.\r\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\r\n// with the reference fields.\r\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\r\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\r\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\r\n// UTC offsets are not allowed, because they are not allowed with any date-only\r\n// format; also, YYYY-MM-UU is ambiguous with YYYY-MM-DD\r\nexport const yearmonth = new RegExp(\r\n  `^(${yearpart.source})-?(${monthpart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\r\n);\r\nexport const monthday = new RegExp(\r\n  `^(?:--)?(${monthpart.source})-?(${daypart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\r\n);\r\n\r\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\r\n\r\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\r\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\r\nexport const duration = new RegExp(`^([+-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\r\n","import { DEBUG, ENABLE_ASSERTS } from './debug';\r\n\r\nimport type { Temporal } from '..';\r\nimport { assert, assertNotReached } from './assert';\r\nimport { abs, compare, divmod, isEven, MILLION, ONE, TWO, ZERO } from './bigintmath';\r\nimport type { CalendarImpl } from './calendar';\r\nimport type {\r\n  AnyTemporalLikeType,\r\n  UnitSmallerThanOrEqualTo,\r\n  InstantParams,\r\n  PlainMonthDayParams,\r\n  ZonedDateTimeParams,\r\n  PlainDateParams,\r\n  PlainTimeParams,\r\n  DurationParams,\r\n  PlainDateTimeParams,\r\n  PlainYearMonthParams,\r\n  BuiltinCalendarId,\r\n  Keys,\r\n  AnyTemporalKey,\r\n  FieldKey,\r\n  InternalDuration,\r\n  ISODateTime,\r\n  ISODate,\r\n  TimeRecord,\r\n  ISODateToFieldsType,\r\n  DateDuration,\r\n  CalendarFieldsRecord,\r\n  MonthDayFromFieldsObject,\r\n  Overflow,\r\n  Resolve,\r\n  AnySlottedType\r\n} from './internaltypes';\r\nimport { GetIntrinsic } from './intrinsicclass';\r\nimport { ApplyUnsignedRoundingMode, FMAPowerOf10, GetUnsignedRoundingMode, TruncatingDivModByPowerOf10 } from './math';\r\nimport { TimeDuration } from './timeduration';\r\nimport {\r\n  CreateSlots,\r\n  GetSlot,\r\n  HasSlot,\r\n  SetSlot,\r\n  EPOCHNANOSECONDS,\r\n  ISO_DATE,\r\n  ISO_DATE_TIME,\r\n  TIME,\r\n  DATE_BRAND,\r\n  YEAR_MONTH_BRAND,\r\n  MONTH_DAY_BRAND,\r\n  TIME_ZONE,\r\n  CALENDAR,\r\n  YEARS,\r\n  MONTHS,\r\n  WEEKS,\r\n  DAYS,\r\n  HOURS,\r\n  MINUTES,\r\n  SECONDS,\r\n  MILLISECONDS,\r\n  MICROSECONDS,\r\n  NANOSECONDS\r\n} from './slots';\r\n\r\nconst DAY_MS = 86400_000;\r\nexport const DAY_NANOS = DAY_MS * 1e6;\r\nexport const DAY_NANOS_BI = BigInt(DAY_NANOS);\r\nconst MINUTE_NANOS = 60e9;\r\n// Instant range is 100 million days (inclusive) before or after epoch.\r\nconst MS_MAX = DAY_MS * 1e8;\r\nconst NS_MAX = epochMsToNs(MS_MAX);\r\nconst NS_MIN = -NS_MAX;\r\n// PlainDateTime range is 24 hours wider (exclusive) than the Instant range on\r\n// both ends, to allow for valid Instant=>PlainDateTime conversion for all\r\n// built-in time zones (whose offsets must have a magnitude less than 24 hours).\r\nconst DATETIME_NS_MIN = DAY_NANOS_BI - NS_MIN + ONE;\r\nconst DATETIME_NS_MAX = DAY_NANOS_BI + NS_MAX - ONE;\r\n// The pattern of leap years in the ISO 8601 calendar repeats every 400 years.\r\n// The constant below is the number of nanoseconds in 400 years. It is used to\r\n// avoid overflows when dealing with values at the edge legacy Date's range.\r\nconst MS_IN_400_YEAR_CYCLE = (400 * 365 + 97) * DAY_MS;\r\nconst YEAR_MIN = -271821;\r\nconst YEAR_MAX = 275760;\r\nconst BEFORE_FIRST_DST = Date.UTC(1847, 0, 1); // 1847-01-01T00:00:00Z\r\n\r\nconst BUILTIN_CALENDAR_IDS = [\r\n  'iso8601',\r\n  'hebrew',\r\n  'islamic',\r\n  'islamic-umalqura',\r\n  'islamic-tbla',\r\n  'islamic-civil',\r\n  'islamic-rgsa',\r\n  'islamicc',\r\n  'persian',\r\n  'ethiopic',\r\n  'ethioaa',\r\n  'ethiopic-amete-alem',\r\n  'coptic',\r\n  'chinese',\r\n  'dangi',\r\n  'roc',\r\n  'indian',\r\n  'buddhist',\r\n  'japanese',\r\n  'gregory'\r\n];\r\n\r\nconst ICU_LEGACY_TIME_ZONE_IDS = new Set([\r\n  'ACT',\r\n  'AET',\r\n  'AGT',\r\n  'ART',\r\n  'AST',\r\n  'BET',\r\n  'BST',\r\n  'CAT',\r\n  'CNT',\r\n  'CST',\r\n  'CTT',\r\n  'EAT',\r\n  'ECT',\r\n  'IET',\r\n  'IST',\r\n  'JST',\r\n  'MIT',\r\n  'NET',\r\n  'NST',\r\n  'PLT',\r\n  'PNT',\r\n  'PRT',\r\n  'PST',\r\n  'SST',\r\n  'VST'\r\n]);\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */\r\n/**\r\n * uncheckedAssertNarrowedType forces TypeScript to change the type of the argument to the one given in\r\n * the type parameter. This should only be used to help TS understand when variables change types,\r\n * but TS can't or won't infer this automatically. They should be used sparingly, because\r\n * if used incorrectly can lead to difficult-to-diagnose problems.\r\n * */\r\nexport function uncheckedAssertNarrowedType<T = unknown>(\r\n  arg: unknown,\r\n  justification: string\r\n): asserts arg is T extends typeof arg ? T : never {}\r\n/* eslint-enable */\r\n\r\n/**\r\n * In debug builds, this function verifies that the given argument \"exists\" (is not\r\n * null or undefined). This function becomes a no-op in the final bundles distributed via NPM.\r\n * @param arg\r\n */\r\nexport function assertExists<A>(arg: A): asserts arg is NonNullable<A> {\r\n  if (ENABLE_ASSERTS) {\r\n    if (arg == null) {\r\n      throw new Error('Expected arg to be set.');\r\n    }\r\n  }\r\n}\r\n\r\n/** Similar to assertExists, but returns the argument. */\r\nfunction castExists<A>(arg: A): NonNullable<A> {\r\n  assertExists(arg);\r\n  return arg;\r\n}\r\n\r\n// For unknown values, this narrows the result to a Record. But for union types\r\n// like `Temporal.DurationLike | string`, it'll strip the primitive types while\r\n// leaving the object type(s) unchanged.\r\nexport function IsObject<T>(\r\n  value: T\r\n): value is Exclude<T, string | null | undefined | number | bigint | symbol | boolean>;\r\nexport function IsObject(value: unknown): value is Record<string | number | symbol, unknown> {\r\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\r\n}\r\n\r\nexport function ToNumber(value: unknown): number {\r\n  // ES 2022's es-abstract made minor changes to ToNumber, but polyfilling these\r\n  // changes adds zero benefit to Temporal and brings in a lot of extra code. So\r\n  // we'll leave ToNumber as-is.\r\n  // See https://github.com/ljharb/es-abstract/blob/main/2022/ToNumber.js\r\n  if (typeof value === 'bigint') throw new TypeError('Cannot convert BigInt to number');\r\n  return Number(value);\r\n}\r\n\r\nfunction IsIntegralNumber(argument: unknown) {\r\n  if (typeof argument !== 'number' || Number.isNaN(argument) || argument === Infinity || argument === -Infinity) {\r\n    return false;\r\n  }\r\n  const absValue = Math.abs(argument);\r\n  return Math.floor(absValue) === absValue;\r\n}\r\n\r\nexport function ToString(value: unknown): string {\r\n  if (typeof value === 'symbol') {\r\n    throw new TypeError('Cannot convert a Symbol value to a String');\r\n  }\r\n  return String(value);\r\n}\r\n\r\nexport function ToIntegerWithTruncation(value: unknown): number {\r\n  const number = ToNumber(value);\r\n  if (number === 0) return 0;\r\n  if (Number.isNaN(number) || number === Infinity || number === -Infinity) {\r\n    throw new RangeError('invalid number value');\r\n  }\r\n  const integer = Math.trunc(number);\r\n  if (integer === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\r\n  return integer;\r\n}\r\n\r\nfunction ToPositiveIntegerWithTruncation(valueParam: unknown, property?: string): number {\r\n  const integer = ToIntegerWithTruncation(valueParam);\r\n  if (integer <= 0) {\r\n    if (property !== undefined) {\r\n      throw new RangeError(`property '${property}' cannot be a a number less than one`);\r\n    }\r\n    throw new RangeError('Cannot convert a number less than one to a positive integer');\r\n  }\r\n  return integer;\r\n}\r\n\r\nexport function ToIntegerIfIntegral(valueParam: unknown): number {\r\n  const number = ToNumber(valueParam);\r\n  if (Number.isNaN(number)) throw new RangeError('not a number');\r\n  if (number === Infinity || number === -Infinity) throw new RangeError('infinity is out of range');\r\n  if (!IsIntegralNumber(number)) throw new RangeError(`unsupported fractional value ${valueParam}`);\r\n  if (number === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\r\n  return number;\r\n}\r\n\r\nfunction ToZeroPaddedDecimalString(n: number, minLength: number) {\r\n  if (DEBUG) {\r\n    if (!IsIntegralNumber(n) || n < 0) {\r\n      throw new RangeError('Assertion failed: `${n}` must be a non-negative integer');\r\n    }\r\n  }\r\n  const s = String(n);\r\n  return s.padStart(minLength, '0');\r\n}\r\n\r\n// This convenience function isn't in the spec, but is useful in the polyfill\r\n// for DRY and better error messages.\r\nexport function RequireString(value: unknown): string {\r\n  if (typeof value !== 'string') {\r\n    // Use String() to ensure that Symbols won't throw\r\n    throw new TypeError(`expected a string, not ${String(value)}`);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction ToSyntacticallyValidMonthCode(valueParam: unknown) {\r\n  const value = RequireString(ToPrimitive(valueParam, String));\r\n  if (\r\n    value.length < 3 ||\r\n    value.length > 4 ||\r\n    value[0] !== 'M' ||\r\n    '0123456789'.indexOf(value[1]) === -1 ||\r\n    '0123456789'.indexOf(value[2]) === -1 ||\r\n    (value[1] + value[2] === '00' && value[3] !== 'L') ||\r\n    (value[3] !== 'L' && value[3] !== undefined)\r\n  ) {\r\n    throw new RangeError(`bad month code ${value}; must match M01-M99 or M00L-M99L`);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction ToOffsetString(valueParam: unknown) {\r\n  const value = RequireString(ToPrimitive(valueParam, String));\r\n  ParseDateTimeUTCOffset(value);\r\n  return value;\r\n}\r\n\r\n// Limited implementation of ToPrimitive that only handles the string case,\r\n// because that's all that's used in this polyfill.\r\nfunction ToPrimitive(value: unknown, preferredType: typeof String): string | number {\r\n  assertExists(preferredType === String);\r\n  if (IsObject(value)) {\r\n    const result = value?.toString();\r\n    if (typeof result === 'string' || typeof result === 'number') return result;\r\n    throw new TypeError('Cannot convert object to primitive value');\r\n  }\r\n  return value;\r\n}\r\n\r\nconst CALENDAR_FIELD_KEYS: readonly FieldKey[] = [\r\n  'era',\r\n  'eraYear',\r\n  'year',\r\n  'month',\r\n  'monthCode',\r\n  'day',\r\n  'hour',\r\n  'minute',\r\n  'second',\r\n  'millisecond',\r\n  'microsecond',\r\n  'nanosecond',\r\n  'offset',\r\n  'timeZone'\r\n] as const;\r\n\r\ntype BuiltinCastFunction = (v: unknown) => string | number;\r\nconst BUILTIN_CASTS: Partial<Record<FieldKey, BuiltinCastFunction>> = {\r\n  era: ToString,\r\n  eraYear: ToIntegerWithTruncation,\r\n  year: ToIntegerWithTruncation,\r\n  month: ToPositiveIntegerWithTruncation,\r\n  monthCode: ToSyntacticallyValidMonthCode,\r\n  day: ToPositiveIntegerWithTruncation,\r\n  hour: ToIntegerWithTruncation,\r\n  minute: ToIntegerWithTruncation,\r\n  second: ToIntegerWithTruncation,\r\n  millisecond: ToIntegerWithTruncation,\r\n  microsecond: ToIntegerWithTruncation,\r\n  nanosecond: ToIntegerWithTruncation,\r\n  offset: ToOffsetString,\r\n  timeZone: ToTemporalTimeZoneIdentifier\r\n};\r\n\r\nconst BUILTIN_DEFAULTS: Partial<Record<FieldKey, number>> = {\r\n  hour: 0,\r\n  minute: 0,\r\n  second: 0,\r\n  millisecond: 0,\r\n  microsecond: 0,\r\n  nanosecond: 0\r\n};\r\n\r\n// each item is [plural, singular, category, (length in ns)]\r\nconst TEMPORAL_UNITS = [\r\n  ['years', 'year', 'date'],\r\n  ['months', 'month', 'date'],\r\n  ['weeks', 'week', 'date'],\r\n  ['days', 'day', 'date'],\r\n  ['hours', 'hour', 'time'],\r\n  ['minutes', 'minute', 'time'],\r\n  ['seconds', 'second', 'time'],\r\n  ['milliseconds', 'millisecond', 'time'],\r\n  ['microseconds', 'microsecond', 'time'],\r\n  ['nanoseconds', 'nanosecond', 'time']\r\n] as const;\r\nconst SINGULAR_FOR = Object.fromEntries(TEMPORAL_UNITS.map((e) => [e[0], e[1]] as const));\r\nconst PLURAL_FOR = Object.fromEntries(TEMPORAL_UNITS.map(([p, s]) => [s, p] as const));\r\nconst UNITS_DESCENDING = TEMPORAL_UNITS.map(([, s]) => s);\r\ntype TimeUnitOrDay = Temporal.TimeUnit | 'day';\r\nconst NS_PER_TIME_UNIT = {\r\n  day: DAY_NANOS,\r\n  hour: 3600e9,\r\n  minute: 60e9,\r\n  second: 1e9,\r\n  millisecond: 1e6,\r\n  microsecond: 1e3,\r\n  nanosecond: 1\r\n};\r\n\r\nconst DURATION_FIELDS = [\r\n  'days',\r\n  'hours',\r\n  'microseconds',\r\n  'milliseconds',\r\n  'minutes',\r\n  'months',\r\n  'nanoseconds',\r\n  'seconds',\r\n  'weeks',\r\n  'years'\r\n] as const;\r\n\r\nimport * as PARSE from './regex';\r\n\r\n// Save the original Intl.DateTimeFormat, it will likely be overwritten with the\r\n// one from this polyfill. Caching the formatter below may be reentrant, so we\r\n// need to use the original one\r\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\r\nconst IntlDateTimeFormatEnUsCache = new Map<string, Intl.DateTimeFormat>();\r\n\r\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier: string) {\r\n  const lowercaseIdentifier = ASCIILowercase(timeZoneIdentifier);\r\n  let instance = IntlDateTimeFormatEnUsCache.get(lowercaseIdentifier);\r\n  if (instance === undefined) {\r\n    instance = new OriginalIntlDateTimeFormat('en-us', {\r\n      timeZone: lowercaseIdentifier,\r\n      hour12: false,\r\n      era: 'short',\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n    IntlDateTimeFormatEnUsCache.set(lowercaseIdentifier, instance);\r\n  }\r\n  return instance;\r\n}\r\n\r\nexport function ToObject<T>(value: T): T extends Record<string, unknown> ? T : Record<PropertyKey, unknown> {\r\n  if (typeof value === 'undefined' || value === null) {\r\n    throw new TypeError(`Expected object not ${value}`);\r\n  }\r\n  return Object(value);\r\n}\r\n\r\n// Adapted from https://github.com/ljharb/es-abstract/blob/main/2022/CopyDataProperties.js\r\n// but simplified (e.g. removed assertions) for this polyfill to reduce bundle size.\r\nexport function CopyDataProperties<K extends PropertyKey, T extends Record<K, unknown>>(\r\n  target: T,\r\n  source: T | undefined,\r\n  excludedKeys: K[],\r\n  excludedValues?: unknown[]\r\n) {\r\n  if (typeof source === 'undefined' || source === null) return;\r\n\r\n  const keys = Reflect.ownKeys(source) as (keyof T)[];\r\n  for (let index = 0; index < keys.length; index++) {\r\n    const nextKey = keys[index];\r\n    if (excludedKeys.some((e) => Object.is(e, nextKey))) continue;\r\n    if (Object.prototype.propertyIsEnumerable.call(source, nextKey)) {\r\n      const propValue = source[nextKey];\r\n      if (excludedValues && excludedValues.some((e) => Object.is(e, propValue))) continue;\r\n\r\n      target[nextKey] = propValue;\r\n    }\r\n  }\r\n}\r\n\r\nexport function IsTemporalInstant(item: unknown): item is Temporal.Instant {\r\n  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\r\n}\r\n\r\nexport function IsTemporalDuration(item: unknown): item is Temporal.Duration {\r\n  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\r\n}\r\nexport function IsTemporalDate(item: unknown): item is Temporal.PlainDate {\r\n  return HasSlot(item, DATE_BRAND);\r\n}\r\n\r\nexport function IsTemporalTime(item: unknown): item is Temporal.PlainTime {\r\n  return HasSlot(item, TIME);\r\n}\r\n\r\nexport function IsTemporalDateTime(item: unknown): item is Temporal.PlainDateTime {\r\n  return HasSlot(item, ISO_DATE_TIME);\r\n}\r\n\r\nexport function IsTemporalYearMonth(item: unknown): item is Temporal.PlainYearMonth {\r\n  return HasSlot(item, YEAR_MONTH_BRAND);\r\n}\r\nexport function IsTemporalMonthDay(item: unknown): item is Temporal.PlainMonthDay {\r\n  return HasSlot(item, MONTH_DAY_BRAND);\r\n}\r\nexport function IsTemporalZonedDateTime(item: unknown): item is Temporal.ZonedDateTime {\r\n  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\r\n}\r\n\r\nexport function CheckReceiver<T extends AnySlottedType>(\r\n  item: unknown,\r\n  test: (item: unknown) => item is T\r\n): asserts item is T {\r\n  if (!test(item)) throw new TypeError('invalid receiver: method called with the wrong type of this-object');\r\n}\r\n\r\nexport function RejectTemporalLikeObject(item: AnyTemporalLikeType) {\r\n  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\r\n    throw new TypeError('with() does not support a calendar or timeZone property');\r\n  }\r\n  if (IsTemporalTime(item)) {\r\n    throw new TypeError('with() does not accept Temporal.PlainTime, use withPlainTime() instead');\r\n  }\r\n  if ((item as { calendar: unknown }).calendar !== undefined) {\r\n    throw new TypeError('with() does not support a calendar property');\r\n  }\r\n  if ((item as { timeZone: unknown }).timeZone !== undefined) {\r\n    throw new TypeError('with() does not support a timeZone property');\r\n  }\r\n}\r\n\r\nfunction FormatCalendarAnnotation(id: BuiltinCalendarId, showCalendar: Temporal.ShowCalendarOption['calendarName']) {\r\n  if (showCalendar === 'never') return '';\r\n  if (showCalendar === 'auto' && id === 'iso8601') return '';\r\n  const flag = showCalendar === 'critical' ? '!' : '';\r\n  return `[${flag}u-ca=${id}]`;\r\n}\r\n\r\n// Not a separate abstract operation in the spec, because it only occurs in one\r\n// place: ParseISODateTime. In the code it's more convenient to split up\r\n// ParseISODateTime for the YYYY-MM, MM-DD, and THH:MM:SS parse goals, so it's\r\n// repeated four times.\r\nfunction processAnnotations(annotations: string) {\r\n  let calendar;\r\n  let calendarWasCritical = false;\r\n  // Avoid the user code minefield of matchAll.\r\n  let match;\r\n  PARSE.annotation.lastIndex = 0;\r\n  while ((match = PARSE.annotation.exec(annotations))) {\r\n    const { 1: critical, 2: key, 3: value } = match;\r\n    if (key === 'u-ca') {\r\n      if (calendar === undefined) {\r\n        calendar = value;\r\n        calendarWasCritical = critical === '!';\r\n      } else if (critical === '!' || calendarWasCritical) {\r\n        throw new RangeError(`Invalid annotations in ${annotations}: more than one u-ca present with critical flag`);\r\n      }\r\n    } else if (critical === '!') {\r\n      throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\r\n    }\r\n  }\r\n  return calendar;\r\n}\r\n\r\nfunction ParseISODateTime(isoString: string) {\r\n  // ZDT is the superset of fields for every other Temporal type\r\n  const match = PARSE.zoneddatetime.exec(isoString);\r\n  if (!match) throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\r\n  const calendar = processAnnotations(match[16]);\r\n  let yearString = match[1];\r\n  if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\r\n  const year = +yearString;\r\n  const month = +(match[2] ?? match[4] ?? 1);\r\n  const day = +(match[3] ?? match[5] ?? 1);\r\n  const hasTime = match[6] !== undefined;\r\n  const hour = +(match[6] ?? 0);\r\n  const minute = +(match[7] ?? match[10] ?? 0);\r\n  let second = +(match[8] ?? match[11] ?? 0);\r\n  if (second === 60) second = 59;\r\n  const fraction = (match[9] ?? match[12] ?? '') + '000000000';\r\n  const millisecond = +fraction.slice(0, 3);\r\n  const microsecond = +fraction.slice(3, 6);\r\n  const nanosecond = +fraction.slice(6, 9);\r\n  let offset;\r\n  let z = false;\r\n  if (match[13]) {\r\n    offset = undefined;\r\n    z = true;\r\n  } else if (match[14]) {\r\n    offset = match[14];\r\n  }\r\n  const tzAnnotation = match[15];\r\n  RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\r\n  return {\r\n    year,\r\n    month,\r\n    day,\r\n    time: hasTime ? { hour, minute, second, millisecond, microsecond, nanosecond } : ('start-of-day' as const),\r\n    tzAnnotation,\r\n    offset,\r\n    z,\r\n    calendar\r\n  };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalInstantString(isoString: string) {\r\n  const result = ParseISODateTime(isoString);\r\n  if (!result.z && !result.offset) throw new RangeError('Temporal.Instant requires a time zone offset');\r\n  return result;\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalZonedDateTimeString(isoString: string) {\r\n  const result = ParseISODateTime(isoString);\r\n  if (!result.tzAnnotation) throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\r\n  return result;\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalDateTimeString(isoString: string) {\r\n  return ParseISODateTime(isoString);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalDateString(isoString: string) {\r\n  return ParseISODateTime(isoString);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalTimeString(isoString: string) {\r\n  const match = PARSE.time.exec(isoString);\r\n  let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\r\n  if (match) {\r\n    calendar = processAnnotations(match[10]);\r\n    hour = +(match[1] ?? 0);\r\n    minute = +(match[2] ?? match[5] ?? 0);\r\n    second = +(match[3] ?? match[6] ?? 0);\r\n    if (second === 60) second = 59;\r\n    const fraction = (match[4] ?? match[7] ?? '') + '000000000';\r\n    millisecond = +fraction.slice(0, 3);\r\n    microsecond = +fraction.slice(3, 6);\r\n    nanosecond = +fraction.slice(6, 9);\r\n    if (match[8]) throw new RangeError('Z designator not supported for PlainTime');\r\n  } else {\r\n    let time, z;\r\n    ({ time, z, calendar } = ParseISODateTime(isoString));\r\n    if (time === 'start-of-day') throw new RangeError(`time is missing in string: ${isoString}`);\r\n    if (z) throw new RangeError('Z designator not supported for PlainTime');\r\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = time);\r\n  }\r\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n  // if it's a date-time string, OK\r\n  if (/[tT ][0-9][0-9]/.test(isoString)) {\r\n    return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\r\n  }\r\n  try {\r\n    const { month, day } = ParseTemporalMonthDayString(isoString);\r\n    RejectISODate(1972, month, day);\r\n  } catch {\r\n    try {\r\n      const { year, month } = ParseTemporalYearMonthString(isoString);\r\n      RejectISODate(year, month, 1);\r\n    } catch {\r\n      return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\r\n    }\r\n  }\r\n  throw new RangeError(`invalid RFC 9557 time-only string ${isoString}; may need a T prefix`);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalYearMonthString(isoString: string) {\r\n  const match = PARSE.yearmonth.exec(isoString);\r\n  let year, month, calendar, referenceISODay;\r\n  if (match) {\r\n    calendar = processAnnotations(match[3]);\r\n    let yearString = match[1];\r\n    if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\r\n    year = +yearString;\r\n    month = +match[2];\r\n    referenceISODay = 1;\r\n    if (calendar !== undefined && calendar !== 'iso8601') {\r\n      throw new RangeError('YYYY-MM format is only valid with iso8601 calendar');\r\n    }\r\n  } else {\r\n    let z;\r\n    ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\r\n    if (z) throw new RangeError('Z designator not supported for PlainYearMonth');\r\n  }\r\n  return { year, month, calendar, referenceISODay };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalMonthDayString(isoString: string) {\r\n  const match = PARSE.monthday.exec(isoString);\r\n  let month, day, calendar, referenceISOYear;\r\n  if (match) {\r\n    calendar = processAnnotations(match[3]);\r\n    month = +match[1];\r\n    day = +match[2];\r\n    if (calendar !== undefined && calendar !== 'iso8601') {\r\n      throw new RangeError('MM-DD format is only valid with iso8601 calendar');\r\n    }\r\n  } else {\r\n    let z;\r\n    ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\r\n    if (z) throw new RangeError('Z designator not supported for PlainMonthDay');\r\n  }\r\n  return { month, day, calendar, referenceISOYear };\r\n}\r\n\r\nconst TIMEZONE_IDENTIFIER = new RegExp(`^${PARSE.timeZoneID.source}$`, 'i');\r\nconst OFFSET_IDENTIFIER = new RegExp(`^${PARSE.offsetIdentifier.source}$`);\r\n\r\nfunction throwBadTimeZoneStringError(timeZoneString: string): never {\r\n  // Offset identifiers only support minute precision, but offsets in ISO\r\n  // strings support nanosecond precision. If the identifier is invalid but\r\n  // it's a valid ISO offset, then it has sub-minute precision. Show a clearer\r\n  // error message in that case.\r\n  const msg = OFFSET.test(timeZoneString) ? 'Seconds not allowed in offset time zone' : 'Invalid time zone';\r\n  throw new RangeError(`${msg}: ${timeZoneString}`);\r\n}\r\n\r\nexport function ParseTimeZoneIdentifier(\r\n  identifier: string\r\n): { tzName: string; offsetMinutes?: undefined } | { tzName?: undefined; offsetMinutes: number } {\r\n  if (!TIMEZONE_IDENTIFIER.test(identifier)) {\r\n    throwBadTimeZoneStringError(identifier);\r\n  }\r\n  if (OFFSET_IDENTIFIER.test(identifier)) {\r\n    const offsetNanoseconds = ParseDateTimeUTCOffset(identifier);\r\n    // The regex limits the input to minutes precision, so we know that the\r\n    // division below will result in an integer.\r\n    return { offsetMinutes: offsetNanoseconds / 60e9 };\r\n  }\r\n  return { tzName: identifier };\r\n}\r\n\r\n// This operation doesn't exist in the spec, but in the polyfill it's split from\r\n// ParseTemporalTimeZoneString so that parsing can be tested separately from the\r\n// logic of converting parsed values into a named or offset identifier.\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalTimeZoneStringRaw(timeZoneString: string): {\r\n  tzAnnotation: string;\r\n  offset: string | undefined;\r\n  z: boolean;\r\n} {\r\n  if (TIMEZONE_IDENTIFIER.test(timeZoneString)) {\r\n    return { tzAnnotation: timeZoneString, offset: undefined, z: false };\r\n  }\r\n  try {\r\n    // Try parsing ISO string instead\r\n    const { tzAnnotation, offset, z } = ParseISODateTime(timeZoneString);\r\n    if (z || tzAnnotation || offset) {\r\n      return { tzAnnotation, offset, z };\r\n    }\r\n  } catch {\r\n    // fall through\r\n  }\r\n  throwBadTimeZoneStringError(timeZoneString);\r\n}\r\n\r\nfunction ParseTemporalTimeZoneString(stringIdent: string): ReturnType<typeof ParseTimeZoneIdentifier> {\r\n  const { tzAnnotation, offset, z } = ParseTemporalTimeZoneStringRaw(stringIdent);\r\n  if (tzAnnotation) return ParseTimeZoneIdentifier(tzAnnotation);\r\n  if (z) return ParseTimeZoneIdentifier('UTC');\r\n  if (offset) return ParseTimeZoneIdentifier(offset);\r\n  /* c8 ignore next */ assertNotReached();\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\r\nexport function ParseTemporalDurationStringRaw(isoString: string) {\r\n  const match = PARSE.duration.exec(isoString);\r\n  if (!match) throw new RangeError(`invalid duration: ${isoString}`);\r\n  if (match.every((part, i) => i < 2 || part === undefined)) {\r\n    throw new RangeError(`invalid duration: ${isoString}`);\r\n  }\r\n  const sign = match[1] === '-' ? -1 : 1;\r\n  const years = match[2] === undefined ? 0 : ToIntegerWithTruncation(match[2]) * sign;\r\n  const months = match[3] === undefined ? 0 : ToIntegerWithTruncation(match[3]) * sign;\r\n  const weeks = match[4] === undefined ? 0 : ToIntegerWithTruncation(match[4]) * sign;\r\n  const days = match[5] === undefined ? 0 : ToIntegerWithTruncation(match[5]) * sign;\r\n  const hours = match[6] === undefined ? 0 : ToIntegerWithTruncation(match[6]) * sign;\r\n  const fHours = match[7];\r\n  const minutesStr = match[8];\r\n  const fMinutes = match[9];\r\n  const secondsStr = match[10];\r\n  const fSeconds = match[11];\r\n  let minutes = 0;\r\n  let seconds = 0;\r\n  // fractional hours, minutes, or seconds, expressed in whole nanoseconds:\r\n  let excessNanoseconds = 0;\r\n\r\n  if (fHours !== undefined) {\r\n    if (minutesStr ?? fMinutes ?? secondsStr ?? fSeconds ?? false) {\r\n      throw new RangeError('only the smallest unit can be fractional');\r\n    }\r\n    excessNanoseconds = ToIntegerWithTruncation((fHours + '000000000').slice(0, 9)) * 3600 * sign;\r\n  } else {\r\n    minutes = minutesStr === undefined ? 0 : ToIntegerWithTruncation(minutesStr) * sign;\r\n    if (fMinutes !== undefined) {\r\n      if (secondsStr ?? fSeconds ?? false) {\r\n        throw new RangeError('only the smallest unit can be fractional');\r\n      }\r\n      excessNanoseconds = ToIntegerWithTruncation((fMinutes + '000000000').slice(0, 9)) * 60 * sign;\r\n    } else {\r\n      seconds = secondsStr === undefined ? 0 : ToIntegerWithTruncation(secondsStr) * sign;\r\n      if (fSeconds !== undefined) {\r\n        excessNanoseconds = ToIntegerWithTruncation((fSeconds + '000000000').slice(0, 9)) * sign;\r\n      }\r\n    }\r\n  }\r\n\r\n  const nanoseconds = excessNanoseconds % 1000;\r\n  const microseconds = Math.trunc(excessNanoseconds / 1000) % 1000;\r\n  const milliseconds = Math.trunc(excessNanoseconds / 1e6) % 1000;\r\n  seconds += Math.trunc(excessNanoseconds / 1e9) % 60;\r\n  minutes += Math.trunc(excessNanoseconds / 60e9);\r\n\r\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\r\n}\r\n\r\nfunction ParseTemporalDurationString(isoString: string) {\r\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\r\n    ParseTemporalDurationStringRaw(isoString);\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  return new TemporalDuration(\r\n    years,\r\n    months,\r\n    weeks,\r\n    days,\r\n    hours,\r\n    minutes,\r\n    seconds,\r\n    milliseconds,\r\n    microseconds,\r\n    nanoseconds\r\n  );\r\n}\r\n\r\nexport function RegulateISODate(yearParam: number, monthParam: number, dayParam: number, overflow: Overflow) {\r\n  let year = yearParam;\r\n  let month = monthParam;\r\n  let day = dayParam;\r\n  switch (overflow) {\r\n    case 'reject':\r\n      RejectISODate(year, month, day);\r\n      break;\r\n    case 'constrain':\r\n      ({ year, month, day } = ConstrainISODate(year, month, day));\r\n      break;\r\n  }\r\n  return { year, month, day };\r\n}\r\n\r\nexport function RegulateTime(\r\n  hourParam: number,\r\n  minuteParam: number,\r\n  secondParam: number,\r\n  millisecondParam: number,\r\n  microsecondParam: number,\r\n  nanosecondParam: number,\r\n  overflow: Overflow\r\n) {\r\n  let hour = hourParam;\r\n  let minute = minuteParam;\r\n  let second = secondParam;\r\n  let millisecond = millisecondParam;\r\n  let microsecond = microsecondParam;\r\n  let nanosecond = nanosecondParam;\r\n\r\n  switch (overflow) {\r\n    case 'reject':\r\n      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n      break;\r\n    case 'constrain':\r\n      hour = ConstrainToRange(hour, 0, 23);\r\n      minute = ConstrainToRange(minute, 0, 59);\r\n      second = ConstrainToRange(second, 0, 59);\r\n      millisecond = ConstrainToRange(millisecond, 0, 999);\r\n      microsecond = ConstrainToRange(microsecond, 0, 999);\r\n      nanosecond = ConstrainToRange(nanosecond, 0, 999);\r\n      break;\r\n  }\r\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\r\n}\r\n\r\nexport function ToTemporalPartialDurationRecord(temporalDurationLike: Temporal.DurationLike | string) {\r\n  if (!IsObject(temporalDurationLike)) {\r\n    throw new TypeError('invalid duration-like');\r\n  }\r\n  const result: Record<(typeof DURATION_FIELDS)[number], number | undefined> = {\r\n    years: undefined,\r\n    months: undefined,\r\n    weeks: undefined,\r\n    days: undefined,\r\n    hours: undefined,\r\n    minutes: undefined,\r\n    seconds: undefined,\r\n    milliseconds: undefined,\r\n    microseconds: undefined,\r\n    nanoseconds: undefined\r\n  };\r\n  let any = false;\r\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\r\n    const property = DURATION_FIELDS[index];\r\n    const value = temporalDurationLike[property];\r\n    if (value !== undefined) {\r\n      any = true;\r\n      result[property] = ToIntegerIfIntegral(value);\r\n    }\r\n  }\r\n  if (!any) {\r\n    throw new TypeError('invalid duration-like');\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function AdjustDateDurationRecord(\r\n  { years, months, weeks, days }: DateDuration,\r\n  newDays: number,\r\n  newWeeks?: number,\r\n  newMonths?: number\r\n) {\r\n  return {\r\n    years,\r\n    months: newMonths ?? months,\r\n    weeks: newWeeks ?? weeks,\r\n    days: newDays ?? days\r\n  };\r\n}\r\n\r\nexport function ZeroDateDuration() {\r\n  return { years: 0, months: 0, weeks: 0, days: 0 };\r\n}\r\n\r\nexport function CombineISODateAndTimeRecord(isoDate: ISODate, time: TimeRecord) {\r\n  return { isoDate, time };\r\n}\r\n\r\nexport function MidnightTimeRecord() {\r\n  return { deltaDays: 0, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\r\n}\r\n\r\nexport function NoonTimeRecord() {\r\n  return { deltaDays: 0, hour: 12, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\r\n}\r\n\r\nexport function GetTemporalOverflowOption(options: Temporal.AssignmentOptions) {\r\n  return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\r\n}\r\n\r\nexport function GetTemporalDisambiguationOption(options: Temporal.ToInstantOptions) {\r\n  return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\r\n}\r\n\r\nexport function GetRoundingModeOption(\r\n  options: { roundingMode?: Temporal.RoundingMode },\r\n  fallback: Temporal.RoundingMode\r\n) {\r\n  return GetOption(\r\n    options,\r\n    'roundingMode',\r\n    ['ceil', 'floor', 'expand', 'trunc', 'halfCeil', 'halfFloor', 'halfExpand', 'halfTrunc', 'halfEven'],\r\n    fallback\r\n  );\r\n}\r\n\r\nfunction NegateRoundingMode(roundingMode: Temporal.RoundingMode) {\r\n  switch (roundingMode) {\r\n    case 'ceil':\r\n      return 'floor';\r\n    case 'floor':\r\n      return 'ceil';\r\n    case 'halfCeil':\r\n      return 'halfFloor';\r\n    case 'halfFloor':\r\n      return 'halfCeil';\r\n    default:\r\n      return roundingMode;\r\n  }\r\n}\r\n\r\nexport function GetTemporalOffsetOption(\r\n  options: Temporal.OffsetDisambiguationOptions,\r\n  fallback: Required<Temporal.OffsetDisambiguationOptions>['offset']\r\n) {\r\n  return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\r\n}\r\n\r\nexport function GetTemporalShowCalendarNameOption(options: Temporal.ShowCalendarOption) {\r\n  return GetOption(options, 'calendarName', ['auto', 'always', 'never', 'critical'], 'auto');\r\n}\r\n\r\nexport function GetTemporalShowTimeZoneNameOption(options: Temporal.ZonedDateTimeToStringOptions) {\r\n  return GetOption(options, 'timeZoneName', ['auto', 'never', 'critical'], 'auto');\r\n}\r\n\r\nexport function GetTemporalShowOffsetOption(options: Temporal.ZonedDateTimeToStringOptions) {\r\n  return GetOption(options, 'offset', ['auto', 'never'], 'auto');\r\n}\r\n\r\nexport function GetDirectionOption(options: { direction?: 'next' | 'previous' }) {\r\n  return GetOption(options, 'direction', ['next', 'previous'], REQUIRED);\r\n}\r\n\r\nexport function GetTemporalRoundingIncrementOption(options: { roundingIncrement?: number }) {\r\n  let increment = options.roundingIncrement;\r\n  if (increment === undefined) return 1;\r\n  const integerIncrement = ToIntegerWithTruncation(increment);\r\n  if (integerIncrement < 1 || integerIncrement > 1e9) {\r\n    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${increment}`);\r\n  }\r\n  return integerIncrement;\r\n}\r\nexport function ValidateTemporalRoundingIncrement(increment: number, dividend: number, inclusive: boolean) {\r\n  const maximum = inclusive ? dividend : dividend - 1;\r\n  if (increment > maximum) {\r\n    throw new RangeError(`roundingIncrement must be at least 1 and less than ${maximum}, not ${increment}`);\r\n  }\r\n  if (dividend % increment !== 0) {\r\n    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\r\n  }\r\n}\r\n\r\nexport function GetTemporalFractionalSecondDigitsOption(\r\n  normalizedOptions: Temporal.ToStringPrecisionOptions\r\n): Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] {\r\n  const digitsValue = normalizedOptions.fractionalSecondDigits;\r\n  if (digitsValue === undefined) return 'auto';\r\n  if (typeof digitsValue !== 'number') {\r\n    if (ToString(digitsValue) !== 'auto') {\r\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\r\n    }\r\n    return 'auto';\r\n  }\r\n  const digitCount = Math.floor(digitsValue);\r\n  if (!Number.isFinite(digitCount) || digitCount < 0 || digitCount > 9) {\r\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\r\n  }\r\n  return digitCount as Exclude<Temporal.ToStringPrecisionOptions['fractionalSecondDigits'], 'auto'>;\r\n}\r\n\r\ninterface SecondsStringPrecisionRecord {\r\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] | 'minute';\r\n  unit: UnitSmallerThanOrEqualTo<'minute'>;\r\n  increment: number;\r\n}\r\n\r\nexport function ToSecondsStringPrecisionRecord(\r\n  smallestUnit: Temporal.ToStringPrecisionOptions['smallestUnit'],\r\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits']\r\n): SecondsStringPrecisionRecord {\r\n  switch (smallestUnit) {\r\n    case 'minute':\r\n      return { precision: 'minute', unit: 'minute', increment: 1 };\r\n    case 'second':\r\n      return { precision: 0, unit: 'second', increment: 1 };\r\n    case 'millisecond':\r\n      return { precision: 3, unit: 'millisecond', increment: 1 };\r\n    case 'microsecond':\r\n      return { precision: 6, unit: 'microsecond', increment: 1 };\r\n    case 'nanosecond':\r\n      return { precision: 9, unit: 'nanosecond', increment: 1 };\r\n    default: // fall through if option not given\r\n  }\r\n  switch (precision) {\r\n    case 'auto':\r\n      return { precision, unit: 'nanosecond', increment: 1 };\r\n    case 0:\r\n      return { precision, unit: 'second', increment: 1 };\r\n    case 1:\r\n    case 2:\r\n    case 3:\r\n      return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\r\n    case 4:\r\n    case 5:\r\n    case 6:\r\n      return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\r\n    case 7:\r\n    case 8:\r\n    case 9:\r\n      return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\r\n    default:\r\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${precision}`);\r\n  }\r\n}\r\n\r\nexport const REQUIRED = Symbol('~required~');\r\n\r\ninterface TemporalUnitOptionsBag {\r\n  smallestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\r\n  largestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit | 'auto';\r\n  unit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\r\n}\r\ntype UnitTypeMapping = {\r\n  date: Temporal.DateUnit;\r\n  time: Temporal.TimeUnit;\r\n  datetime: Temporal.DateTimeUnit;\r\n};\r\n// This type specifies the allowed defaults for each unit key type.\r\ntype AllowedGetTemporalUnitDefaultValues = {\r\n  smallestUnit: undefined;\r\n  largestUnit: 'auto' | undefined;\r\n  unit: undefined;\r\n};\r\n\r\nexport function GetTemporalUnitValuedOption<\r\n  U extends keyof TemporalUnitOptionsBag,\r\n  T extends keyof UnitTypeMapping,\r\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\r\n  R extends Exclude<D, typeof REQUIRED> | UnitTypeMapping[T]\r\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D): R;\r\nexport function GetTemporalUnitValuedOption<\r\n  U extends keyof TemporalUnitOptionsBag,\r\n  T extends keyof UnitTypeMapping,\r\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\r\n  E extends 'auto' | Temporal.DateTimeUnit,\r\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\r\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D, extraValues: ReadonlyArray<E>): R;\r\n// This signature of the function is NOT used in type-checking, so restricting\r\n// the default value via generic binding like the other overloads isn't\r\n// necessary.\r\nexport function GetTemporalUnitValuedOption<\r\n  T extends keyof UnitTypeMapping,\r\n  D extends typeof REQUIRED | UnitTypeMapping[T] | 'auto' | undefined,\r\n  E extends 'auto' | Temporal.DateTimeUnit,\r\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\r\n>(\r\n  options: TemporalUnitOptionsBag,\r\n  key: keyof typeof options,\r\n  unitGroup: T,\r\n  requiredOrDefault: D,\r\n  extraValues: ReadonlyArray<E> | never[] = []\r\n): R {\r\n  let allowedSingular: Array<Temporal.DateTimeUnit | 'auto'> = [];\r\n  for (let index = 0; index < TEMPORAL_UNITS.length; index++) {\r\n    const unitInfo = TEMPORAL_UNITS[index];\r\n    const singular = unitInfo[1];\r\n    const category = unitInfo[2];\r\n    if (unitGroup === 'datetime' || unitGroup === category) {\r\n      allowedSingular.push(singular);\r\n    }\r\n  }\r\n  allowedSingular = allowedSingular.concat(extraValues);\r\n  let defaultVal: typeof REQUIRED | Temporal.DateTimeUnit | 'auto' | undefined = requiredOrDefault;\r\n  if (defaultVal === REQUIRED) {\r\n    defaultVal = undefined;\r\n  } else if (defaultVal !== undefined) {\r\n    allowedSingular.push(defaultVal);\r\n  }\r\n  let allowedValues: Array<Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit> | 'auto'> = [];\r\n  allowedValues = allowedValues.concat(allowedSingular);\r\n  for (let index = 0; index < allowedSingular.length; index++) {\r\n    const singular = allowedSingular[index];\r\n    const plural = PLURAL_FOR[singular];\r\n    if (plural !== undefined) allowedValues.push(plural);\r\n  }\r\n  let retval = GetOption(options, key, allowedValues, defaultVal);\r\n  if (retval === undefined && requiredOrDefault === REQUIRED) {\r\n    throw new RangeError(`${key} is required`);\r\n  }\r\n  // Coerce any plural units into their singular form\r\n  return (retval && retval in SINGULAR_FOR ? SINGULAR_FOR[retval] : retval) as R;\r\n}\r\n\r\nexport function GetTemporalRelativeToOption(options: {\r\n  relativeTo?:\r\n    | Temporal.ZonedDateTime\r\n    | Temporal.PlainDateTime\r\n    | Temporal.ZonedDateTimeLike\r\n    | Temporal.PlainDateTimeLike\r\n    | string\r\n    | undefined;\r\n}):\r\n  | { zonedRelativeTo?: Temporal.ZonedDateTime; plainRelativeTo?: never }\r\n  | { plainRelativeTo?: Temporal.PlainDate; zonedRelativeTo?: never } {\r\n  const relativeTo = options.relativeTo;\r\n  if (relativeTo === undefined) return {};\r\n\r\n  let offsetBehaviour: OffsetBehaviour = 'option';\r\n  let matchMinutes = false;\r\n  let isoDate, time, calendar, timeZone, offset;\r\n  if (IsObject(relativeTo)) {\r\n    if (IsTemporalZonedDateTime(relativeTo)) {\r\n      return { zonedRelativeTo: relativeTo };\r\n    }\r\n    if (IsTemporalDate(relativeTo)) return { plainRelativeTo: relativeTo };\r\n    if (IsTemporalDateTime(relativeTo)) {\r\n      return {\r\n        plainRelativeTo: CreateTemporalDate(GetSlot(relativeTo, ISO_DATE_TIME).isoDate, GetSlot(relativeTo, CALENDAR))\r\n      };\r\n    }\r\n    calendar = GetTemporalCalendarIdentifierWithISODefault(relativeTo);\r\n    const fields = PrepareCalendarFields(\r\n      calendar,\r\n      relativeTo,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\r\n      []\r\n    );\r\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, 'constrain'));\r\n    ({ offset, timeZone } = fields);\r\n    if (offset === undefined) offsetBehaviour = 'wall';\r\n  } else {\r\n    let tzAnnotation, z, year, month, day;\r\n    ({ year, month, day, time, calendar, tzAnnotation, offset, z } = ParseISODateTime(RequireString(relativeTo)));\r\n    if (tzAnnotation) {\r\n      timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\r\n      if (z) {\r\n        offsetBehaviour = 'exact';\r\n      } else if (!offset) {\r\n        offsetBehaviour = 'wall';\r\n      }\r\n      matchMinutes = true;\r\n    } else if (z) {\r\n      throw new RangeError(\r\n        'Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone'\r\n      );\r\n    }\r\n    if (!calendar) calendar = 'iso8601';\r\n    calendar = CanonicalizeCalendar(calendar);\r\n    isoDate = { year, month, day };\r\n  }\r\n  if (timeZone === undefined) {\r\n    return { plainRelativeTo: CreateTemporalDate(isoDate, calendar) };\r\n  }\r\n  const offsetNs = offsetBehaviour === 'option' ? ParseDateTimeUTCOffset(castExists(offset)) : 0;\r\n  const epochNanoseconds = InterpretISODateTimeOffset(\r\n    isoDate,\r\n    time,\r\n    offsetBehaviour,\r\n    offsetNs,\r\n    timeZone,\r\n    'compatible',\r\n    'reject',\r\n    matchMinutes\r\n  );\r\n  return { zonedRelativeTo: CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar) };\r\n}\r\n\r\nexport function DefaultTemporalLargestUnit(duration: Temporal.Duration) {\r\n  if (GetSlot(duration, YEARS) !== 0) return 'year';\r\n  if (GetSlot(duration, MONTHS) !== 0) return 'month';\r\n  if (GetSlot(duration, WEEKS) !== 0) return 'week';\r\n  if (GetSlot(duration, DAYS) !== 0) return 'day';\r\n  if (GetSlot(duration, HOURS) !== 0) return 'hour';\r\n  if (GetSlot(duration, MINUTES) !== 0) return 'minute';\r\n  if (GetSlot(duration, SECONDS) !== 0) return 'second';\r\n  if (GetSlot(duration, MILLISECONDS) !== 0) return 'millisecond';\r\n  if (GetSlot(duration, MICROSECONDS) !== 0) return 'microsecond';\r\n  return 'nanosecond';\r\n}\r\n\r\nexport function LargerOfTwoTemporalUnits<T1 extends Temporal.DateTimeUnit, T2 extends Temporal.DateTimeUnit>(\r\n  unit1: T1,\r\n  unit2: T2\r\n) {\r\n  const i1 = UNITS_DESCENDING.indexOf(unit1);\r\n  const i2 = UNITS_DESCENDING.indexOf(unit2);\r\n  if (i1 > i2) {\r\n    return unit2;\r\n  }\r\n  return unit1;\r\n}\r\n\r\nexport function IsCalendarUnit(unit: Temporal.DateTimeUnit): unit is Exclude<Temporal.DateUnit, 'day'> {\r\n  return unit === 'year' || unit === 'month' || unit === 'week';\r\n}\r\n\r\nexport function TemporalUnitCategory(unit: Temporal.DateTimeUnit) {\r\n  if (IsCalendarUnit(unit) || unit === 'day') return 'date';\r\n  return 'time';\r\n}\r\n\r\nfunction calendarImplForID(calendar: BuiltinCalendarId) {\r\n  return GetIntrinsic('%calendarImpl%')(calendar);\r\n}\r\n\r\nexport function calendarImplForObj(\r\n  temporalObj:\r\n    | Temporal.PlainDate\r\n    | Temporal.PlainDateTime\r\n    | Temporal.PlainMonthDay\r\n    | Temporal.PlainYearMonth\r\n    | Temporal.ZonedDateTime\r\n) {\r\n  return GetIntrinsic('%calendarImpl%')(GetSlot(temporalObj, CALENDAR));\r\n}\r\n\r\ntype ISODateToFieldsReturn<Type extends ISODateToFieldsType> = Resolve<{\r\n  year: Type extends 'date' | 'year-month' ? number : never;\r\n  monthCode: string;\r\n  day: Type extends 'date' | 'month-day' ? number : never;\r\n}>;\r\n\r\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate): ISODateToFieldsReturn<'date'>;\r\nexport function ISODateToFields<T extends ISODateToFieldsType>(\r\n  calendar: BuiltinCalendarId,\r\n  isoDate: ISODate,\r\n  type: T\r\n): ISODateToFieldsReturn<T>;\r\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate, type = 'date') {\r\n  const fields = Object.create(null);\r\n  const calendarImpl = calendarImplForID(calendar);\r\n  const calendarDate = calendarImpl.isoToDate(isoDate, { year: true, monthCode: true, day: true });\r\n\r\n  fields.monthCode = calendarDate.monthCode;\r\n  if (type === 'month-day' || type === 'date') {\r\n    fields.day = calendarDate.day;\r\n  }\r\n  if (type === 'year-month' || type === 'date') {\r\n    fields.year = calendarDate.year;\r\n  }\r\n  return fields;\r\n}\r\n\r\ntype Prop<T, K> = T extends unknown ? (K extends keyof T ? T[K] : undefined) : 'ThisShouldNeverHappen';\r\n\r\ntype FieldObjectWithRequired<FieldKeys extends FieldKey> = Resolve<\r\n  // The resulting object type contains:\r\n  // - All keys in FieldKeys, which are required properties and their values\r\n  //   don't include undefined.\r\n  // - All the other keys in CalendarFieldsRecord that aren't in FieldKeys,\r\n  //   which are optional properties and their value types explicitly include\r\n  //   undefined.\r\n  {\r\n    -readonly [k in FieldKeys]: Exclude<Prop<CalendarFieldsRecord, k>, undefined>;\r\n  } & {\r\n    -readonly [k in Exclude<Keys<CalendarFieldsRecord>, FieldKeys>]?: Prop<CalendarFieldsRecord, k> | undefined;\r\n  }\r\n>;\r\n\r\ntype PrepareCalendarFieldsReturn<\r\n  FieldKeys extends FieldKey,\r\n  RequiredFieldsOpt extends ReadonlyArray<FieldKey> | 'partial'\r\n> = RequiredFieldsOpt extends 'partial' ? Partial<CalendarFieldsRecord> : FieldObjectWithRequired<FieldKeys>;\r\n\r\nexport function PrepareCalendarFields<\r\n  FieldKeys extends FieldKey,\r\n  RequiredFields extends ReadonlyArray<FieldKey> | 'partial'\r\n>(\r\n  calendar: BuiltinCalendarId,\r\n  bag: Partial<Record<FieldKeys, unknown>>,\r\n  calendarFieldNames: Array<FieldKeys>,\r\n  nonCalendarFieldNames: Array<FieldKeys>,\r\n  requiredFields: RequiredFields\r\n): PrepareCalendarFieldsReturn<FieldKeys, RequiredFields> {\r\n  const extraFieldNames = calendarImplForID(calendar).extraFields(calendarFieldNames) as FieldKeys[];\r\n  const fields = calendarFieldNames.concat(nonCalendarFieldNames, extraFieldNames);\r\n  const result: Partial<Record<AnyTemporalKey, unknown>> = Object.create(null);\r\n  let any = false;\r\n  fields.sort();\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const property = fields[index];\r\n    const value = bag[property];\r\n    if (value !== undefined) {\r\n      any = true;\r\n      result[property] = castExists(BUILTIN_CASTS[property])(value);\r\n    } else if (requiredFields !== 'partial') {\r\n      if (requiredFields.includes(property)) {\r\n        throw new TypeError(`required property '${property}' missing or undefined`);\r\n      }\r\n      result[property] = BUILTIN_DEFAULTS[property];\r\n    }\r\n  }\r\n  if (requiredFields === 'partial' && !any) {\r\n    throw new TypeError('no supported properties found');\r\n  }\r\n  return result as unknown as PrepareCalendarFieldsReturn<FieldKeys, RequiredFields>;\r\n}\r\n\r\ntype FieldCompleteness = 'complete' | 'partial';\r\n\r\nexport function ToTemporalTimeRecord(bag: Partial<Record<keyof TimeRecord, string | number>>): TimeRecord;\r\nexport function ToTemporalTimeRecord(\r\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\r\n  completeness: 'partial'\r\n): Partial<TimeRecord>;\r\nexport function ToTemporalTimeRecord(\r\n  bag: Partial<Record<keyof TimeRecord, string | number>>,\r\n  completeness: 'complete'\r\n): TimeRecord;\r\nexport function ToTemporalTimeRecord(\r\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\r\n  completeness: FieldCompleteness = 'complete'\r\n): Partial<TimeRecord> {\r\n  // NOTE: Field order is sorted to make the sort in PrepareTemporalFields more efficient.\r\n  const fields: (keyof TimeRecord)[] = ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second'];\r\n  let any = false;\r\n  const result: Partial<TimeRecord> = Object.create(null);\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const field = fields[index];\r\n    const value = bag[field];\r\n    if (value !== undefined) {\r\n      result[field] = ToIntegerWithTruncation(value);\r\n      any = true;\r\n    } else if (completeness === 'complete') {\r\n      result[field] = 0;\r\n    }\r\n  }\r\n  if (!any) throw new TypeError('invalid time-like');\r\n  return result;\r\n}\r\n\r\nexport function ToTemporalDate(\r\n  item: PlainDateParams['from'][0],\r\n  options?: PlainDateParams['from'][1]\r\n): Temporal.PlainDate {\r\n  if (IsObject(item)) {\r\n    if (IsTemporalDate(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDate(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\r\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\r\n      const isoDate = isoDateTime.isoDate;\r\n      return CreateTemporalDate(isoDate, GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalDateTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\r\n      return CreateTemporalDate(GetSlot(item, ISO_DATE_TIME).isoDate, GetSlot(item, CALENDAR));\r\n    }\r\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    const isoDate = CalendarDateFromFields(calendar, fields, overflow);\r\n    return CreateTemporalDate(isoDate, calendar);\r\n  }\r\n  let { year, month, day, calendar, z } = ParseTemporalDateString(RequireString(item));\r\n  if (z) throw new RangeError('Z designator not supported for PlainDate');\r\n  if (!calendar) calendar = 'iso8601';\r\n  calendar = CanonicalizeCalendar(calendar);\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\r\n  GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\r\n  return CreateTemporalDate({ year, month, day }, calendar);\r\n}\r\n\r\nexport function InterpretTemporalDateTimeFields(\r\n  calendar: BuiltinCalendarId,\r\n  fields: CalendarFieldsRecord & TimeRecord,\r\n  overflow: Overflow\r\n) {\r\n  const isoDate = CalendarDateFromFields(calendar, fields, overflow);\r\n  const time = RegulateTime(\r\n    fields.hour,\r\n    fields.minute,\r\n    fields.second,\r\n    fields.millisecond,\r\n    fields.microsecond,\r\n    fields.nanosecond,\r\n    overflow\r\n  );\r\n  return CombineISODateAndTimeRecord(isoDate, time);\r\n}\r\n\r\nexport function ToTemporalDateTime(item: PlainDateTimeParams['from'][0], options?: PlainDateTimeParams['from'][1]) {\r\n  let isoDate, time, calendar;\r\n\r\n  if (IsObject(item)) {\r\n    if (IsTemporalDateTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDateTime(GetSlot(item, ISO_DATE_TIME), GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDateTime(isoDateTime, GetSlot(item, CALENDAR));\r\n    }\r\n    if (IsTemporalDate(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalDateTime(\r\n        CombineISODateAndTimeRecord(GetSlot(item, ISO_DATE), MidnightTimeRecord()),\r\n        GetSlot(item, CALENDAR)\r\n      );\r\n    }\r\n\r\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(\r\n      calendar,\r\n      item,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\r\n      []\r\n    );\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\r\n  } else {\r\n    let z, year, month, day;\r\n    ({ year, month, day, time, calendar, z } = ParseTemporalDateTimeString(RequireString(item)));\r\n    if (z) throw new RangeError('Z designator not supported for PlainDateTime');\r\n    if (time === 'start-of-day') time = MidnightTimeRecord();\r\n    RejectDateTime(\r\n      year,\r\n      month,\r\n      day,\r\n      time.hour,\r\n      time.minute,\r\n      time.second,\r\n      time.millisecond,\r\n      time.microsecond,\r\n      time.nanosecond\r\n    );\r\n    if (!calendar) calendar = 'iso8601';\r\n    calendar = CanonicalizeCalendar(calendar);\r\n    GetTemporalOverflowOption(GetOptionsObject(options));\r\n    isoDate = { year, month, day };\r\n  }\r\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, time);\r\n  return CreateTemporalDateTime(isoDateTime, calendar);\r\n}\r\n\r\nexport function ToTemporalDuration(item: DurationParams['from'][0]) {\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  if (IsTemporalDuration(item)) {\r\n    return new TemporalDuration(\r\n      GetSlot(item, YEARS),\r\n      GetSlot(item, MONTHS),\r\n      GetSlot(item, WEEKS),\r\n      GetSlot(item, DAYS),\r\n      GetSlot(item, HOURS),\r\n      GetSlot(item, MINUTES),\r\n      GetSlot(item, SECONDS),\r\n      GetSlot(item, MILLISECONDS),\r\n      GetSlot(item, MICROSECONDS),\r\n      GetSlot(item, NANOSECONDS)\r\n    );\r\n  }\r\n  if (!IsObject(item)) {\r\n    return ParseTemporalDurationString(RequireString(item));\r\n  }\r\n  const result = {\r\n    years: 0,\r\n    months: 0,\r\n    weeks: 0,\r\n    days: 0,\r\n    hours: 0,\r\n    minutes: 0,\r\n    seconds: 0,\r\n    milliseconds: 0,\r\n    microseconds: 0,\r\n    nanoseconds: 0\r\n  };\r\n  let partial = ToTemporalPartialDurationRecord(item);\r\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\r\n    const property = DURATION_FIELDS[index];\r\n    const value = partial[property];\r\n    if (value !== undefined) {\r\n      result[property] = value;\r\n    }\r\n  }\r\n  return new TemporalDuration(\r\n    result.years,\r\n    result.months,\r\n    result.weeks,\r\n    result.days,\r\n    result.hours,\r\n    result.minutes,\r\n    result.seconds,\r\n    result.milliseconds,\r\n    result.microseconds,\r\n    result.nanoseconds\r\n  );\r\n}\r\n\r\nexport function ToTemporalInstant(itemParam: InstantParams['from'][0]) {\r\n  let item: string | number;\r\n  if (IsObject(itemParam)) {\r\n    if (IsTemporalInstant(itemParam) || IsTemporalZonedDateTime(itemParam)) {\r\n      return CreateTemporalInstant(GetSlot(itemParam, EPOCHNANOSECONDS));\r\n    }\r\n    item = ToPrimitive(itemParam, String);\r\n  } else {\r\n    item = itemParam;\r\n  }\r\n  const { year, month, day, time, offset, z } = ParseTemporalInstantString(RequireString(item));\r\n  const {\r\n    hour = 0,\r\n    minute = 0,\r\n    second = 0,\r\n    millisecond = 0,\r\n    microsecond = 0,\r\n    nanosecond = 0\r\n  } = time === 'start-of-day' ? {} : time;\r\n\r\n  // ParseTemporalInstantString ensures that either `z` is true or or `offset` is non-undefined\r\n  const offsetNanoseconds = z ? 0 : ParseDateTimeUTCOffset(castExists(offset));\r\n  const balanced = BalanceISODateTime(\r\n    year,\r\n    month,\r\n    day,\r\n    hour,\r\n    minute,\r\n    second,\r\n    millisecond,\r\n    microsecond,\r\n    nanosecond - offsetNanoseconds\r\n  );\r\n  CheckISODaysRange(balanced.isoDate);\r\n  const epochNanoseconds = GetUTCEpochNanoseconds(balanced);\r\n  return CreateTemporalInstant(epochNanoseconds);\r\n}\r\n\r\nexport function ToTemporalMonthDay(item: PlainMonthDayParams['from'][0], options?: PlainMonthDayParams['from'][1]) {\r\n  if (IsObject(item)) {\r\n    if (IsTemporalMonthDay(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalMonthDay(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\r\n    }\r\n    let calendar;\r\n    if (HasSlot(item, CALENDAR)) {\r\n      calendar = GetSlot(item, CALENDAR);\r\n    } else {\r\n      calendar = item.calendar;\r\n      if (calendar === undefined) calendar = 'iso8601';\r\n      calendar = ToTemporalCalendarIdentifier(calendar);\r\n    }\r\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    const isoDate = CalendarMonthDayFromFields(calendar, fields, overflow);\r\n    return CreateTemporalMonthDay(isoDate, calendar);\r\n  }\r\n\r\n  let { month, day, referenceISOYear, calendar } = ParseTemporalMonthDayString(RequireString(item));\r\n  if (calendar === undefined) calendar = 'iso8601';\r\n  calendar = CanonicalizeCalendar(calendar);\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\r\n\r\n  GetTemporalOverflowOption(GetOptionsObject(options));\r\n  if (calendar === 'iso8601') {\r\n    const isoCalendarReferenceYear = 1972; // First leap year after Unix epoch\r\n    return CreateTemporalMonthDay({ year: isoCalendarReferenceYear, month, day }, calendar);\r\n  }\r\n  assertExists(referenceISOYear);\r\n  let isoDate = { year: referenceISOYear, month, day };\r\n  RejectDateRange(isoDate);\r\n  const result = ISODateToFields(calendar, isoDate, 'month-day');\r\n  isoDate = CalendarMonthDayFromFields(calendar, result, 'constrain');\r\n  return CreateTemporalMonthDay(isoDate, calendar);\r\n}\r\n\r\nexport function ToTemporalTime(item: PlainTimeParams['from'][0], options?: PlainTimeParams['from'][1]) {\r\n  let time;\r\n  if (IsObject(item)) {\r\n    if (IsTemporalTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalTime(GetSlot(item, TIME));\r\n    }\r\n    if (IsTemporalDateTime(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalTime(GetSlot(item, ISO_DATE_TIME).time);\r\n    }\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalTime(isoDateTime.time);\r\n    }\r\n    const { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow);\r\n  } else {\r\n    time = ParseTemporalTimeString(RequireString(item));\r\n    GetTemporalOverflowOption(GetOptionsObject(options));\r\n  }\r\n  return CreateTemporalTime(time);\r\n}\r\n\r\nexport function ToTimeRecordOrMidnight(item: PlainTimeParams['from'][0] | undefined) {\r\n  if (item === undefined) return MidnightTimeRecord();\r\n  return GetSlot(ToTemporalTime(item), TIME);\r\n}\r\n\r\nexport function ToTemporalYearMonth(\r\n  item: PlainYearMonthParams['from'][0],\r\n  options?: PlainYearMonthParams['from'][1]\r\n): Temporal.PlainYearMonth {\r\n  if (IsObject(item)) {\r\n    if (IsTemporalYearMonth(item)) {\r\n      GetTemporalOverflowOption(GetOptionsObject(options));\r\n      return CreateTemporalYearMonth(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\r\n    }\r\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode'], [], []);\r\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\r\n    const isoDate = CalendarYearMonthFromFields(calendar, fields, overflow);\r\n    return CreateTemporalYearMonth(isoDate, calendar);\r\n  }\r\n\r\n  let { year, month, referenceISODay, calendar } = ParseTemporalYearMonthString(RequireString(item));\r\n  if (calendar === undefined) calendar = 'iso8601';\r\n  calendar = CanonicalizeCalendar(calendar);\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\r\n\r\n  GetTemporalOverflowOption(GetOptionsObject(options));\r\n  let isoDate = { year, month, day: referenceISODay };\r\n  RejectYearMonthRange(isoDate);\r\n  const result = ISODateToFields(calendar, isoDate, 'year-month');\r\n  isoDate = CalendarYearMonthFromFields(calendar, result, 'constrain');\r\n  return CreateTemporalYearMonth(isoDate, calendar);\r\n}\r\n\r\ntype OffsetBehaviour = 'wall' | 'exact' | 'option';\r\n\r\nexport function InterpretISODateTimeOffset(\r\n  isoDate: ISODate,\r\n  time: 'start-of-day' | TimeRecord,\r\n  offsetBehaviour: OffsetBehaviour,\r\n  offsetNs: number,\r\n  timeZone: string,\r\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>,\r\n  offsetOpt: Temporal.OffsetDisambiguationOptions['offset'],\r\n  matchMinute: boolean\r\n) {\r\n  // start-of-day signifies that we had a string such as YYYY-MM-DD[Zone]. It is\r\n  // grammatically not possible to specify a UTC offset in that string, so the\r\n  // behaviour collapses into ~WALL~, which is equivalent to offset: \"ignore\".\r\n  if (time === 'start-of-day') {\r\n    assert(offsetBehaviour === 'wall', 'offset cannot be provided in YYYY-MM-DD[Zone] string');\r\n    assert(offsetNs === 0, 'offset cannot be provided in YYYY-MM-DD[Zone] string');\r\n    return GetStartOfDay(timeZone, isoDate);\r\n  }\r\n\r\n  const dt = CombineISODateAndTimeRecord(isoDate, time);\r\n\r\n  if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\r\n    // Simple case: ISO string without a TZ offset (or caller wants to ignore\r\n    // the offset), so just convert DateTime to Instant in the given time zone\r\n    return GetEpochNanosecondsFor(timeZone, dt, disambiguation);\r\n  }\r\n\r\n  // The caller wants the offset to always win ('use') OR the caller is OK\r\n  // with the offset winning ('prefer' or 'reject') as long as it's valid\r\n  // for this timezone and date/time.\r\n  if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\r\n    // Calculate the instant for the input's date/time and offset\r\n    const balanced = BalanceISODateTime(\r\n      isoDate.year,\r\n      isoDate.month,\r\n      isoDate.day,\r\n      time.hour,\r\n      time.minute,\r\n      time.second,\r\n      time.millisecond,\r\n      time.microsecond,\r\n      time.nanosecond - offsetNs\r\n    );\r\n    CheckISODaysRange(balanced.isoDate);\r\n    const epochNs = GetUTCEpochNanoseconds(balanced);\r\n    ValidateEpochNanoseconds(epochNs);\r\n    return epochNs;\r\n  }\r\n\r\n  CheckISODaysRange(isoDate);\r\n  const utcEpochNs = GetUTCEpochNanoseconds(dt);\r\n\r\n  // \"prefer\" or \"reject\"\r\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, dt);\r\n  for (let index = 0; index < possibleEpochNs.length; index++) {\r\n    const candidate = possibleEpochNs[index];\r\n    const candidateOffset = ToNumber(utcEpochNs - candidate);\r\n    const roundedCandidateOffset = RoundNumberToIncrement(candidateOffset, 60e9, 'halfExpand');\r\n    if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\r\n      return candidate;\r\n    }\r\n  }\r\n\r\n  // the user-provided offset doesn't match any instants for this time\r\n  // zone and date/time.\r\n  if (offsetOpt === 'reject') {\r\n    const offsetStr = FormatUTCOffsetNanoseconds(BigInt(offsetNs));\r\n    const dtStr = ISODateTimeToString(dt, 'iso8601', 'auto');\r\n    throw new RangeError(`Offset ${offsetStr} is invalid for ${dtStr} in ${timeZone}`);\r\n  }\r\n  // fall through: offsetOpt === 'prefer', but the offset doesn't match\r\n  // so fall back to use the time zone instead.\r\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, dt, disambiguation);\r\n}\r\n\r\nexport function ToTemporalZonedDateTime(\r\n  item: ZonedDateTimeParams['from'][0],\r\n  options?: ZonedDateTimeParams['from'][1]\r\n) {\r\n  let isoDate, time, timeZone, offset, calendar;\r\n  let matchMinute = false;\r\n  let offsetBehaviour: OffsetBehaviour = 'option';\r\n  let disambiguation, offsetOpt;\r\n  if (IsObject(item)) {\r\n    if (IsTemporalZonedDateTime(item)) {\r\n      const resolvedOptions = GetOptionsObject(options);\r\n      GetTemporalDisambiguationOption(resolvedOptions); // validate and ignore\r\n      GetTemporalOffsetOption(resolvedOptions, 'reject');\r\n      GetTemporalOverflowOption(resolvedOptions);\r\n      return CreateTemporalZonedDateTime(\r\n        GetSlot(item, EPOCHNANOSECONDS),\r\n        GetSlot(item, TIME_ZONE),\r\n        GetSlot(item, CALENDAR)\r\n      );\r\n    }\r\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\r\n    const fields = PrepareCalendarFields(\r\n      calendar,\r\n      item,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\r\n      ['timeZone']\r\n    );\r\n    ({ offset, timeZone } = fields);\r\n    if (offset === undefined) {\r\n      offsetBehaviour = 'wall';\r\n    }\r\n    const resolvedOptions = GetOptionsObject(options);\r\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\r\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\r\n    const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\r\n  } else {\r\n    let tzAnnotation, z, year, month, day;\r\n    ({ year, month, day, time, tzAnnotation, offset, z, calendar } = ParseTemporalZonedDateTimeString(\r\n      RequireString(item)\r\n    ));\r\n    timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\r\n    if (z) {\r\n      offsetBehaviour = 'exact';\r\n    } else if (!offset) {\r\n      offsetBehaviour = 'wall';\r\n    }\r\n    if (!calendar) calendar = 'iso8601';\r\n    calendar = CanonicalizeCalendar(calendar);\r\n    matchMinute = true; // ISO strings may specify offset with less precision\r\n    const resolvedOptions = GetOptionsObject(options);\r\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\r\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\r\n    GetTemporalOverflowOption(resolvedOptions); // validate and ignore\r\n    isoDate = { year, month, day };\r\n  }\r\n  let offsetNs = 0;\r\n  if (offsetBehaviour === 'option') offsetNs = ParseDateTimeUTCOffset(castExists(offset));\r\n  const epochNanoseconds = InterpretISODateTimeOffset(\r\n    isoDate,\r\n    time,\r\n    offsetBehaviour,\r\n    offsetNs,\r\n    timeZone,\r\n    disambiguation,\r\n    offsetOpt,\r\n    matchMinute\r\n  );\r\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\r\n}\r\n\r\nexport function CreateTemporalDateSlots(result: Temporal.PlainDate, isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  RejectDateRange(isoDate);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE, isoDate);\r\n  SetSlot(result, CALENDAR, calendar);\r\n  SetSlot(result, DATE_BRAND, true);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalDateToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainDate <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalDate(isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\r\n  const result = Object.create(TemporalPlainDate.prototype);\r\n  CreateTemporalDateSlots(result, isoDate, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalDateTimeSlots(\r\n  result: Temporal.PlainDateTime,\r\n  isoDateTime: ISODateTime,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  RejectDateTimeRange(isoDateTime);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE_TIME, isoDateTime);\r\n  SetSlot(result, CALENDAR, calendar);\r\n\r\n  if (DEBUG) {\r\n    let repr = ISODateTimeToString(isoDateTime, calendar, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainDateTime <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalDateTime(isoDateTime: ISODateTime, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\r\n  const result = Object.create(TemporalPlainDateTime.prototype);\r\n  CreateTemporalDateTimeSlots(result, isoDateTime, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalMonthDaySlots(\r\n  result: Temporal.PlainMonthDay,\r\n  isoDate: ISODate,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  RejectDateRange(isoDate);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE, isoDate);\r\n  SetSlot(result, CALENDAR, calendar);\r\n  SetSlot(result, MONTH_DAY_BRAND, true);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalMonthDayToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainMonthDay <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalMonthDay(isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\r\n  const result = Object.create(TemporalPlainMonthDay.prototype);\r\n  CreateTemporalMonthDaySlots(result, isoDate, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalTimeSlots(result: Temporal.PlainTime, time: TimeRecord) {\r\n  CreateSlots(result);\r\n  SetSlot(result, TIME, time);\r\n\r\n  if (DEBUG) {\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainTime <${TimeRecordToString(time, 'auto')}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalTime(time: TimeRecord) {\r\n  const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\r\n  const result = Object.create(TemporalPlainTime.prototype);\r\n  CreateTemporalTimeSlots(result, time);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalYearMonthSlots(\r\n  result: Temporal.PlainYearMonth,\r\n  isoDate: ISODate,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  RejectYearMonthRange(isoDate);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, ISO_DATE, isoDate);\r\n  SetSlot(result, CALENDAR, calendar);\r\n  SetSlot(result, YEAR_MONTH_BRAND, true);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalYearMonthToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.PlainYearMonth <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalYearMonth(isoDate: ISODate, calendar: BuiltinCalendarId) {\r\n  const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\r\n  const result = Object.create(TemporalPlainYearMonth.prototype);\r\n  CreateTemporalYearMonthSlots(result, isoDate, calendar);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalInstantSlots(result: Temporal.Instant, epochNanoseconds: bigint) {\r\n  ValidateEpochNanoseconds(epochNanoseconds);\r\n  CreateSlots(result);\r\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\r\n\r\n  if (DEBUG) {\r\n    const iso = GetISOPartsFromEpoch(epochNanoseconds);\r\n    const repr = ISODateTimeToString(iso, 'iso8601', 'auto', 'never') + 'Z';\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `${result[Symbol.toStringTag]} <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalInstant(epochNanoseconds: bigint) {\r\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\r\n  const result: Temporal.Instant = Object.create(TemporalInstant.prototype);\r\n  CreateTemporalInstantSlots(result, epochNanoseconds);\r\n  return result;\r\n}\r\n\r\nexport function CreateTemporalZonedDateTimeSlots(\r\n  result: Temporal.ZonedDateTime,\r\n  epochNanoseconds: bigint,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId\r\n) {\r\n  ValidateEpochNanoseconds(epochNanoseconds);\r\n\r\n  CreateSlots(result);\r\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\r\n  SetSlot(result, TIME_ZONE, timeZone);\r\n  SetSlot(result, CALENDAR, calendar);\r\n\r\n  if (DEBUG) {\r\n    const repr = TemporalZonedDateTimeToString(result, 'auto');\r\n    Object.defineProperty(result, '_repr_', {\r\n      value: `Temporal.ZonedDateTime <${repr}>`,\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: false\r\n    });\r\n  }\r\n}\r\n\r\nexport function CreateTemporalZonedDateTime(\r\n  epochNanoseconds: bigint,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId = 'iso8601'\r\n) {\r\n  const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\r\n  const result: Temporal.ZonedDateTime = Object.create(TemporalZonedDateTime.prototype);\r\n  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\r\n  return result;\r\n}\r\n\r\nfunction CalendarFieldKeysPresent(fields: Record<FieldKey, unknown>) {\r\n  return CALENDAR_FIELD_KEYS.filter((key) => fields[key] !== undefined);\r\n}\r\n\r\nexport function CalendarMergeFields<Base extends Record<string, unknown>, ToAdd extends Record<string, unknown>>(\r\n  calendar: BuiltinCalendarId,\r\n  fields: Base,\r\n  additionalFields: ToAdd\r\n) {\r\n  const additionalKeys = CalendarFieldKeysPresent(additionalFields);\r\n  const overriddenKeys = calendarImplForID(calendar).fieldKeysToIgnore(additionalKeys);\r\n  const merged = Object.create(null);\r\n  const fieldsKeys = CalendarFieldKeysPresent(fields);\r\n  for (let ix = 0; ix < CALENDAR_FIELD_KEYS.length; ix++) {\r\n    let propValue = undefined;\r\n    const key = CALENDAR_FIELD_KEYS[ix];\r\n    if (fieldsKeys.includes(key) && !overriddenKeys.includes(key)) {\r\n      propValue = fields[key];\r\n    }\r\n    if (additionalKeys.includes(key)) {\r\n      propValue = additionalFields[key];\r\n    }\r\n    if (propValue !== undefined) merged[key] = propValue;\r\n  }\r\n  return merged as Base & ToAdd;\r\n}\r\n\r\nexport function CalendarDateAdd(\r\n  calendar: BuiltinCalendarId,\r\n  isoDate: ISODate,\r\n  dateDuration: Partial<DateDuration>,\r\n  overflow: Overflow\r\n) {\r\n  const result = calendarImplForID(calendar).dateAdd(isoDate, dateDuration, overflow);\r\n  RejectDateRange(result);\r\n  return result;\r\n}\r\n\r\nfunction CalendarDateUntil(\r\n  calendar: BuiltinCalendarId,\r\n  isoDate: ISODate,\r\n  isoOtherDate: ISODate,\r\n  largestUnit: Temporal.DateUnit\r\n) {\r\n  return calendarImplForID(calendar).dateUntil(isoDate, isoOtherDate, largestUnit);\r\n}\r\n\r\nexport function ToTemporalCalendarIdentifier(calendarLike: Temporal.CalendarLike): BuiltinCalendarId {\r\n  if (IsObject(calendarLike)) {\r\n    if (HasSlot(calendarLike, CALENDAR)) return GetSlot(calendarLike, CALENDAR);\r\n  }\r\n  const identifier = RequireString(calendarLike);\r\n  try {\r\n    // Fast path: identifier is a calendar type, no ISO string parsing needed\r\n    return CanonicalizeCalendar(identifier);\r\n  } catch {\r\n    // fall through\r\n  }\r\n  let calendar;\r\n  try {\r\n    ({ calendar } = ParseISODateTime(identifier));\r\n  } catch {\r\n    try {\r\n      ({ calendar } = ParseTemporalTimeString(identifier));\r\n    } catch {\r\n      try {\r\n        ({ calendar } = ParseTemporalYearMonthString(identifier));\r\n      } catch {\r\n        ({ calendar } = ParseTemporalMonthDayString(identifier));\r\n      }\r\n    }\r\n  }\r\n  if (!calendar) calendar = 'iso8601';\r\n  return CanonicalizeCalendar(calendar);\r\n}\r\n\r\nfunction GetTemporalCalendarIdentifierWithISODefault(item: { calendar?: Temporal.CalendarLike }) {\r\n  if (HasSlot(item, CALENDAR)) return GetSlot(item, CALENDAR);\r\n  const { calendar } = item;\r\n  if (calendar === undefined) return 'iso8601';\r\n  return ToTemporalCalendarIdentifier(calendar);\r\n}\r\n\r\nexport function CalendarEquals(one: BuiltinCalendarId, two: BuiltinCalendarId) {\r\n  return CanonicalizeCalendar(one) === CanonicalizeCalendar(two);\r\n}\r\n\r\nexport function CalendarDateFromFields(calendar: BuiltinCalendarId, fields: CalendarFieldsRecord, overflow: Overflow) {\r\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\r\n  calendarImpl.resolveFields(fields, 'date');\r\n  const result = calendarImpl.dateToISO(fields, overflow);\r\n  RejectDateRange(result);\r\n  return result;\r\n}\r\n\r\nexport function CalendarYearMonthFromFields(\r\n  calendar: BuiltinCalendarId,\r\n  fields: CalendarFieldsRecord,\r\n  overflow: Overflow\r\n) {\r\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\r\n  calendarImpl.resolveFields(fields, 'year-month');\r\n  fields.day = 1;\r\n  const result = calendarImpl.dateToISO(fields, overflow);\r\n  RejectYearMonthRange(result);\r\n  return result;\r\n}\r\n\r\nexport function CalendarMonthDayFromFields(\r\n  calendar: BuiltinCalendarId,\r\n  fields: MonthDayFromFieldsObject,\r\n  overflow: Overflow\r\n) {\r\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\r\n  calendarImpl.resolveFields(fields, 'month-day');\r\n  const result = calendarImpl.monthDayToISOReferenceDate(fields, overflow);\r\n  RejectDateRange(result);\r\n  return result;\r\n}\r\n\r\nexport function ToTemporalTimeZoneIdentifier(temporalTimeZoneLike: unknown): string {\r\n  if (IsObject(temporalTimeZoneLike)) {\r\n    if (IsTemporalZonedDateTime(temporalTimeZoneLike)) return GetSlot(temporalTimeZoneLike, TIME_ZONE);\r\n  }\r\n  const timeZoneString = RequireString(temporalTimeZoneLike);\r\n  if (timeZoneString === 'UTC') return 'UTC'; // UTC fast path\r\n\r\n  const { tzName, offsetMinutes } = ParseTemporalTimeZoneString(timeZoneString);\r\n  if (offsetMinutes !== undefined) {\r\n    return FormatOffsetTimeZoneIdentifier(offsetMinutes);\r\n  }\r\n  // if offsetMinutes is undefined, then tzName must be present\r\n  const record = GetAvailableNamedTimeZoneIdentifier(castExists(tzName));\r\n  if (!record) throw new RangeError(`Unrecognized time zone ${tzName}`);\r\n  return record.identifier;\r\n}\r\n\r\nexport function TimeZoneEquals(one: string, two: string) {\r\n  if (one === two) return true;\r\n  const offsetMinutes1 = ParseTimeZoneIdentifier(one).offsetMinutes;\r\n  const offsetMinutes2 = ParseTimeZoneIdentifier(two).offsetMinutes;\r\n  if (offsetMinutes1 === undefined && offsetMinutes2 === undefined) {\r\n    // Calling GetAvailableNamedTimeZoneIdentifier is costly, so (unlike the\r\n    // spec) the polyfill will early-return if one of them isn't recognized. Try\r\n    // the second ID first because it's more likely to be unknown, because it\r\n    // can come from the argument of TimeZone.p.equals as opposed to the first\r\n    // ID which comes from the receiver.\r\n    const idRecord2 = GetAvailableNamedTimeZoneIdentifier(two);\r\n    if (!idRecord2) return false;\r\n    const idRecord1 = GetAvailableNamedTimeZoneIdentifier(one);\r\n    if (!idRecord1) return false;\r\n    return idRecord1.primaryIdentifier === idRecord2.primaryIdentifier;\r\n  } else {\r\n    return offsetMinutes1 === offsetMinutes2;\r\n  }\r\n}\r\n\r\nexport function GetOffsetNanosecondsFor(timeZone: string, epochNs: bigint): number {\r\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes ?? 0;\r\n  if (offsetMinutes !== undefined) return offsetMinutes * 60_000_000_000; //60*1e9\r\n\r\n  return GetNamedTimeZoneOffsetNanoseconds(timeZone, epochNs);\r\n}\r\n\r\nexport function FormatUTCOffsetNanoseconds(offsetNs: bigint): string {\r\n  const sign = offsetNs < 0n ? '-' : '+';\r\n  const absoluteNs = offsetNs < 0n ? -offsetNs : offsetNs;\r\n  const hour = Number(absoluteNs / 3600_000_000_000n);\r\n  const minute = Number(absoluteNs / 60_000_000_000n) % 60;\r\n  const second = Number(absoluteNs / 1_000_000_000n) % 60;\r\n  const subSecondNs = Number(absoluteNs % 1_000_000_000n);\r\n  const precision = second === 0 && subSecondNs === 0 ? 'minute' : 'auto';\r\n  const timeString = FormatTimeString(hour, minute, second, subSecondNs, precision);\r\n  return `${sign}${timeString}`;\r\n}\r\n\r\nexport function GetISODateTimeFor(timeZone: string, epochNs: bigint) {\r\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, epochNs);\r\n  let {\r\n    isoDate: { year, month, day },\r\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\r\n  } = GetISOPartsFromEpoch(epochNs);\r\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs);\r\n}\r\n\r\nexport function GetEpochNanosecondsFor(\r\n  timeZone: string,\r\n  isoDateTime: ISODateTime,\r\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\r\n) {\r\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\r\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, isoDateTime, disambiguation);\r\n}\r\n\r\n// TODO: See if this logic can be removed in favour of GetNamedTimeZoneEpochNanoseconds\r\nfunction DisambiguatePossibleEpochNanoseconds(\r\n  possibleEpochNs: bigint[],\r\n  timeZone: string,\r\n  isoDateTime: ISODateTime,\r\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\r\n) {\r\n  const numInstants = possibleEpochNs.length;\r\n\r\n  if (numInstants === 1) return possibleEpochNs[0];\r\n  if (numInstants) {\r\n    switch (disambiguation) {\r\n      case 'compatible':\r\n      // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\r\n      case 'earlier':\r\n        return possibleEpochNs[0];\r\n      case 'later':\r\n        return possibleEpochNs[numInstants - 1];\r\n      case 'reject': {\r\n        throw new RangeError('multiple instants found');\r\n      }\r\n    }\r\n  }\r\n\r\n  if (disambiguation === 'reject') throw new RangeError('multiple instants found');\r\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\r\n\r\n  const dayBefore = utcns - DAY_NANOS_BI;\r\n  ValidateEpochNanoseconds(dayBefore);\r\n  const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\r\n  const dayAfter = DAY_NANOS_BI + utcns;\r\n  ValidateEpochNanoseconds(dayAfter);\r\n  const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\r\n  const nanoseconds = offsetAfter - offsetBefore;\r\n  assert(Math.abs(nanoseconds) <= DAY_NANOS, 'UTC offset shift longer than 24 hours');\r\n\r\n  switch (disambiguation) {\r\n    case 'earlier': {\r\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, -nanoseconds);\r\n      const earlierTime = AddTime(isoDateTime.time, timeDuration);\r\n      const earlierDate = BalanceISODate(\r\n        isoDateTime.isoDate.year,\r\n        isoDateTime.isoDate.month,\r\n        isoDateTime.isoDate.day + earlierTime.deltaDays\r\n      );\r\n      const earlier = CombineISODateAndTimeRecord(earlierDate, earlierTime);\r\n      return GetPossibleEpochNanoseconds(timeZone, earlier)[0];\r\n    }\r\n    case 'compatible':\r\n    // fall through because 'compatible' means 'later' for \"spring forward\" transitions\r\n    case 'later': {\r\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, nanoseconds);\r\n      const laterTime = AddTime(isoDateTime.time, timeDuration);\r\n      const laterDate = BalanceISODate(\r\n        isoDateTime.isoDate.year,\r\n        isoDateTime.isoDate.month,\r\n        isoDateTime.isoDate.day + laterTime.deltaDays\r\n      );\r\n      const later = CombineISODateAndTimeRecord(laterDate, laterTime);\r\n      const possible = GetPossibleEpochNanoseconds(timeZone, later);\r\n      return possible[possible.length - 1];\r\n    }\r\n  }\r\n}\r\n\r\nfunction GetPossibleEpochNanoseconds(timeZone: string, isoDateTime: ISODateTime) {\r\n  // UTC fast path\r\n  if (timeZone === 'UTC') {\r\n    CheckISODaysRange(isoDateTime.isoDate);\r\n    return [GetUTCEpochNanoseconds(isoDateTime)];\r\n  }\r\n\r\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes;\r\n  if (offsetMinutes !== undefined) {\r\n    const balanced = BalanceISODateTime(\r\n      isoDateTime.isoDate.year,\r\n      isoDateTime.isoDate.month,\r\n      isoDateTime.isoDate.day,\r\n      isoDateTime.time.hour,\r\n      isoDateTime.time.minute - offsetMinutes,\r\n      isoDateTime.time.second,\r\n      isoDateTime.time.millisecond,\r\n      isoDateTime.time.microsecond,\r\n      isoDateTime.time.nanosecond\r\n    );\r\n    CheckISODaysRange(balanced.isoDate);\r\n    const epochNs = GetUTCEpochNanoseconds(balanced);\r\n    ValidateEpochNanoseconds(epochNs);\r\n    return [epochNs];\r\n  }\r\n\r\n  CheckISODaysRange(isoDateTime.isoDate);\r\n  return GetNamedTimeZoneEpochNanoseconds(timeZone, isoDateTime);\r\n}\r\n\r\nexport function GetStartOfDay(timeZone: string, isoDate: ISODate) {\r\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\r\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\r\n  // If not a DST gap, return the single or earlier epochNs\r\n  if (possibleEpochNs.length) return possibleEpochNs[0];\r\n\r\n  // Otherwise, 00:00:00 lies within a DST gap. Compute an epochNs that's\r\n  // guaranteed to be before the transition\r\n  assert(!IsOffsetTimeZoneIdentifier(timeZone), 'should only be reached with named time zone');\r\n\r\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\r\n  const dayBefore = utcns - DAY_NANOS_BI;\r\n  ValidateEpochNanoseconds(dayBefore);\r\n  return castExists(GetNamedTimeZoneNextTransition(timeZone, dayBefore));\r\n}\r\n\r\nexport function ISOYearString(year: number) {\r\n  let yearString;\r\n  if (year < 0 || year > 9999) {\r\n    const sign = year < 0 ? '-' : '+';\r\n    const yearNumber = Math.abs(year);\r\n    yearString = sign + ToZeroPaddedDecimalString(yearNumber, 6);\r\n  } else {\r\n    yearString = ToZeroPaddedDecimalString(year, 4);\r\n  }\r\n  return yearString;\r\n}\r\n\r\nexport function ISODateTimePartString(part: number) {\r\n  return ToZeroPaddedDecimalString(part, 2);\r\n}\r\n\r\nfunction FormatFractionalSeconds(\r\n  subSecondNanoseconds: number,\r\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\r\n): string {\r\n  let fraction;\r\n  if (precision === 'auto') {\r\n    if (subSecondNanoseconds === 0) return '';\r\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\r\n    // now remove any trailing zeroes\r\n    fraction = fractionFullPrecision.replace(/0+$/, '');\r\n  } else {\r\n    if (precision === 0) return '';\r\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\r\n    fraction = fractionFullPrecision.slice(0, precision);\r\n  }\r\n  return `.${fraction}`;\r\n}\r\n\r\nfunction FormatTimeString(\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  subSecondNanoseconds: number,\r\n  precision: SecondsStringPrecisionRecord['precision']\r\n): string {\r\n  let result = `${ISODateTimePartString(hour)}:${ISODateTimePartString(minute)}`;\r\n  if (precision === 'minute') return result;\r\n\r\n  result += `:${ISODateTimePartString(second)}`;\r\n  result += FormatFractionalSeconds(subSecondNanoseconds, precision);\r\n  return result;\r\n}\r\n\r\nexport function TemporalInstantToString(\r\n  instant: Temporal.Instant,\r\n  timeZone: string | undefined,\r\n  precision: SecondsStringPrecisionRecord['precision']\r\n) {\r\n  let outputTimeZone = timeZone;\r\n  if (outputTimeZone === undefined) outputTimeZone = 'UTC';\r\n  const epochNs = GetSlot(instant, EPOCHNANOSECONDS);\r\n  const iso = GetISODateTimeFor(outputTimeZone, epochNs);\r\n  const dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\r\n  let timeZoneString = 'Z';\r\n  if (timeZone !== undefined) {\r\n    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, epochNs);\r\n    timeZoneString = FormatDateTimeUTCOffsetRounded(offsetNs);\r\n  }\r\n  return `${dateTimeString}${timeZoneString}`;\r\n}\r\n\r\ninterface ToStringOptions {\r\n  unit: SecondsStringPrecisionRecord['unit'];\r\n  increment: number;\r\n  roundingMode: ReturnType<typeof GetRoundingModeOption>;\r\n}\r\n\r\nexport function TemporalDurationToString(\r\n  duration: Temporal.Duration,\r\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\r\n) {\r\n  const years = GetSlot(duration, YEARS);\r\n  const months = GetSlot(duration, MONTHS);\r\n  const weeks = GetSlot(duration, WEEKS);\r\n  const days = GetSlot(duration, DAYS);\r\n  const hours = GetSlot(duration, HOURS);\r\n  const minutes = GetSlot(duration, MINUTES);\r\n  const sign = DurationSign(duration);\r\n\r\n  let datePart = '';\r\n  if (years !== 0) datePart += `${Math.abs(years)}Y`;\r\n  if (months !== 0) datePart += `${Math.abs(months)}M`;\r\n  if (weeks !== 0) datePart += `${Math.abs(weeks)}W`;\r\n  if (days !== 0) datePart += `${Math.abs(days)}D`;\r\n\r\n  let timePart = '';\r\n  if (hours !== 0) timePart += `${Math.abs(hours)}H`;\r\n  if (minutes !== 0) timePart += `${Math.abs(minutes)}M`;\r\n\r\n  // Keeping sub-second units separate avoids losing precision after resolving\r\n  // any overflows from rounding\r\n  const secondsDuration = TimeDuration.fromComponents(\r\n    0,\r\n    0,\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  );\r\n  if (\r\n    !secondsDuration.isZero() ||\r\n    ['second', 'millisecond', 'microsecond', 'nanosecond'].includes(DefaultTemporalLargestUnit(duration)) ||\r\n    precision !== 'auto'\r\n  ) {\r\n    const secondsPart = Math.abs(secondsDuration.sec);\r\n    const subSecondsPart = FormatFractionalSeconds(Math.abs(secondsDuration.subsec), precision);\r\n    timePart += `${secondsPart}${subSecondsPart}S`;\r\n  }\r\n  let result = `${sign < 0 ? '-' : ''}P${datePart}`;\r\n  if (timePart) result = `${result}T${timePart}`;\r\n  return result;\r\n}\r\n\r\nexport function TemporalDateToString(\r\n  date: Temporal.PlainDate,\r\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\r\n) {\r\n  const { year, month, day } = GetSlot(date, ISO_DATE);\r\n  const yearString = ISOYearString(year);\r\n  const monthString = ISODateTimePartString(month);\r\n  const dayString = ISODateTimePartString(day);\r\n  const calendar = FormatCalendarAnnotation(GetSlot(date, CALENDAR), showCalendar);\r\n  return `${yearString}-${monthString}-${dayString}${calendar}`;\r\n}\r\n\r\nexport function TimeRecordToString(\r\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\r\n  precision: SecondsStringPrecisionRecord['precision']\r\n) {\r\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\r\n  return FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\r\n}\r\n\r\nexport function ISODateTimeToString(\r\n  isoDateTime: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  precision: SecondsStringPrecisionRecord['precision'],\r\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto'\r\n) {\r\n  const {\r\n    isoDate: { year, month, day },\r\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\r\n  } = isoDateTime;\r\n  const yearString = ISOYearString(year);\r\n  const monthString = ISODateTimePartString(month);\r\n  const dayString = ISODateTimePartString(day);\r\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\r\n  const timeString = FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\r\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\r\n  return `${yearString}-${monthString}-${dayString}T${timeString}${calendarString}`;\r\n}\r\n\r\nexport function TemporalMonthDayToString(\r\n  monthDay: Temporal.PlainMonthDay,\r\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\r\n) {\r\n  const { year, month, day } = GetSlot(monthDay, ISO_DATE);\r\n  const monthString = ISODateTimePartString(month);\r\n  const dayString = ISODateTimePartString(day);\r\n  let resultString = `${monthString}-${dayString}`;\r\n  const calendar = GetSlot(monthDay, CALENDAR);\r\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\r\n    const yearString = ISOYearString(year);\r\n    resultString = `${yearString}-${resultString}`;\r\n  }\r\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\r\n  if (calendarString) resultString += calendarString;\r\n  return resultString;\r\n}\r\n\r\nexport function TemporalYearMonthToString(\r\n  yearMonth: Temporal.PlainYearMonth,\r\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\r\n) {\r\n  const { year, month, day } = GetSlot(yearMonth, ISO_DATE);\r\n  const yearString = ISOYearString(year);\r\n  const monthString = ISODateTimePartString(month);\r\n  let resultString = `${yearString}-${monthString}`;\r\n  const calendar = GetSlot(yearMonth, CALENDAR);\r\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\r\n    const dayString = ISODateTimePartString(day);\r\n    resultString += `-${dayString}`;\r\n  }\r\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\r\n  if (calendarString) resultString += calendarString;\r\n  return resultString;\r\n}\r\n\r\nexport function TemporalZonedDateTimeToString(\r\n  zdt: Temporal.ZonedDateTime,\r\n  precision: SecondsStringPrecisionRecord['precision'],\r\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto',\r\n  showTimeZone: ReturnType<typeof GetTemporalShowTimeZoneNameOption> = 'auto',\r\n  showOffset: ReturnType<typeof GetTemporalShowOffsetOption> = 'auto',\r\n  options: ToStringOptions | undefined = undefined\r\n) {\r\n  let epochNs = GetSlot(zdt, EPOCHNANOSECONDS);\r\n\r\n  if (options) {\r\n    const { unit, increment, roundingMode } = options;\r\n    epochNs = RoundTemporalInstant(epochNs, increment, unit, roundingMode);\r\n  }\r\n\r\n  const tz = GetSlot(zdt, TIME_ZONE);\r\n  const offsetNs = GetOffsetNanosecondsFor(tz, epochNs);\r\n  const iso = GetISODateTimeFor(tz, epochNs);\r\n  let dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\r\n  if (showOffset !== 'never') {\r\n    dateTimeString += FormatDateTimeUTCOffsetRounded(offsetNs);\r\n  }\r\n  if (showTimeZone !== 'never') {\r\n    const flag = showTimeZone === 'critical' ? '!' : '';\r\n    dateTimeString += `[${flag}${tz}]`;\r\n  }\r\n  dateTimeString += FormatCalendarAnnotation(GetSlot(zdt, CALENDAR), showCalendar);\r\n  return dateTimeString;\r\n}\r\n\r\nexport function IsOffsetTimeZoneIdentifier(string: string) {\r\n  return OFFSET_IDENTIFIER.test(string);\r\n}\r\n\r\nexport function ParseDateTimeUTCOffset(string: string): number {\r\n  const match = OFFSET_WITH_PARTS.exec(string);\r\n  if (!match) {\r\n    throw new RangeError(`invalid time zone offset: ${string}; must match ±HH:MM[:SS.SSSSSSSSS]`);\r\n  }\r\n  const sign = match[1] === '-' ? -1 : +1;\r\n  const hours = +match[2];\r\n  const minutes = +(match[3] || 0);\r\n  const seconds = +(match[4] || 0);\r\n  const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\r\n  const offsetNanoseconds = sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\r\n  return offsetNanoseconds;\r\n}\r\n\r\nlet canonicalTimeZoneIdsCache: Map<string, string> | undefined | null = undefined;\r\nconst isTZIDSep = Object.assign(Object.create(null), { '/': true, '-': true, _: true });\r\n\r\nexport function GetAvailableNamedTimeZoneIdentifier(\r\n  identifier: string\r\n): { identifier: string; primaryIdentifier: string } | undefined {\r\n  // The most common case is when the identifier is a canonical time zone ID.\r\n  // Fast-path that case by caching all canonical IDs. For old ECMAScript\r\n  // implementations lacking this API, set the cache to `null` to avoid retries.\r\n  if (canonicalTimeZoneIdsCache === undefined) {\r\n    const canonicalTimeZoneIds = Intl.supportedValuesOf?.('timeZone');\r\n    if (canonicalTimeZoneIds) {\r\n      canonicalTimeZoneIdsCache = new Map();\r\n      for (let ix = 0; ix < canonicalTimeZoneIds.length; ix++) {\r\n        const id = canonicalTimeZoneIds[ix];\r\n        canonicalTimeZoneIdsCache.set(ASCIILowercase(id), id);\r\n      }\r\n    } else {\r\n      canonicalTimeZoneIdsCache = null;\r\n    }\r\n  }\r\n\r\n  const lower = ASCIILowercase(identifier);\r\n  let primaryIdentifier = canonicalTimeZoneIdsCache?.get(lower);\r\n  if (primaryIdentifier) return { identifier: primaryIdentifier, primaryIdentifier };\r\n\r\n  // It's not already a primary identifier, so get its primary identifier (or\r\n  // return if it's not an available named time zone ID).\r\n  try {\r\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(identifier);\r\n    primaryIdentifier = formatter.resolvedOptions().timeZone;\r\n  } catch {\r\n    return undefined;\r\n  }\r\n\r\n  // Special case this legacy identifier that is listed both in `backzone` and\r\n  // `backward` in the TZDB. Work around implementations that incorrectly use\r\n  // the `backward` data.\r\n  if (lower === 'antarctica/south_pole') primaryIdentifier = 'Antarctica/McMurdo';\r\n\r\n  // Some legacy identifiers are aliases in ICU but not legal IANA identifiers.\r\n  // Reject them even if the implementation's Intl supports them, as they are\r\n  // not present in the IANA time zone database.\r\n  if (ICU_LEGACY_TIME_ZONE_IDS.has(identifier)) {\r\n    throw new RangeError(`${identifier} is a legacy time zone identifier from ICU. Use ${primaryIdentifier} instead`);\r\n  }\r\n\r\n  // The identifier is an alias (a deprecated identifier that's a synonym for a\r\n  // primary identifier), so we need to case-normalize the identifier to match\r\n  // the IANA TZDB, e.g. america/new_york => America/New_York. There's no\r\n  // built-in way to do this using Intl.DateTimeFormat, but the we can normalize\r\n  // almost all aliases (modulo a few special cases) using the TZDB's basic\r\n  // capitalization pattern:\r\n  // 1. capitalize the first letter of the identifier\r\n  // 2. capitalize the letter after every slash, dash, or underscore delimiter\r\n  const chars = [...lower].map((c, i) => (i === 0 || isTZIDSep[lower[i - 1]] ? c.toUpperCase() : c));\r\n  const standardCase = chars.join('');\r\n  const segments = standardCase.split('/');\r\n\r\n  if (segments.length === 1) {\r\n    // If a single-segment legacy ID is 2-3 chars or contains a number or dash, then\r\n    // (except for the \"GB-Eire\" special case) the case-normalized form is uppercase.\r\n    // These are: GMT+0, GMT-0, GB, NZ, PRC, ROC, ROK, UCT, GMT, GMT0, CET, CST6CDT,\r\n    // EET, EST, HST, MET, MST, MST7MDT, PST8PDT, WET, NZ-CHAT, and W-SU.\r\n    // Otherwise it's standard form: first letter capitalized, e.g. Iran, Egypt, Hongkong\r\n    if (lower === 'gb-eire') return { identifier: 'GB-Eire', primaryIdentifier };\r\n    return {\r\n      identifier: lower.length <= 3 || /[-0-9]/.test(lower) ? lower.toUpperCase() : segments[0],\r\n      primaryIdentifier\r\n    };\r\n  }\r\n\r\n  // All Etc zone names are uppercase except three exceptions.\r\n  if (segments[0] === 'Etc') {\r\n    const etcName = ['Zulu', 'Greenwich', 'Universal'].includes(segments[1]) ? segments[1] : segments[1].toUpperCase();\r\n    return { identifier: `Etc/${etcName}`, primaryIdentifier };\r\n  }\r\n\r\n  // Legacy US identifiers like US/Alaska or US/Indiana-Starke are 2 segments and use standard form.\r\n  if (segments[0] === 'Us') return { identifier: `US/${segments[1]}`, primaryIdentifier };\r\n\r\n  // For multi-segment IDs, there's a few special cases in the second/third segments\r\n  const specialCases = new Map([\r\n    ['Act', 'ACT'],\r\n    ['Lhi', 'LHI'],\r\n    ['Nsw', 'NSW'],\r\n    ['Dar_Es_Salaam', 'Dar_es_Salaam'],\r\n    ['Port_Of_Spain', 'Port_of_Spain'],\r\n    ['Port-Au-Prince', 'Port-au-Prince'],\r\n    ['Isle_Of_Man', 'Isle_of_Man'],\r\n    ['Comodrivadavia', 'ComodRivadavia'],\r\n    ['Knox_In', 'Knox_IN'],\r\n    ['Dumontdurville', 'DumontDUrville'],\r\n    ['Mcmurdo', 'McMurdo'],\r\n    ['Denoronha', 'DeNoronha'],\r\n    ['Easterisland', 'EasterIsland'],\r\n    ['Bajanorte', 'BajaNorte'],\r\n    ['Bajasur', 'BajaSur']\r\n  ]);\r\n  segments[1] = specialCases.get(segments[1]) ?? segments[1];\r\n  if (segments.length > 2) segments[2] = specialCases.get(segments[2]) ?? segments[2];\r\n  return { identifier: segments.join('/'), primaryIdentifier };\r\n}\r\n\r\nfunction GetNamedTimeZoneOffsetNanosecondsImpl(id: string, epochMilliseconds: number) {\r\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\r\n  let millisecond = epochMilliseconds % 1000;\r\n  if (millisecond < 0) millisecond += 1000;\r\n  const utc = GetUTCEpochMilliseconds({ isoDate: { year, month, day }, time: { hour, minute, second, millisecond } });\r\n  return (utc - epochMilliseconds) * 1e6;\r\n}\r\n\r\nfunction GetNamedTimeZoneOffsetNanoseconds(id: string, epochNanoseconds: bigint): number {\r\n  // Optimization: We get the offset nanoseconds only with millisecond\r\n  // resolution, assuming that time zone offset changes don't happen in the\r\n  // middle of a millisecond\r\n  return GetNamedTimeZoneOffsetNanosecondsImpl(id, epochNsToMs(epochNanoseconds, 'floor'));\r\n}\r\n\r\nexport function FormatOffsetTimeZoneIdentifier(offsetMinutes: number): string {\r\n  const sign = offsetMinutes < 0 ? '-' : '+';\r\n  const absoluteMinutes = Math.abs(offsetMinutes);\r\n  const hour = Math.floor(absoluteMinutes / 60);\r\n  const minute = absoluteMinutes % 60;\r\n  const timeString = FormatTimeString(hour, minute, 0, 0, 'minute');\r\n  return `${sign}${timeString}`;\r\n}\r\n\r\nfunction FormatDateTimeUTCOffsetRounded(offsetNanosecondsParam: number): string {\r\n  const offsetNanoseconds = RoundNumberToIncrement(offsetNanosecondsParam, MINUTE_NANOS, 'halfExpand');\r\n  return FormatOffsetTimeZoneIdentifier(offsetNanoseconds / 60e9);\r\n}\r\n\r\nfunction GetUTCEpochMilliseconds({\r\n  isoDate: { year, month, day },\r\n  time: { hour, minute, second, millisecond }\r\n}: {\r\n  isoDate: ISODate;\r\n  time: Omit<TimeRecord, 'microsecond' | 'nanosecond'>;\r\n}) {\r\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\r\n  // years. To avoid overflowing at the edges of the range, we reduce the year\r\n  // to the remainder after dividing by 400, and then add back all the\r\n  // nanoseconds from the multiples of 400 years at the end.\r\n  const reducedYear = year % 400;\r\n  const yearCycles = (year - reducedYear) / 400;\r\n\r\n  // Note: Date.UTC() interprets one and two-digit years as being in the\r\n  // 20th century, so don't use it\r\n  const legacyDate = new Date();\r\n  legacyDate.setUTCHours(hour, minute, second, millisecond);\r\n  legacyDate.setUTCFullYear(reducedYear, month - 1, day);\r\n  const ms = legacyDate.getTime();\r\n  return ms + MS_IN_400_YEAR_CYCLE * yearCycles;\r\n}\r\n\r\nfunction GetUTCEpochNanoseconds(isoDateTime: ISODateTime) {\r\n  const ms = GetUTCEpochMilliseconds(isoDateTime);\r\n  const subMs = isoDateTime.time.microsecond * 1e3 + isoDateTime.time.nanosecond;\r\n  return epochMsToNs(ms) + BigInt(subMs);\r\n}\r\n\r\nfunction GetISOPartsFromEpoch(epochNanoseconds: bigint) {\r\n  let epochMilliseconds = epochNsToMs(epochNanoseconds, 'trunc');\r\n  let nanos = Number(epochNanoseconds % BigInt(MILLION));\r\n  if (nanos < 0) {\r\n    nanos += 1e6;\r\n    epochMilliseconds -= 1;\r\n  }\r\n  const microsecond = Math.floor(nanos / 1e3) % 1e3;\r\n  const nanosecond = nanos % 1e3;\r\n\r\n  const item = new Date(epochMilliseconds);\r\n  const year = item.getUTCFullYear();\r\n  const month = item.getUTCMonth() + 1;\r\n  const day = item.getUTCDate();\r\n  const hour = item.getUTCHours();\r\n  const minute = item.getUTCMinutes();\r\n  const second = item.getUTCSeconds();\r\n  const millisecond = item.getUTCMilliseconds();\r\n\r\n  return {\r\n    epochMilliseconds,\r\n    isoDate: { year, month, day },\r\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\r\n  };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function GetNamedTimeZoneDateTimeParts(id: string, epochNanoseconds: bigint) {\r\n  const {\r\n    epochMilliseconds,\r\n    time: { millisecond, microsecond, nanosecond }\r\n  } = GetISOPartsFromEpoch(epochNanoseconds);\r\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\r\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\r\n}\r\n\r\n// Most time zones never transition twice within a short span of days. We still\r\n// accommodate twitchy zones, albeit at a performance penalty. 19 days is the\r\n// default window, past which we'd need to start adding many more special cases.\r\nfunction searchWindowForTransitions(id: string) {\r\n  if (id === 'Africa/El_Aaiun') return DAY_MS * 17;\r\n  if (id === 'America/Argentina/Tucuman') return DAY_MS * 12;\r\n  if (id === 'Europe/Tirane') return DAY_MS * 11;\r\n  if (id === 'Europe/Riga') return DAY_MS * 10;\r\n  if (id === 'Europe/Simferopol' || id === 'Europe/Vienna') return DAY_MS * 9;\r\n  if (id === 'Africa/Tunis') return DAY_MS * 8;\r\n  if (\r\n    id === 'America/Boa_Vista' ||\r\n    id === 'America/Fortaleza' ||\r\n    id === 'America/Maceio' ||\r\n    id === 'America/Noronha' ||\r\n    id === 'America/Recife' ||\r\n    id === 'Asia/Gaza' || // dubious, only in future calculations\r\n    id === 'Asia/Hebron' || // ditto\r\n    id === 'Brazil/DeNoronha'\r\n  ) {\r\n    return DAY_MS * 6;\r\n  }\r\n  return DAY_MS * 19;\r\n}\r\n\r\nexport function GetNamedTimeZoneNextTransition(id: string, epochNanoseconds: bigint): bigint | null {\r\n  if (id === 'UTC') return null; // UTC fast path\r\n\r\n  // Optimization: we floor the instant to the previous millisecond boundary\r\n  // so that we can do Number math instead of BigInt math. This assumes that\r\n  // time zone transitions don't happen in the middle of a millisecond.\r\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'floor');\r\n  if (epochMilliseconds < BEFORE_FIRST_DST) {\r\n    return GetNamedTimeZoneNextTransition(id, epochMsToNs(BEFORE_FIRST_DST));\r\n  }\r\n\r\n  // Optimization: the farthest that we'll look for a next transition is 3 years\r\n  // after the later of epochNanoseconds or the current time. If there are no\r\n  // transitions found before then, we'll assume that there will not be any more\r\n  // transitions after that.\r\n  const now = Date.now();\r\n  const base = Math.max(epochMilliseconds, now);\r\n  const uppercap = base + DAY_MS * 366 * 3;\r\n  let leftMs = epochMilliseconds;\r\n  let leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\r\n  let rightMs = leftMs;\r\n  let rightOffsetNs = leftOffsetNs;\r\n  const searchWindow = searchWindowForTransitions(id);\r\n  while (leftOffsetNs === rightOffsetNs && leftMs < uppercap) {\r\n    rightMs = leftMs + searchWindow;\r\n    if (rightMs > MS_MAX) return null;\r\n    rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\r\n    if (leftOffsetNs === rightOffsetNs) {\r\n      leftMs = rightMs;\r\n    }\r\n  }\r\n  if (leftOffsetNs === rightOffsetNs) return null;\r\n  const result = bisect(\r\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\r\n    leftMs,\r\n    rightMs,\r\n    leftOffsetNs,\r\n    rightOffsetNs\r\n  );\r\n  return epochMsToNs(result);\r\n}\r\n\r\nexport function GetNamedTimeZonePreviousTransition(id: string, epochNanoseconds: bigint): bigint | null {\r\n  if (id === 'UTC') return null; // UTC fast path\r\n\r\n  // Optimization: we raise the instant to the next millisecond boundary so\r\n  // that we can do Number math instead of BigInt math. This assumes that time\r\n  // zone transitions don't happen in the middle of a millisecond.\r\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'ceil');\r\n\r\n  // Optimization: if the instant is more than 3 years in the future and there\r\n  // are no transitions between the present day and 3 years from now, assume\r\n  // there are none after.\r\n  const now = Date.now();\r\n  const lookahead = now + DAY_MS * 366 * 3;\r\n  if (epochMilliseconds > lookahead) {\r\n    const prevBeforeLookahead = GetNamedTimeZonePreviousTransition(id, epochMsToNs(lookahead));\r\n    if (prevBeforeLookahead === null || prevBeforeLookahead < epochMsToNs(now)) {\r\n      return prevBeforeLookahead;\r\n    }\r\n  }\r\n\r\n  // We assume most time zones either have regular DST rules that extend\r\n  // indefinitely into the future, or they have no DST transitions between now\r\n  // and next year. Africa/Casablanca and Africa/El_Aaiun are unique cases\r\n  // that fit neither of these. Their irregular DST transitions are\r\n  // precomputed until 2087 in the current time zone database, so requesting\r\n  // the previous transition for an instant far in the future may take an\r\n  // extremely long time as it loops backward 2 weeks at a time.\r\n  if (id === 'Africa/Casablanca' || id === 'Africa/El_Aaiun') {\r\n    const lastPrecomputed = Date.UTC(2088, 0, 1); // 2088-01-01T00Z\r\n    if (lastPrecomputed < epochMilliseconds) {\r\n      return GetNamedTimeZonePreviousTransition(id, epochMsToNs(lastPrecomputed));\r\n    }\r\n  }\r\n\r\n  let rightMs = epochMilliseconds - 1;\r\n  if (rightMs < BEFORE_FIRST_DST) return null;\r\n  let rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\r\n  let leftMs = rightMs;\r\n  let leftOffsetNs = rightOffsetNs;\r\n  const searchWindow = searchWindowForTransitions(id);\r\n  while (rightOffsetNs === leftOffsetNs && rightMs > BEFORE_FIRST_DST) {\r\n    leftMs = rightMs - searchWindow;\r\n    if (leftMs < BEFORE_FIRST_DST) return null;\r\n    leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\r\n    if (rightOffsetNs === leftOffsetNs) {\r\n      rightMs = leftMs;\r\n    }\r\n  }\r\n  if (rightOffsetNs === leftOffsetNs) return null;\r\n  const result = bisect(\r\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\r\n    leftMs,\r\n    rightMs,\r\n    leftOffsetNs,\r\n    rightOffsetNs\r\n  );\r\n  return epochMsToNs(result);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function parseFromEnUsFormat(datetime: string) {\r\n  const splits = datetime.split(/[^\\w]+/);\r\n\r\n  if (splits.length !== 7) {\r\n    throw new RangeError(`expected 7 parts in \"${datetime}`);\r\n  }\r\n\r\n  const month = +splits[0];\r\n  const day = +splits[1];\r\n  let year = +splits[2];\r\n  const era = splits[3];\r\n  if (era[0] === 'b' || era[0] === 'B') {\r\n    year = -year + 1;\r\n  } else if (era[0] !== 'a' && era[0] !== 'A') {\r\n    throw new RangeError(`Unknown era ${era} in \"${datetime}`);\r\n  }\r\n  const hour = splits[4] === '24' ? 0 : +splits[4]; // bugs.chromium.org/p/chromium/issues/detail?id=1045791\r\n  const minute = +splits[5];\r\n  const second = +splits[6];\r\n\r\n  if (\r\n    !Number.isFinite(year) ||\r\n    !Number.isFinite(month) ||\r\n    !Number.isFinite(day) ||\r\n    !Number.isFinite(hour) ||\r\n    !Number.isFinite(minute) ||\r\n    !Number.isFinite(second)\r\n  ) {\r\n    throw new RangeError(`Invalid number in \"${datetime}`);\r\n  }\r\n\r\n  return { year, month, day, hour, minute, second };\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function GetFormatterParts(timeZone: string, epochMilliseconds: number) {\r\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\r\n  // Using `format` instead of `formatToParts` for compatibility with older\r\n  // clients and because it is twice as fast\r\n  const datetime = formatter.format(epochMilliseconds);\r\n  return parseFromEnUsFormat(datetime);\r\n}\r\n\r\n// The goal of this function is to find the exact time(s) that correspond to a\r\n// calendar date and clock time in a particular time zone. Normally there will\r\n// be only one match. But for repeated clock times after backwards transitions\r\n// (like when DST ends) there may be two matches. And for skipped clock times\r\n// after forward transitions, there will be no matches.\r\nfunction GetNamedTimeZoneEpochNanoseconds(id: string, isoDateTime: ISODateTime) {\r\n  // Get the offset of one day before and after the requested calendar date and\r\n  // clock time, avoiding overflows if near the edge of the Instant range.\r\n  let ns = GetUTCEpochNanoseconds(isoDateTime);\r\n  let nsEarlier = ns - BigInt(DAY_NANOS);\r\n  if (nsEarlier < NS_MIN) nsEarlier = ns;\r\n  let nsLater = ns + BigInt(DAY_NANOS);\r\n  if (nsLater > NS_MAX) nsLater = ns;\r\n  const earlierOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsEarlier);\r\n  const laterOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsLater);\r\n\r\n  // If before and after offsets are the same, then we assume there was no\r\n  // offset transition in between, and therefore only one exact time can\r\n  // correspond to the provided calendar date and clock time. But if they're\r\n  // different, then there was an offset transition in between, so test both\r\n  // offsets to see which one(s) will yield a matching exact time.\r\n  const found = earlierOffsetNs === laterOffsetNs ? [earlierOffsetNs] : [earlierOffsetNs, laterOffsetNs];\r\n  const candidates = found.map((offsetNanoseconds) => {\r\n    const epochNanoseconds = ns - BigInt(offsetNanoseconds);\r\n    const parts = GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\r\n    if (CompareISODateTime(isoDateTime, parts) !== 0) return undefined;\r\n    ValidateEpochNanoseconds(epochNanoseconds);\r\n    return epochNanoseconds;\r\n  });\r\n  return candidates.filter((x) => x !== undefined) as bigint[];\r\n}\r\n\r\nexport function LeapYear(year: number) {\r\n  if (undefined === year) return false;\r\n  const isDiv4 = year % 4 === 0;\r\n  const isDiv100 = year % 100 === 0;\r\n  const isDiv400 = year % 400 === 0;\r\n  return isDiv4 && (!isDiv100 || isDiv400);\r\n}\r\n\r\nexport function ISODaysInMonth(year: number, month: number) {\r\n  const DoM = {\r\n    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\r\n    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\r\n  };\r\n  return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\r\n}\r\n\r\nexport function DurationSign(duration: Temporal.Duration) {\r\n  const fields = [\r\n    GetSlot(duration, YEARS),\r\n    GetSlot(duration, MONTHS),\r\n    GetSlot(duration, WEEKS),\r\n    GetSlot(duration, DAYS),\r\n    GetSlot(duration, HOURS),\r\n    GetSlot(duration, MINUTES),\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  ];\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const prop = fields[index];\r\n    if (prop !== 0) return prop < 0 ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction DateDurationSign(dateDuration: DateDuration) {\r\n  const fieldNames = ['years', 'months', 'weeks', 'days'] as const;\r\n  for (let index = 0; index < fieldNames.length; index++) {\r\n    const prop = dateDuration[fieldNames[index]];\r\n    if (prop !== 0) return prop < 0 ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction InternalDurationSign(duration: InternalDuration) {\r\n  const dateSign = DateDurationSign(duration.date);\r\n  if (dateSign !== 0) return dateSign;\r\n  return duration.time.sign();\r\n}\r\n\r\nexport function BalanceISOYearMonth(yearParam: number, monthParam: number) {\r\n  let year = yearParam;\r\n  let month = monthParam;\r\n  if (!Number.isFinite(year) || !Number.isFinite(month)) throw new RangeError('infinity is out of range');\r\n  month -= 1;\r\n  year += Math.floor(month / 12);\r\n  month %= 12;\r\n  if (month < 0) month += 12;\r\n  month += 1;\r\n  return { year, month };\r\n}\r\n\r\nexport function BalanceISODate(yearParam: number, monthParam: number, dayParam: number) {\r\n  let year = yearParam;\r\n  let month = monthParam;\r\n  let day = dayParam;\r\n  if (!Number.isFinite(day)) throw new RangeError('infinity is out of range');\r\n  ({ year, month } = BalanceISOYearMonth(year, month));\r\n\r\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\r\n  // years. So if we have more than 400 years in days, there's no need to\r\n  // convert days to a year 400 times. We can convert a multiple of 400 all at\r\n  // once.\r\n  const daysIn400YearCycle = 400 * 365 + 97;\r\n  if (Math.abs(day) > daysIn400YearCycle) {\r\n    const nCycles = Math.trunc(day / daysIn400YearCycle);\r\n    year += 400 * nCycles;\r\n    day -= nCycles * daysIn400YearCycle;\r\n  }\r\n\r\n  let daysInYear = 0;\r\n  let testYear = month > 2 ? year : year - 1;\r\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\r\n    year -= 1;\r\n    testYear -= 1;\r\n    day += daysInYear;\r\n  }\r\n  testYear += 1;\r\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\r\n    year += 1;\r\n    testYear += 1;\r\n    day -= daysInYear;\r\n  }\r\n\r\n  while (day < 1) {\r\n    ({ year, month } = BalanceISOYearMonth(year, month - 1));\r\n    day += ISODaysInMonth(year, month);\r\n  }\r\n  while (day > ISODaysInMonth(year, month)) {\r\n    day -= ISODaysInMonth(year, month);\r\n    ({ year, month } = BalanceISOYearMonth(year, month + 1));\r\n  }\r\n\r\n  return { year, month, day };\r\n}\r\n\r\nfunction BalanceISODateTime(\r\n  year: number,\r\n  month: number,\r\n  day: number,\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  millisecond: number,\r\n  microsecond: number,\r\n  nanosecond: number\r\n) {\r\n  const time = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\r\n  return CombineISODateAndTimeRecord(isoDate, time);\r\n}\r\n\r\nfunction BalanceTime(\r\n  hourParam: number,\r\n  minuteParam: number,\r\n  secondParam: number,\r\n  millisecondParam: number,\r\n  microsecondParam: number,\r\n  nanosecondParam: number\r\n) {\r\n  let hour = hourParam;\r\n  let minute = minuteParam;\r\n  let second = secondParam;\r\n  let millisecond = millisecondParam;\r\n  let microsecond = microsecondParam;\r\n  let nanosecond = nanosecondParam;\r\n  let div;\r\n\r\n  ({ div, mod: nanosecond } = TruncatingDivModByPowerOf10(nanosecond, 3));\r\n  microsecond += div;\r\n  if (nanosecond < 0) {\r\n    microsecond -= 1;\r\n    nanosecond += 1000;\r\n  }\r\n\r\n  ({ div, mod: microsecond } = TruncatingDivModByPowerOf10(microsecond, 3));\r\n  millisecond += div;\r\n  if (microsecond < 0) {\r\n    millisecond -= 1;\r\n    microsecond += 1000;\r\n  }\r\n\r\n  second += Math.trunc(millisecond / 1000);\r\n  millisecond %= 1000;\r\n  if (millisecond < 0) {\r\n    second -= 1;\r\n    millisecond += 1000;\r\n  }\r\n\r\n  minute += Math.trunc(second / 60);\r\n  second %= 60;\r\n  if (second < 0) {\r\n    minute -= 1;\r\n    second += 60;\r\n  }\r\n\r\n  hour += Math.trunc(minute / 60);\r\n  minute %= 60;\r\n  if (minute < 0) {\r\n    hour -= 1;\r\n    minute += 60;\r\n  }\r\n\r\n  let deltaDays = Math.trunc(hour / 24);\r\n  hour %= 24;\r\n  if (hour < 0) {\r\n    deltaDays -= 1;\r\n    hour += 24;\r\n  }\r\n\r\n  // Results are possibly -0 at this point, but these are mathematical values in\r\n  // the spec. Force -0 to +0.\r\n  deltaDays += 0;\r\n  hour += 0;\r\n  minute += 0;\r\n  second += 0;\r\n  millisecond += 0;\r\n  microsecond += 0;\r\n  nanosecond += 0;\r\n\r\n  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\r\n}\r\n\r\nexport function DateDurationDays(dateDuration: DateDuration, plainRelativeTo: Temporal.PlainDate) {\r\n  const yearsMonthsWeeksDuration = AdjustDateDurationRecord(dateDuration, 0);\r\n  if (DateDurationSign(yearsMonthsWeeksDuration) === 0) return dateDuration.days;\r\n\r\n  // balance years, months, and weeks down to days\r\n  const isoDate = GetSlot(plainRelativeTo, ISO_DATE);\r\n  const later = CalendarDateAdd(GetSlot(plainRelativeTo, CALENDAR), isoDate, yearsMonthsWeeksDuration, 'constrain');\r\n  const epochDaysEarlier = ISODateToEpochDays(isoDate.year, isoDate.month - 1, isoDate.day);\r\n  const epochDaysLater = ISODateToEpochDays(later.year, later.month - 1, later.day);\r\n  const yearsMonthsWeeksInDays = epochDaysLater - epochDaysEarlier;\r\n  return dateDuration.days + yearsMonthsWeeksInDays;\r\n}\r\n\r\nexport function CreateNegatedTemporalDuration(duration: Temporal.Duration) {\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  return new TemporalDuration(\r\n    -GetSlot(duration, YEARS),\r\n    -GetSlot(duration, MONTHS),\r\n    -GetSlot(duration, WEEKS),\r\n    -GetSlot(duration, DAYS),\r\n    -GetSlot(duration, HOURS),\r\n    -GetSlot(duration, MINUTES),\r\n    -GetSlot(duration, SECONDS),\r\n    -GetSlot(duration, MILLISECONDS),\r\n    -GetSlot(duration, MICROSECONDS),\r\n    -GetSlot(duration, NANOSECONDS)\r\n  );\r\n}\r\n\r\nexport function ConstrainToRange(value: number | undefined, min: number, max: number) {\r\n  // Math.Max accepts undefined values and returns NaN. Undefined values are\r\n  // used for optional params in the method below.\r\n  return Math.min(max, Math.max(min, value as number));\r\n}\r\nexport function ConstrainISODate(year: number, monthParam: number, dayParam?: number) {\r\n  const month = ConstrainToRange(monthParam, 1, 12);\r\n  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\r\n  return { year, month, day };\r\n}\r\n\r\nexport function RejectToRange(value: number, min: number, max: number) {\r\n  if (value < min || value > max) throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\r\n}\r\n\r\nexport function RejectISODate(year: number, month: number, day: number) {\r\n  RejectToRange(month, 1, 12);\r\n  RejectToRange(day, 1, ISODaysInMonth(year, month));\r\n}\r\n\r\nfunction RejectDateRange(isoDate: ISODate) {\r\n  // Noon avoids trouble at edges of DateTime range (excludes midnight)\r\n  RejectDateTimeRange(CombineISODateAndTimeRecord(isoDate, NoonTimeRecord()));\r\n}\r\n\r\nexport function RejectTime(\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  millisecond: number,\r\n  microsecond: number,\r\n  nanosecond: number\r\n) {\r\n  RejectToRange(hour, 0, 23);\r\n  RejectToRange(minute, 0, 59);\r\n  RejectToRange(second, 0, 59);\r\n  RejectToRange(millisecond, 0, 999);\r\n  RejectToRange(microsecond, 0, 999);\r\n  RejectToRange(nanosecond, 0, 999);\r\n}\r\n\r\nexport function RejectDateTime(\r\n  year: number,\r\n  month: number,\r\n  day: number,\r\n  hour: number,\r\n  minute: number,\r\n  second: number,\r\n  millisecond: number,\r\n  microsecond: number,\r\n  nanosecond: number\r\n) {\r\n  RejectISODate(year, month, day);\r\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n}\r\n\r\nexport function RejectDateTimeRange(isoDateTime: ISODateTime) {\r\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\r\n  if (ns < DATETIME_NS_MIN || ns > DATETIME_NS_MAX) {\r\n    // Because PlainDateTime's range is wider than Instant's range, the line\r\n    // below will always throw. Calling `ValidateEpochNanoseconds` avoids\r\n    // repeating the same error message twice.\r\n    ValidateEpochNanoseconds(ns);\r\n  }\r\n}\r\n\r\n// Same as above, but throws a different, non-user-facing error\r\nfunction AssertISODateTimeWithinLimits(isoDateTime: ISODateTime) {\r\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\r\n  assert(\r\n    ns >= DATETIME_NS_MIN && ns <= DATETIME_NS_MAX,\r\n    `${ISODateTimeToString(isoDateTime, 'iso8601', 'auto')} is outside the representable range`\r\n  );\r\n}\r\n\r\n// In the spec, IsValidEpochNanoseconds returns a boolean and call sites are\r\n// responsible for throwing. In the polyfill, ValidateEpochNanoseconds takes its\r\n// place so that we can DRY the throwing code.\r\nfunction ValidateEpochNanoseconds(epochNanoseconds: bigint) {\r\n  if (epochNanoseconds < NS_MIN || epochNanoseconds > NS_MAX) {\r\n    throw new RangeError('date/time value is outside of supported range');\r\n  }\r\n}\r\n\r\nfunction RejectYearMonthRange({ year, month }: Omit<ISODate, 'day'>) {\r\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\r\n  if (year === YEAR_MIN) {\r\n    RejectToRange(month, 4, 12);\r\n  } else if (year === YEAR_MAX) {\r\n    RejectToRange(month, 1, 9);\r\n  }\r\n}\r\n\r\nexport function RejectDuration(\r\n  y: number,\r\n  mon: number,\r\n  w: number,\r\n  d: number,\r\n  h: number,\r\n  min: number,\r\n  s: number,\r\n  ms: number,\r\n  µs: number,\r\n  ns: number\r\n) {\r\n  let sign: -1 | 0 | 1 = 0;\r\n  const fields = [y, mon, w, d, h, min, s, ms, µs, ns];\r\n  for (let index = 0; index < fields.length; index++) {\r\n    const prop = fields[index];\r\n    if (prop === Infinity || prop === -Infinity) throw new RangeError('infinite values not allowed as duration fields');\r\n    if (prop !== 0) {\r\n      const propSign = prop < 0 ? -1 : 1;\r\n      if (sign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\r\n      sign = propSign;\r\n    }\r\n  }\r\n  if (Math.abs(y) >= 2 ** 32 || Math.abs(mon) >= 2 ** 32 || Math.abs(w) >= 2 ** 32) {\r\n    throw new RangeError('years, months, and weeks must be < 2³²');\r\n  }\r\n  const msResult = TruncatingDivModByPowerOf10(ms, 3);\r\n  const µsResult = TruncatingDivModByPowerOf10(µs, 6);\r\n  const nsResult = TruncatingDivModByPowerOf10(ns, 9);\r\n  const remainderSec = TruncatingDivModByPowerOf10(msResult.mod * 1e6 + µsResult.mod * 1e3 + nsResult.mod, 9).div;\r\n  const totalSec = d * 86400 + h * 3600 + min * 60 + s + msResult.div + µsResult.div + nsResult.div + remainderSec;\r\n  if (!Number.isSafeInteger(totalSec)) {\r\n    throw new RangeError('total of duration time units cannot exceed 9007199254740991.999999999 s');\r\n  }\r\n}\r\n\r\nexport function ToInternalDurationRecord(duration: Temporal.Duration) {\r\n  const date = {\r\n    years: GetSlot(duration, YEARS),\r\n    months: GetSlot(duration, MONTHS),\r\n    weeks: GetSlot(duration, WEEKS),\r\n    days: GetSlot(duration, DAYS)\r\n  };\r\n  const time = TimeDuration.fromComponents(\r\n    GetSlot(duration, HOURS),\r\n    GetSlot(duration, MINUTES),\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  );\r\n  return { date, time };\r\n}\r\n\r\nexport function ToInternalDurationRecordWith24HourDays(duration: Temporal.Duration) {\r\n  const time = TimeDuration.fromComponents(\r\n    GetSlot(duration, HOURS),\r\n    GetSlot(duration, MINUTES),\r\n    GetSlot(duration, SECONDS),\r\n    GetSlot(duration, MILLISECONDS),\r\n    GetSlot(duration, MICROSECONDS),\r\n    GetSlot(duration, NANOSECONDS)\r\n  ).add24HourDays(GetSlot(duration, DAYS));\r\n  const date = {\r\n    years: GetSlot(duration, YEARS),\r\n    months: GetSlot(duration, MONTHS),\r\n    weeks: GetSlot(duration, WEEKS),\r\n    days: 0\r\n  };\r\n  return { date, time };\r\n}\r\n\r\nfunction ToDateDurationRecordWithoutTime(duration: Temporal.Duration) {\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n  const days = Math.trunc(internalDuration.time.sec / 86400);\r\n  RejectDuration(\r\n    internalDuration.date.years,\r\n    internalDuration.date.months,\r\n    internalDuration.date.weeks,\r\n    days,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    0\r\n  );\r\n  return { ...internalDuration.date, days };\r\n}\r\n\r\nexport function TemporalDurationFromInternal(internalDuration: InternalDuration, largestUnit: Temporal.DateTimeUnit) {\r\n  const sign = internalDuration.time.sign();\r\n  let nanoseconds = internalDuration.time.abs().subsec;\r\n  let microseconds = 0;\r\n  let milliseconds = 0;\r\n  let seconds = internalDuration.time.abs().sec;\r\n  let minutes = 0;\r\n  let hours = 0;\r\n  let days = 0;\r\n\r\n  switch (largestUnit) {\r\n    case 'year':\r\n    case 'month':\r\n    case 'week':\r\n    case 'day':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      minutes = Math.trunc(seconds / 60);\r\n      seconds %= 60;\r\n      hours = Math.trunc(minutes / 60);\r\n      minutes %= 60;\r\n      days = Math.trunc(hours / 24);\r\n      hours %= 24;\r\n      break;\r\n    case 'hour':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      minutes = Math.trunc(seconds / 60);\r\n      seconds %= 60;\r\n      hours = Math.trunc(minutes / 60);\r\n      minutes %= 60;\r\n      break;\r\n    case 'minute':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      minutes = Math.trunc(seconds / 60);\r\n      seconds %= 60;\r\n      break;\r\n    case 'second':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = Math.trunc(microseconds / 1000);\r\n      microseconds %= 1000;\r\n      seconds += Math.trunc(milliseconds / 1000);\r\n      milliseconds %= 1000;\r\n      break;\r\n    case 'millisecond':\r\n      microseconds = Math.trunc(nanoseconds / 1000);\r\n      nanoseconds %= 1000;\r\n      milliseconds = FMAPowerOf10(seconds, 3, Math.trunc(microseconds / 1000));\r\n      microseconds %= 1000;\r\n      seconds = 0;\r\n      break;\r\n    case 'microsecond':\r\n      microseconds = FMAPowerOf10(seconds, 6, Math.trunc(nanoseconds / 1000));\r\n      nanoseconds %= 1000;\r\n      seconds = 0;\r\n      break;\r\n    case 'nanosecond':\r\n      nanoseconds = FMAPowerOf10(seconds, 9, nanoseconds);\r\n      seconds = 0;\r\n      break;\r\n    default:\r\n      /* c8 ignore next */ assertNotReached();\r\n  }\r\n\r\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\r\n  return new TemporalDuration(\r\n    internalDuration.date.years,\r\n    internalDuration.date.months,\r\n    internalDuration.date.weeks,\r\n    internalDuration.date.days + sign * days,\r\n    sign * hours,\r\n    sign * minutes,\r\n    sign * seconds,\r\n    sign * milliseconds,\r\n    sign * microseconds,\r\n    sign * nanoseconds\r\n  );\r\n}\r\n\r\nexport function CombineDateAndTimeDuration(dateDuration: DateDuration, timeDuration: TimeDuration) {\r\n  const dateSign = DateDurationSign(dateDuration);\r\n  const timeSign = timeDuration.sign();\r\n  assert(\r\n    dateSign === 0 || timeSign === 0 || dateSign === timeSign,\r\n    'should not be able to create mixed sign duration fields here'\r\n  );\r\n  return { date: dateDuration, time: timeDuration };\r\n}\r\n\r\n// Caution: month is 0-based\r\nexport function ISODateToEpochDays(year: number, month: number, day: number) {\r\n  return (\r\n    GetUTCEpochMilliseconds({\r\n      isoDate: { year, month: month + 1, day },\r\n      time: { hour: 0, minute: 0, second: 0, millisecond: 0 }\r\n    }) / DAY_MS\r\n  );\r\n}\r\n\r\n// This is needed before calling GetUTCEpochNanoseconds, because it uses MakeDay\r\n// which is ill-defined in how it handles large year numbers. If the issue\r\n// https://github.com/tc39/ecma262/issues/1087 is fixed, this can be removed\r\n// with no observable changes.\r\nfunction CheckISODaysRange({ year, month, day }: ISODate) {\r\n  if (Math.abs(ISODateToEpochDays(year, month - 1, day)) > 1e8) {\r\n    throw new RangeError('date/time value is outside the supported range');\r\n  }\r\n}\r\n\r\nfunction DifferenceTime(time1: TimeRecord, time2: TimeRecord) {\r\n  const hours = time2.hour - time1.hour;\r\n  const minutes = time2.minute - time1.minute;\r\n  const seconds = time2.second - time1.second;\r\n  const milliseconds = time2.millisecond - time1.millisecond;\r\n  const microseconds = time2.microsecond - time1.microsecond;\r\n  const nanoseconds = time2.nanosecond - time1.nanosecond;\r\n  const timeDuration = TimeDuration.fromComponents(hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n  assert(timeDuration.abs().sec < 86400, '_bt_.[[Days]] should be 0');\r\n  return timeDuration;\r\n}\r\n\r\nfunction DifferenceInstant(\r\n  ns1: bigint,\r\n  ns2: bigint,\r\n  increment: number,\r\n  smallestUnit: Temporal.TimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  let timeDuration = TimeDuration.fromEpochNsDiff(ns2, ns1);\r\n  timeDuration = RoundTimeDuration(timeDuration, increment, smallestUnit, roundingMode);\r\n  return CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\r\n}\r\n\r\nfunction DifferenceISODateTime(\r\n  isoDateTime1: ISODateTime,\r\n  isoDateTime2: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit\r\n) {\r\n  AssertISODateTimeWithinLimits(isoDateTime1);\r\n  AssertISODateTimeWithinLimits(isoDateTime2);\r\n  let timeDuration = DifferenceTime(isoDateTime1.time, isoDateTime2.time);\r\n\r\n  const timeSign = timeDuration.sign();\r\n  const dateSign = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\r\n\r\n  // back-off a day from date2 so that the signs of the date and time diff match\r\n  let adjustedDate = isoDateTime2.isoDate;\r\n  if (dateSign === timeSign) {\r\n    adjustedDate = BalanceISODate(adjustedDate.year, adjustedDate.month, adjustedDate.day + timeSign);\r\n    timeDuration = timeDuration.add24HourDays(-timeSign);\r\n  }\r\n\r\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\r\n  const dateDifference = CalendarDateUntil(calendar, isoDateTime1.isoDate, adjustedDate, dateLargestUnit);\r\n  if (largestUnit !== dateLargestUnit) {\r\n    // largestUnit < days, so add the days in to the internal duration\r\n    timeDuration = timeDuration.add24HourDays(dateDifference.days);\r\n    dateDifference.days = 0;\r\n  }\r\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\r\n}\r\n\r\nfunction DifferenceZonedDateTime(\r\n  ns1: bigint,\r\n  ns2: bigint,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit\r\n) {\r\n  const nsDiff = ns2 - ns1;\r\n  if (nsDiff === ZERO) return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\r\n  const sign = nsDiff < 0n ? -1 : 1;\r\n\r\n  // Convert start/end instants to datetimes\r\n  const isoDtStart = GetISODateTimeFor(timeZone, ns1);\r\n  const isoDtEnd = GetISODateTimeFor(timeZone, ns2);\r\n\r\n  // Simulate moving ns1 as many years/months/weeks/days as possible without\r\n  // surpassing ns2. This value is stored in intermediateDateTime/intermediateInstant/intermediateNs.\r\n  // We do not literally move years/months/weeks/days with calendar arithmetic,\r\n  // but rather assume intermediateDateTime will have the same time-parts as\r\n  // dtStart and the date-parts from dtEnd, and move backward from there.\r\n  // The number of days we move backward is stored in dayCorrection.\r\n  // Credit to Adam Shaw for devising this algorithm.\r\n  let dayCorrection = 0;\r\n  let intermediateDateTime: ISODateTime | undefined;\r\n\r\n  // The max number of allowed day corrections depends on the direction of travel.\r\n  // Both directions allow for 1 day correction due to an ISO wall-clock overshoot (see below).\r\n  // Only the forward direction allows for an additional 1 day correction caused by a push-forward\r\n  // 'compatible' DST transition causing the wall-clock to overshoot again.\r\n  // This max value is inclusive.\r\n  let maxDayCorrection = sign === 1 ? 2 : 1;\r\n\r\n  // Detect ISO wall-clock overshoot.\r\n  // If the diff of the ISO wall-clock times is opposite to the overall diff's sign,\r\n  // we are guaranteed to need at least one day correction.\r\n  let timeDuration = DifferenceTime(isoDtStart.time, isoDtEnd.time);\r\n  if (timeDuration.sign() === -sign) {\r\n    dayCorrection++;\r\n  }\r\n\r\n  for (; dayCorrection <= maxDayCorrection; dayCorrection++) {\r\n    const intermediateDate = BalanceISODate(\r\n      isoDtEnd.isoDate.year,\r\n      isoDtEnd.isoDate.month,\r\n      isoDtEnd.isoDate.day - dayCorrection * sign\r\n    );\r\n\r\n    // Incorporate time parts from dtStart\r\n    intermediateDateTime = CombineISODateAndTimeRecord(intermediateDate, isoDtStart.time);\r\n\r\n    // Convert intermediate datetime to epoch-nanoseconds (may disambiguate)\r\n    const intermediateNs = GetEpochNanosecondsFor(timeZone, intermediateDateTime, 'compatible');\r\n\r\n    // Compute the nanosecond diff between the intermediate instant and the final destination\r\n    timeDuration = TimeDuration.fromEpochNsDiff(ns2, intermediateNs);\r\n\r\n    // Did intermediateNs NOT surpass ns2?\r\n    // If so, exit the loop with success (without incrementing dayCorrection past maxDayCorrection)\r\n    if (timeDuration.sign() !== -sign) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  assert(dayCorrection <= maxDayCorrection, `more than ${maxDayCorrection} day correction needed`);\r\n\r\n  // Output of the above loop\r\n  assertExists(intermediateDateTime);\r\n\r\n  // Similar to what happens in DifferenceISODateTime with date parts only:\r\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\r\n  const dateDifference = CalendarDateUntil(calendar, isoDtStart.isoDate, intermediateDateTime.isoDate, dateLargestUnit);\r\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\r\n}\r\n\r\n// Epoch-nanosecond bounding technique where the start/end of the calendar-unit\r\n// interval are converted to epoch-nanosecond times and destEpochNs is nudged to\r\n// either one.\r\nfunction NudgeToCalendarUnit(\r\n  sign: -1 | 1,\r\n  durationParam: InternalDuration,\r\n  destEpochNs: bigint,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  increment: number,\r\n  unit: Temporal.DateUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be day, week, month, or year\r\n  // timeZone may be undefined\r\n  let duration = durationParam;\r\n\r\n  // Create a duration with smallestUnit trunc'd towards zero\r\n  // Create a separate duration that incorporates roundingIncrement\r\n  let r1, r2, startDuration, endDuration;\r\n  switch (unit) {\r\n    case 'year': {\r\n      const years = RoundNumberToIncrement(duration.date.years, increment, 'trunc');\r\n      r1 = years;\r\n      r2 = years + increment * sign;\r\n      startDuration = { years: r1, months: 0, weeks: 0, days: 0 };\r\n      endDuration = { ...startDuration, years: r2 };\r\n      break;\r\n    }\r\n    case 'month': {\r\n      const months = RoundNumberToIncrement(duration.date.months, increment, 'trunc');\r\n      r1 = months;\r\n      r2 = months + increment * sign;\r\n      startDuration = AdjustDateDurationRecord(duration.date, 0, 0, r1);\r\n      endDuration = AdjustDateDurationRecord(duration.date, 0, 0, r2);\r\n      break;\r\n    }\r\n    case 'week': {\r\n      const yearsMonths = AdjustDateDurationRecord(duration.date, 0, 0);\r\n      const weeksStart = CalendarDateAdd(calendar, isoDateTime.isoDate, yearsMonths, 'constrain');\r\n      const weeksEnd = BalanceISODate(weeksStart.year, weeksStart.month, weeksStart.day + duration.date.days);\r\n      const untilResult = CalendarDateUntil(calendar, weeksStart, weeksEnd, 'week');\r\n      const weeks = RoundNumberToIncrement(duration.date.weeks + untilResult.weeks, increment, 'trunc');\r\n      r1 = weeks;\r\n      r2 = weeks + increment * sign;\r\n      startDuration = AdjustDateDurationRecord(duration.date, 0, r1);\r\n      endDuration = AdjustDateDurationRecord(duration.date, 0, r2);\r\n      break;\r\n    }\r\n    case 'day': {\r\n      const days = RoundNumberToIncrement(duration.date.days, increment, 'trunc');\r\n      r1 = days;\r\n      r2 = days + increment * sign;\r\n      startDuration = AdjustDateDurationRecord(duration.date, r1);\r\n      endDuration = AdjustDateDurationRecord(duration.date, r2);\r\n      break;\r\n    }\r\n    default:\r\n      /* c8 ignore next */ assertNotReached();\r\n  }\r\n\r\n  if (sign === 1) assert(r1 >= 0 && r1 < r2, `positive ordering of r1, r2: 0 ≤ ${r1} < ${r2}`);\r\n  if (sign === -1) assert(r1 <= 0 && r1 > r2, `negative ordering of r1, r2: 0 ≥ ${r1} > ${r2}`);\r\n\r\n  // Apply to origin, output PlainDateTimes\r\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, startDuration, 'constrain');\r\n  const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\r\n\r\n  // Convert to epoch-nanoseconds\r\n  let startEpochNs, endEpochNs;\r\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\r\n  const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\r\n  if (timeZone) {\r\n    startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\r\n    endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\r\n  } else {\r\n    startEpochNs = GetUTCEpochNanoseconds(startDateTime);\r\n    endEpochNs = GetUTCEpochNanoseconds(endDateTime);\r\n  }\r\n\r\n  // Round the smallestUnit within the epoch-nanosecond span\r\n  if (sign === 1) {\r\n    assert(\r\n      startEpochNs <= destEpochNs && destEpochNs <= endEpochNs,\r\n      `${unit} was 0 days long`\r\n    );\r\n  }\r\n  if (sign === -1) {\r\n    assert(\r\n      endEpochNs <= destEpochNs && destEpochNs <= startEpochNs,\r\n      `${unit} was 0 days long`\r\n    );\r\n  }\r\n  assert(endEpochNs !== startEpochNs, 'startEpochNs must ≠ endEpochNs');\r\n  const numerator = TimeDuration.fromEpochNsDiff(destEpochNs, startEpochNs);\r\n  const denominator = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\r\n  const unsignedRoundingMode = GetUnsignedRoundingMode(roundingMode, sign < 0 ? 'negative' : 'positive');\r\n  const cmp = numerator.add(numerator).abs().subtract(denominator.abs()).sign();\r\n  const even = (Math.abs(r1) / increment) % 2 === 0;\r\n  // prettier-ignore\r\n  const roundedUnit = numerator.isZero()\r\n    ? Math.abs(r1)\r\n    : !numerator.cmp(denominator) // equal?\r\n      ? Math.abs(r2)\r\n      : ApplyUnsignedRoundingMode(Math.abs(r1), Math.abs(r2), cmp, even, unsignedRoundingMode);\r\n\r\n  // Trick to minimize rounding error, due to the lack of fma() in JS\r\n  const fakeNumerator = new TimeDuration(\r\n    BigInt(denominator.totalNs) * BigInt(r1) + BigInt(numerator.totalNs) * BigInt(increment * sign)\r\n  );\r\n  const total = fakeNumerator.fdiv(denominator.totalNs);\r\n  assert(Math.abs(r1) <= Math.abs(total) && Math.abs(total) <= Math.abs(r2), 'r1 ≤ total ≤ r2');\r\n\r\n  // Determine whether expanded or contracted\r\n  const didExpandCalendarUnit = roundedUnit === Math.abs(r2);\r\n  duration = { date: didExpandCalendarUnit ? endDuration : startDuration, time: TimeDuration.ZERO };\r\n\r\n  const nudgeResult = {\r\n    duration,\r\n    nudgedEpochNs: didExpandCalendarUnit ? endEpochNs : startEpochNs,\r\n    didExpandCalendarUnit\r\n  };\r\n  return { nudgeResult, total };\r\n}\r\n\r\n// Attempts rounding of time units within a time zone's day, but if the rounding\r\n// causes time to exceed the total time within the day, rerun rounding in next\r\n// day.\r\nfunction NudgeToZonedTime(\r\n  sign: -1 | 1,\r\n  durationParam: InternalDuration,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  increment: number,\r\n  unit: Temporal.TimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be hour or smaller\r\n  let duration = durationParam;\r\n\r\n  // Apply to origin, output start/end of the day as PlainDateTimes\r\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, duration.date, 'constrain');\r\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\r\n  const endDate = BalanceISODate(start.year, start.month, start.day + sign);\r\n  const endDateTime = CombineISODateAndTimeRecord(endDate, isoDateTime.time);\r\n\r\n  // Compute the epoch-nanosecond start/end of the final whole-day interval\r\n  // If duration has negative sign, startEpochNs will be after endEpochNs\r\n  const startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\r\n  const endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\r\n\r\n  // The signed amount of time from the start of the whole-day interval to the end\r\n  const daySpan = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\r\n  if (daySpan.sign() !== sign) throw new RangeError('time zone returned inconsistent Instants');\r\n\r\n  // Compute time parts of the duration to nanoseconds and round\r\n  // Result could be negative\r\n  const unitIncrement = BigInt(NS_PER_TIME_UNIT[unit] * increment);\r\n  let roundedTimeDuration = duration.time.round(unitIncrement, roundingMode);\r\n\r\n  // Does the rounded time exceed the time-in-day?\r\n  const beyondDaySpan = roundedTimeDuration.subtract(daySpan);\r\n  const didRoundBeyondDay = beyondDaySpan.sign() !== -sign;\r\n\r\n  let dayDelta, nudgedEpochNs;\r\n  if (didRoundBeyondDay) {\r\n    // If rounded into next day, use the day-end as the local origin and rerun\r\n    // the rounding\r\n    dayDelta = sign;\r\n    roundedTimeDuration = beyondDaySpan.round(unitIncrement, roundingMode);\r\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(endEpochNs);\r\n  } else {\r\n    // Otherwise, if time not rounded beyond day, use the day-start as the local\r\n    // origin\r\n    dayDelta = 0;\r\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(startEpochNs);\r\n  }\r\n\r\n  const dateDuration = AdjustDateDurationRecord(duration.date, duration.date.days + dayDelta);\r\n  const resultDuration = CombineDateAndTimeDuration(dateDuration, roundedTimeDuration);\r\n  return {\r\n    duration: resultDuration,\r\n    nudgedEpochNs,\r\n    didExpandCalendarUnit: didRoundBeyondDay\r\n  };\r\n}\r\n\r\n// Converts all fields to nanoseconds and does integer rounding.\r\nfunction NudgeToDayOrTime(\r\n  durationParam: InternalDuration,\r\n  destEpochNs: bigint,\r\n  largestUnit: Temporal.DateTimeUnit,\r\n  increment: number,\r\n  smallestUnit: Temporal.TimeUnit | 'day',\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be day or smaller\r\n  let duration = durationParam;\r\n\r\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\r\n  // Convert to nanoseconds and round\r\n  const roundedTime = timeDuration.round(BigInt(increment * NS_PER_TIME_UNIT[smallestUnit]), roundingMode);\r\n  const diffTime = roundedTime.subtract(timeDuration);\r\n\r\n  // Determine if whole days expanded\r\n  const { quotient: wholeDays } = timeDuration.divmod(DAY_NANOS);\r\n  const { quotient: roundedWholeDays } = roundedTime.divmod(DAY_NANOS);\r\n  const didExpandDays = Math.sign(Number(roundedWholeDays - wholeDays)) === timeDuration.sign();\r\n\r\n  const nudgedEpochNs = diffTime.addToEpochNs(destEpochNs);\r\n\r\n  let days = 0n;\r\n  let remainder = roundedTime;\r\n  if (TemporalUnitCategory(largestUnit) === 'date') {\r\n    days = roundedWholeDays;\r\n    remainder = roundedTime.add(TimeDuration.fromComponents(-Number(roundedWholeDays * 24n), 0, 0, 0, 0, 0));\r\n  }\r\n\r\n  const dateDuration = AdjustDateDurationRecord(duration.date, Number(days));\r\n  return {\r\n    duration: { date: dateDuration, time: remainder },\r\n    nudgedEpochNs,\r\n    didExpandCalendarUnit: didExpandDays\r\n  };\r\n}\r\n\r\n// Given a potentially bottom-heavy duration, bubble up smaller units to larger\r\n// units. Any units smaller than smallestUnit are already zeroed-out.\r\nfunction BubbleRelativeDuration(\r\n  sign: -1 | 1,\r\n  durationParam: InternalDuration,\r\n  nudgedEpochNs: bigint,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateUnit,\r\n  smallestUnit: Temporal.DateUnit\r\n) {\r\n  // smallestUnit is day or larger\r\n  let duration = durationParam;\r\n\r\n  if (smallestUnit === largestUnit) return duration;\r\n\r\n  // Check to see if nudgedEpochNs has hit the boundary of any units higher than\r\n  // smallestUnit, in which case increment the higher unit and clear smaller\r\n  // units.\r\n  const largestUnitIndex = UNITS_DESCENDING.indexOf(largestUnit);\r\n  const smallestUnitIndex = UNITS_DESCENDING.indexOf(smallestUnit);\r\n  for (let unitIndex = smallestUnitIndex - 1; unitIndex >= largestUnitIndex; unitIndex--) {\r\n    // The only situation where days and smaller bubble-up into weeks is when\r\n    // largestUnit is 'week' (not to be confused with the situation where\r\n    // smallestUnit is 'week', in which case days and smaller are ROUNDED-up\r\n    // into weeks, but that has already happened by the time this function\r\n    // executes)\r\n    // So, if days and smaller are NOT bubbled-up into weeks, and the current\r\n    // unit is weeks, skip.\r\n    const unit = UNITS_DESCENDING[unitIndex];\r\n    if (unit === 'week' && largestUnit !== 'week') {\r\n      continue;\r\n    }\r\n\r\n    let endDuration;\r\n    switch (unit) {\r\n      case 'year': {\r\n        const years = duration.date.years + sign;\r\n        endDuration = { years, months: 0, weeks: 0, days: 0 };\r\n        break;\r\n      }\r\n      case 'month': {\r\n        const months = duration.date.months + sign;\r\n        endDuration = AdjustDateDurationRecord(duration.date, 0, 0, months);\r\n        break;\r\n      }\r\n      case 'week': {\r\n        const weeks = duration.date.weeks + sign;\r\n        endDuration = AdjustDateDurationRecord(duration.date, 0, weeks);\r\n        break;\r\n      }\r\n      default:\r\n        /* c8 ignore next */ assertNotReached();\r\n    }\r\n\r\n    // Compute end-of-unit in epoch-nanoseconds\r\n    const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\r\n    const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\r\n    let endEpochNs;\r\n    if (timeZone) {\r\n      endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\r\n    } else {\r\n      endEpochNs = GetUTCEpochNanoseconds(endDateTime);\r\n    }\r\n\r\n    const didExpandToEnd = compare(nudgedEpochNs, endEpochNs) !== -sign;\r\n\r\n    // Is nudgedEpochNs at the end-of-unit? This means it should bubble-up to\r\n    // the next highest unit (and possibly further...)\r\n    if (didExpandToEnd) {\r\n      duration = { date: endDuration, time: TimeDuration.ZERO };\r\n    } else {\r\n      // NOT at end-of-unit. Stop looking for bubbling\r\n      break;\r\n    }\r\n  }\r\n\r\n  return duration;\r\n}\r\n\r\nfunction RoundRelativeDuration(\r\n  durationParam: InternalDuration,\r\n  destEpochNs: bigint,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnitParam: Temporal.DateTimeUnit,\r\n  increment: number,\r\n  smallestUnit: Temporal.DateTimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  let duration = durationParam;\r\n  // The duration must already be balanced. This should be achieved by calling\r\n  // one of the non-rounding since/until internal methods prior. It's okay to\r\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\r\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\r\n  // >24 hours in its timezone. (should automatically end up like this if using\r\n  // non-rounding since/until internal methods prior)\r\n  const irregularLengthUnit = IsCalendarUnit(smallestUnit) || (timeZone && smallestUnit === 'day');\r\n  const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\r\n\r\n  let nudgeResult;\r\n  if (irregularLengthUnit) {\r\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\r\n    ({ nudgeResult } = NudgeToCalendarUnit(\r\n      sign,\r\n      duration,\r\n      destEpochNs,\r\n      isoDateTime,\r\n      timeZone,\r\n      calendar,\r\n      increment,\r\n      smallestUnit,\r\n      roundingMode\r\n    ));\r\n  } else if (timeZone) {\r\n    // Special-case for rounding time units within a zoned day\r\n    uncheckedAssertNarrowedType<Temporal.TimeUnit>(\r\n      smallestUnit,\r\n      'other values handled in irregularLengthUnit clause above'\r\n    );\r\n    nudgeResult = NudgeToZonedTime(\r\n      sign,\r\n      duration,\r\n      isoDateTime,\r\n      timeZone,\r\n      calendar,\r\n      increment,\r\n      smallestUnit,\r\n      roundingMode\r\n    );\r\n  } else {\r\n    // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\r\n    // math. years/months/weeks unchanged\r\n    nudgeResult = NudgeToDayOrTime(duration, destEpochNs, largestUnitParam, increment, smallestUnit, roundingMode);\r\n  }\r\n\r\n  duration = nudgeResult.duration;\r\n  // Did nudging cause the duration to expand to the next day or larger?\r\n  // Bubble-up smaller calendar units into higher ones, except for weeks, which\r\n  // don't balance up into months\r\n  if (nudgeResult.didExpandCalendarUnit && smallestUnit !== 'week') {\r\n    uncheckedAssertNarrowedType<Temporal.DateUnit>(\r\n      largestUnitParam,\r\n      'if we expanded to a calendar unit, then largestUnit is a calendar unit'\r\n    );\r\n    duration = BubbleRelativeDuration(\r\n      sign,\r\n      duration,\r\n      nudgeResult.nudgedEpochNs, // The destEpochNs after expanding/contracting\r\n      isoDateTime,\r\n      timeZone,\r\n      calendar,\r\n      largestUnitParam, // where to STOP bubbling\r\n      LargerOfTwoTemporalUnits(smallestUnit, 'day') as Temporal.DateUnit // where to START bubbling-up from\r\n    );\r\n  }\r\n\r\n  return duration;\r\n}\r\n\r\nfunction TotalRelativeDuration(\r\n  duration: InternalDuration,\r\n  destEpochNs: bigint,\r\n  isoDateTime: ISODateTime,\r\n  timeZone: string | null,\r\n  calendar: BuiltinCalendarId,\r\n  unit: Temporal.DateTimeUnit\r\n) {\r\n  // The duration must already be balanced. This should be achieved by calling\r\n  // one of the non-rounding since/until internal methods prior. It's okay to\r\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\r\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\r\n  // >24 hours in its timezone. (should automatically end up like this if using\r\n  // non-rounding since/until internal methods prior)\r\n  if (IsCalendarUnit(unit) || (timeZone && unit === 'day')) {\r\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\r\n    const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\r\n    return NudgeToCalendarUnit(sign, duration, destEpochNs, isoDateTime, timeZone, calendar, 1, unit, 'trunc').total;\r\n  }\r\n  // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\r\n  // math. years/months/weeks unchanged\r\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\r\n  return TotalTimeDuration(timeDuration, unit);\r\n}\r\n\r\nexport function DifferencePlainDateTimeWithRounding(\r\n  isoDateTime1: ISODateTime,\r\n  isoDateTime2: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit,\r\n  roundingIncrement: number,\r\n  smallestUnit: Temporal.DateTimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) {\r\n    return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\r\n  }\r\n\r\n  RejectDateTimeRange(isoDateTime1);\r\n  RejectDateTimeRange(isoDateTime2);\r\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, largestUnit);\r\n\r\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\r\n\r\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\r\n  return RoundRelativeDuration(\r\n    duration,\r\n    destEpochNs,\r\n    isoDateTime1,\r\n    null,\r\n    calendar,\r\n    largestUnit,\r\n    roundingIncrement,\r\n    smallestUnit,\r\n    roundingMode\r\n  );\r\n}\r\n\r\nexport function DifferencePlainDateTimeWithTotal(\r\n  isoDateTime1: ISODateTime,\r\n  isoDateTime2: ISODateTime,\r\n  calendar: BuiltinCalendarId,\r\n  unit: Temporal.DateTimeUnit\r\n) {\r\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) return 0;\r\n\r\n  RejectDateTimeRange(isoDateTime1);\r\n  RejectDateTimeRange(isoDateTime2);\r\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, unit);\r\n\r\n  if (unit === 'nanosecond') return duration.time.totalNs;\r\n\r\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\r\n  return TotalRelativeDuration(duration, destEpochNs, isoDateTime1, null, calendar, unit);\r\n}\r\n\r\nexport function DifferenceZonedDateTimeWithRounding(\r\n  ns1: bigint,\r\n  ns2: bigint,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  largestUnit: Temporal.DateTimeUnit,\r\n  roundingIncrement: number,\r\n  smallestUnit: Temporal.DateTimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  if (TemporalUnitCategory(largestUnit) === 'time') {\r\n    // The user is only asking for a time difference, so return difference of instants.\r\n    return DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit as Temporal.TimeUnit, roundingMode);\r\n  }\r\n\r\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit);\r\n\r\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\r\n\r\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\r\n  return RoundRelativeDuration(\r\n    duration,\r\n    ns2,\r\n    dateTime,\r\n    timeZone,\r\n    calendar,\r\n    largestUnit,\r\n    roundingIncrement,\r\n    smallestUnit,\r\n    roundingMode\r\n  );\r\n}\r\n\r\nexport function DifferenceZonedDateTimeWithTotal(\r\n  ns1: bigint,\r\n  ns2: bigint,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  unit: Temporal.DateTimeUnit\r\n) {\r\n  if (TemporalUnitCategory(unit) === 'time') {\r\n    // The user is only asking for a time difference, so return difference of instants.\r\n    return TotalTimeDuration(TimeDuration.fromEpochNsDiff(ns2, ns1), unit as Temporal.TimeUnit);\r\n  }\r\n\r\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, unit);\r\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\r\n  return TotalRelativeDuration(duration, ns2, dateTime, timeZone, calendar, unit);\r\n}\r\n\r\ntype DifferenceOperation = 'since' | 'until';\r\n\r\nfunction GetDifferenceSettings<T extends Temporal.DateTimeUnit>(\r\n  op: DifferenceOperation,\r\n  options: Temporal.DifferenceOptions<T>,\r\n  group: 'datetime' | 'date' | 'time',\r\n  disallowed: (Temporal.DateTimeUnit | 'auto')[],\r\n  fallbackSmallest: T,\r\n  smallestLargestDefaultUnit: T\r\n) {\r\n  const ALLOWED_UNITS = TEMPORAL_UNITS.reduce((allowed, unitInfo) => {\r\n    const p = unitInfo[0];\r\n    const s = unitInfo[1];\r\n    const c = unitInfo[2];\r\n    if ((group === 'datetime' || c === group) && !disallowed.includes(s)) {\r\n      allowed.push(s, p);\r\n    }\r\n    return allowed;\r\n  }, [] as (Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit>)[]);\r\n\r\n  let largestUnit = GetTemporalUnitValuedOption(options, 'largestUnit', group, 'auto');\r\n  if (disallowed.includes(largestUnit)) {\r\n    throw new RangeError(`largestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${largestUnit}`);\r\n  }\r\n\r\n  const roundingIncrement = GetTemporalRoundingIncrementOption(options);\r\n\r\n  let roundingMode = GetRoundingModeOption(options, 'trunc');\r\n  if (op === 'since') roundingMode = NegateRoundingMode(roundingMode);\r\n\r\n  const smallestUnit = GetTemporalUnitValuedOption(options, 'smallestUnit', group, fallbackSmallest);\r\n  if (disallowed.includes(smallestUnit)) {\r\n    throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\r\n  }\r\n\r\n  const defaultLargestUnit = LargerOfTwoTemporalUnits(smallestLargestDefaultUnit, smallestUnit);\r\n  if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\r\n  if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\r\n    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\r\n  }\r\n  const MAX_DIFFERENCE_INCREMENTS: { [k in Temporal.DateTimeUnit]?: number } = {\r\n    hour: 24,\r\n    minute: 60,\r\n    second: 60,\r\n    millisecond: 1000,\r\n    microsecond: 1000,\r\n    nanosecond: 1000\r\n  };\r\n  const maximum = MAX_DIFFERENCE_INCREMENTS[smallestUnit];\r\n  if (maximum !== undefined) ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\r\n\r\n  return { largestUnit: largestUnit as T, roundingIncrement, roundingMode, smallestUnit: smallestUnit as T };\r\n}\r\n\r\nexport function DifferenceTemporalInstant(\r\n  operation: DifferenceOperation,\r\n  instant: Temporal.Instant,\r\n  otherParam: InstantParams['until'][0],\r\n  options: InstantParams['until'][1]\r\n) {\r\n  const other = ToTemporalInstant(otherParam);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'second');\r\n\r\n  const onens = GetSlot(instant, EPOCHNANOSECONDS);\r\n  const twons = GetSlot(other, EPOCHNANOSECONDS);\r\n  const duration = DifferenceInstant(\r\n    onens,\r\n    twons,\r\n    settings.roundingIncrement,\r\n    settings.smallestUnit,\r\n    settings.roundingMode\r\n  );\r\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainDate(\r\n  operation: DifferenceOperation,\r\n  plainDate: Temporal.PlainDate,\r\n  otherParam: PlainDateParams['until'][0],\r\n  options: PlainDateParams['until'][1]\r\n) {\r\n  const other = ToTemporalDate(otherParam);\r\n  const calendar = GetSlot(plainDate, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', [], 'day', 'day');\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n  const isoDate = GetSlot(plainDate, ISO_DATE);\r\n  const isoOther = GetSlot(other, ISO_DATE);\r\n  if (CompareISODate(isoDate, isoOther) === 0) return new Duration();\r\n\r\n  const dateDifference = CalendarDateUntil(calendar, isoDate, isoOther, settings.largestUnit);\r\n\r\n  let duration = { date: dateDifference, time: TimeDuration.ZERO };\r\n  const roundingIsNoop = settings.smallestUnit === 'day' && settings.roundingIncrement === 1;\r\n  if (!roundingIsNoop) {\r\n    const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\r\n    const isoDateTimeOther = CombineISODateAndTimeRecord(isoOther, MidnightTimeRecord());\r\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\r\n    duration = RoundRelativeDuration(\r\n      duration,\r\n      destEpochNs,\r\n      isoDateTime,\r\n      null,\r\n      calendar,\r\n      settings.largestUnit,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit,\r\n      settings.roundingMode\r\n    );\r\n  }\r\n\r\n  let result = TemporalDurationFromInternal(duration, 'day');\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainDateTime(\r\n  operation: DifferenceOperation,\r\n  plainDateTime: Temporal.PlainDateTime,\r\n  otherParam: PlainDateTimeParams['until'][0],\r\n  options: PlainDateTimeParams['until'][1]\r\n) {\r\n  const other = ToTemporalDateTime(otherParam);\r\n  const calendar = GetSlot(plainDateTime, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'day');\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n  const isoDateTime1 = GetSlot(plainDateTime, ISO_DATE_TIME);\r\n  const isoDateTime2 = GetSlot(other, ISO_DATE_TIME);\r\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) === 0) return new Duration();\r\n\r\n  const duration = DifferencePlainDateTimeWithRounding(\r\n    isoDateTime1,\r\n    isoDateTime2,\r\n    calendar,\r\n    settings.largestUnit,\r\n    settings.roundingIncrement,\r\n    settings.smallestUnit,\r\n    settings.roundingMode\r\n  );\r\n\r\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainTime(\r\n  operation: DifferenceOperation,\r\n  plainTime: Temporal.PlainTime,\r\n  otherParam: PlainTimeParams['until'][0],\r\n  options: PlainTimeParams['until'][1]\r\n) {\r\n  const other = ToTemporalTime(otherParam);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'hour');\r\n\r\n  let timeDuration = DifferenceTime(GetSlot(plainTime, TIME), GetSlot(other, TIME));\r\n  timeDuration = RoundTimeDuration(\r\n    timeDuration,\r\n    settings.roundingIncrement,\r\n    settings.smallestUnit,\r\n    settings.roundingMode\r\n  );\r\n  const duration = CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\r\n\r\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalPlainYearMonth(\r\n  operation: DifferenceOperation,\r\n  yearMonth: Temporal.PlainYearMonth,\r\n  otherParam: PlainYearMonthParams['until'][0],\r\n  options: PlainYearMonthParams['until'][1]\r\n) {\r\n  const other = ToTemporalYearMonth(otherParam);\r\n  const calendar = GetSlot(yearMonth, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between months of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', ['week', 'day'], 'month', 'year');\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n  if (CompareISODate(GetSlot(yearMonth, ISO_DATE), GetSlot(other, ISO_DATE)) == 0) {\r\n    return new Duration();\r\n  }\r\n\r\n  const thisFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\r\n  thisFields.day = 1;\r\n  const thisDate = CalendarDateFromFields(calendar, thisFields, 'constrain');\r\n  const otherFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(other, ISO_DATE), 'year-month');\r\n  otherFields.day = 1;\r\n  const otherDate = CalendarDateFromFields(calendar, otherFields, 'constrain');\r\n\r\n  const dateDifference = CalendarDateUntil(calendar, thisDate, otherDate, settings.largestUnit);\r\n  let duration = { date: AdjustDateDurationRecord(dateDifference, 0, 0), time: TimeDuration.ZERO };\r\n  if (settings.smallestUnit !== 'month' || settings.roundingIncrement !== 1) {\r\n    const isoDateTime = CombineISODateAndTimeRecord(thisDate, MidnightTimeRecord());\r\n    const isoDateTimeOther = CombineISODateAndTimeRecord(otherDate, MidnightTimeRecord());\r\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\r\n    duration = RoundRelativeDuration(\r\n      duration,\r\n      destEpochNs,\r\n      isoDateTime,\r\n      null,\r\n      calendar,\r\n      settings.largestUnit,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit,\r\n      settings.roundingMode\r\n    );\r\n  }\r\n\r\n  let result = TemporalDurationFromInternal(duration, 'day');\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function DifferenceTemporalZonedDateTime(\r\n  operation: DifferenceOperation,\r\n  zonedDateTime: Temporal.ZonedDateTime,\r\n  otherParam: ZonedDateTimeParams['until'][0],\r\n  options: ZonedDateTimeParams['until'][1]\r\n) {\r\n  const other = ToTemporalZonedDateTime(otherParam);\r\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\r\n  const otherCalendar = GetSlot(other, CALENDAR);\r\n  if (!CalendarEquals(calendar, otherCalendar)) {\r\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\r\n  }\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'hour');\r\n\r\n  const ns1 = GetSlot(zonedDateTime, EPOCHNANOSECONDS);\r\n  const ns2 = GetSlot(other, EPOCHNANOSECONDS);\r\n\r\n  const Duration = GetIntrinsic('%Temporal.Duration%');\r\n\r\n  let result;\r\n  if (TemporalUnitCategory(settings.largestUnit) !== 'date') {\r\n    // The user is only asking for a time difference, so return difference of instants.\r\n    const duration = DifferenceInstant(\r\n      ns1,\r\n      ns2,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit as Temporal.TimeUnit,\r\n      settings.roundingMode\r\n    );\r\n    result = TemporalDurationFromInternal(duration, settings.largestUnit);\r\n  } else {\r\n    const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\r\n    if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\r\n      throw new RangeError(\r\n        \"When calculating difference between time zones, largestUnit must be 'hours' \" +\r\n          'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.'\r\n      );\r\n    }\r\n\r\n    if (ns1 === ns2) return new Duration();\r\n\r\n    const duration = DifferenceZonedDateTimeWithRounding(\r\n      ns1,\r\n      ns2,\r\n      timeZone,\r\n      calendar,\r\n      settings.largestUnit,\r\n      settings.roundingIncrement,\r\n      settings.smallestUnit,\r\n      settings.roundingMode\r\n    );\r\n    result = TemporalDurationFromInternal(duration, 'hour');\r\n  }\r\n\r\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\r\n  return result;\r\n}\r\n\r\nexport function AddTime(\r\n  { hour, minute, second: secondParam, millisecond, microsecond, nanosecond: nanosecondParam }: TimeRecord,\r\n  timeDuration: TimeDuration\r\n) {\r\n  let second = secondParam;\r\n  let nanosecond = nanosecondParam;\r\n\r\n  second += timeDuration.sec;\r\n  nanosecond += timeDuration.subsec;\r\n  return BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n}\r\n\r\nfunction AddInstant(epochNanoseconds: bigint, timeDuration: TimeDuration) {\r\n  const result = timeDuration.addToEpochNs(epochNanoseconds);\r\n  ValidateEpochNanoseconds(result);\r\n  return result;\r\n}\r\n\r\nexport function AddZonedDateTime(\r\n  epochNs: bigint,\r\n  timeZone: string,\r\n  calendar: BuiltinCalendarId,\r\n  duration: InternalDuration,\r\n  overflow: Overflow = 'constrain'\r\n) {\r\n  // If only time is to be added, then use Instant math. It's not OK to fall\r\n  // through to the date/time code below because compatible disambiguation in\r\n  // the PlainDateTime=>Instant conversion will change the offset of any\r\n  // ZonedDateTime in the repeated clock time after a backwards transition.\r\n  // When adding/subtracting time units and not dates, this disambiguation is\r\n  // not expected and so is avoided below via a fast path for time-only\r\n  // arithmetic.\r\n  // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\r\n  if (DateDurationSign(duration.date) === 0) return AddInstant(epochNs, duration.time);\r\n\r\n  // RFC 5545 requires the date portion to be added in calendar days and the\r\n  // time portion to be added in exact time.\r\n  const dt = GetISODateTimeFor(timeZone, epochNs);\r\n  const addedDate = CalendarDateAdd(calendar, dt.isoDate, duration.date, overflow);\r\n  const dtIntermediate = CombineISODateAndTimeRecord(addedDate, dt.time);\r\n\r\n  // Note that 'compatible' is used below because this disambiguation behavior\r\n  // is required by RFC 5545.\r\n  const intermediateNs = GetEpochNanosecondsFor(timeZone, dtIntermediate, 'compatible');\r\n  return AddInstant(intermediateNs, duration.time);\r\n}\r\n\r\ntype AddSubtractOperation = 'add' | 'subtract';\r\n\r\nexport function AddDurations(\r\n  operation: AddSubtractOperation,\r\n  duration: Temporal.Duration,\r\n  otherParam: DurationParams['add'][0]\r\n) {\r\n  let other = ToTemporalDuration(otherParam);\r\n  if (operation === 'subtract') other = CreateNegatedTemporalDuration(other);\r\n\r\n  const largestUnit1 = DefaultTemporalLargestUnit(duration);\r\n  const largestUnit2 = DefaultTemporalLargestUnit(other);\r\n  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\r\n  if (IsCalendarUnit(largestUnit)) {\r\n    throw new RangeError('For years, months, or weeks arithmetic, use date arithmetic relative to a starting point');\r\n  }\r\n\r\n  const d1 = ToInternalDurationRecordWith24HourDays(duration);\r\n  const d2 = ToInternalDurationRecordWith24HourDays(other);\r\n  const result = CombineDateAndTimeDuration(ZeroDateDuration(), d1.time.add(d2.time));\r\n  return TemporalDurationFromInternal(result, largestUnit);\r\n}\r\n\r\nexport function AddDurationToInstant(\r\n  operation: AddSubtractOperation,\r\n  instant: Temporal.Instant,\r\n  durationLike: InstantParams['add'][0]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const largestUnit = DefaultTemporalLargestUnit(duration);\r\n  if (TemporalUnitCategory(largestUnit) === 'date') {\r\n    throw new RangeError(\r\n      `Duration field ${largestUnit} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`\r\n    );\r\n  }\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n  const ns = AddInstant(GetSlot(instant, EPOCHNANOSECONDS), internalDuration.time);\r\n  return CreateTemporalInstant(ns);\r\n}\r\n\r\nexport function AddDurationToDate(\r\n  operation: AddSubtractOperation,\r\n  plainDate: Temporal.PlainDate,\r\n  durationLike: PlainDateParams['add'][0],\r\n  options: PlainDateParams['add'][1]\r\n) {\r\n  const calendar = GetSlot(plainDate, CALENDAR);\r\n\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const dateDuration = ToDateDurationRecordWithoutTime(duration);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n\r\n  const addedDate = CalendarDateAdd(calendar, GetSlot(plainDate, ISO_DATE), dateDuration, overflow);\r\n  return CreateTemporalDate(addedDate, calendar);\r\n}\r\n\r\nexport function AddDurationToDateTime(\r\n  operation: AddSubtractOperation,\r\n  dateTime: Temporal.PlainDateTime,\r\n  durationLike: PlainDateTimeParams['add'][0],\r\n  options: PlainDateTimeParams['add'][1]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n\r\n  const calendar = GetSlot(dateTime, CALENDAR);\r\n\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n\r\n  // Add the time part\r\n  const isoDateTime = GetSlot(dateTime, ISO_DATE_TIME);\r\n  const timeResult = AddTime(isoDateTime.time, internalDuration.time);\r\n  const dateDuration = AdjustDateDurationRecord(internalDuration.date, timeResult.deltaDays);\r\n\r\n  // Delegate the date part addition to the calendar\r\n  RejectDuration(dateDuration.years, dateDuration.months, dateDuration.weeks, dateDuration.days, 0, 0, 0, 0, 0, 0);\r\n  const addedDate = CalendarDateAdd(calendar, isoDateTime.isoDate, dateDuration, overflow);\r\n\r\n  const result = CombineISODateAndTimeRecord(addedDate, timeResult);\r\n  return CreateTemporalDateTime(result, calendar);\r\n}\r\n\r\nexport function AddDurationToTime(\r\n  operation: AddSubtractOperation,\r\n  temporalTime: Temporal.PlainTime,\r\n  durationLike: PlainTimeParams['add'][0]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\r\n  const { hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\r\n    GetSlot(temporalTime, TIME),\r\n    internalDuration.time\r\n  );\r\n  const time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject');\r\n  return CreateTemporalTime(time);\r\n}\r\n\r\nexport function AddDurationToYearMonth(\r\n  operation: AddSubtractOperation,\r\n  yearMonth: Temporal.PlainYearMonth,\r\n  durationLike: PlainYearMonthParams['add'][0],\r\n  options: PlainYearMonthParams['add'][1]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n  const sign = DurationSign(duration);\r\n\r\n  const calendar = GetSlot(yearMonth, CALENDAR);\r\n  const fields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\r\n  fields.day = 1;\r\n  let startDate = CalendarDateFromFields(calendar, fields, 'constrain');\r\n  if (sign < 0) {\r\n    const nextMonth = CalendarDateAdd(calendar, startDate, { months: 1 }, 'constrain');\r\n    startDate = BalanceISODate(nextMonth.year, nextMonth.month, nextMonth.day - 1);\r\n  }\r\n  const durationToAdd = ToDateDurationRecordWithoutTime(duration);\r\n  RejectDateRange(startDate);\r\n  const addedDate = CalendarDateAdd(calendar, startDate, durationToAdd, overflow);\r\n  const addedDateFields = ISODateToFields(calendar, addedDate, 'year-month');\r\n\r\n  const isoDate = CalendarYearMonthFromFields(calendar, addedDateFields, overflow);\r\n  return CreateTemporalYearMonth(isoDate, calendar);\r\n}\r\n\r\nexport function AddDurationToZonedDateTime(\r\n  operation: AddSubtractOperation,\r\n  zonedDateTime: Temporal.ZonedDateTime,\r\n  durationLike: ZonedDateTimeParams['add'][0],\r\n  options: ZonedDateTimeParams['add'][1]\r\n) {\r\n  let duration = ToTemporalDuration(durationLike);\r\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\r\n\r\n  const resolvedOptions = GetOptionsObject(options);\r\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\r\n  const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\r\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\r\n  const internalDuration = ToInternalDurationRecord(duration);\r\n  const epochNanoseconds = AddZonedDateTime(\r\n    GetSlot(zonedDateTime, EPOCHNANOSECONDS),\r\n    timeZone,\r\n    calendar,\r\n    internalDuration,\r\n    overflow\r\n  );\r\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function RoundNumberToIncrement(quantity: number, increment: number, mode: Temporal.RoundingMode) {\r\n  const quotient = Math.trunc(quantity / increment);\r\n  const remainder = quantity % increment;\r\n  const sign = quantity < 0 ? 'negative' : 'positive';\r\n  const r1 = Math.abs(quotient);\r\n  const r2 = r1 + 1;\r\n  const cmp = ComparisonResult(Math.abs(remainder * 2) - increment);\r\n  const even = r1 % 2 === 0;\r\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\r\n  const rounded = remainder === 0 ? r1 : ApplyUnsignedRoundingMode(r1, r2, cmp, even, unsignedRoundingMode);\r\n  return increment * (sign === 'positive' ? rounded : -rounded);\r\n}\r\n\r\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\r\nexport function RoundNumberToIncrementAsIfPositive(\r\n  quantityParam: bigint,\r\n  incrementParam: bigint,\r\n  mode: Temporal.RoundingMode\r\n) {\r\n  const quantity = quantityParam;\r\n  const increment = incrementParam;\r\n  const quotient = quantity / increment;\r\n  const remainder = quantity % increment;\r\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, 'positive');\r\n  let r1: bigint, r2: bigint;\r\n  if (quantity < 0) {\r\n    r1 = quotient - ONE;\r\n    r2 = quotient;\r\n  } else {\r\n    r1 = quotient;\r\n    r2 = quotient + ONE;\r\n  }\r\n  // Similar to the comparison in RoundNumberToIncrement, but multiplied by an\r\n  // extra sign to make sure we treat it as positive\r\n  const cmp = (compare(abs(remainder * TWO), increment) * (quantity < 0 ? -1 : 1) +\r\n    0) as -1 | 0 | 1;\r\n  const rounded = remainder === ZERO\r\n    ? quotient\r\n    : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(r1), unsignedRoundingMode);\r\n  return rounded * increment;\r\n}\r\n\r\nexport function RoundTemporalInstant(\r\n  epochNs: bigint,\r\n  increment: number,\r\n  unit: TimeUnitOrDay,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  const incrementNs = NS_PER_TIME_UNIT[unit] * increment;\r\n  return RoundNumberToIncrementAsIfPositive(epochNs, BigInt(incrementNs), roundingMode);\r\n}\r\n\r\nexport function RoundISODateTime(\r\n  isoDateTime: ISODateTime,\r\n  increment: number,\r\n  unit: UnitSmallerThanOrEqualTo<'day'>,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  AssertISODateTimeWithinLimits(isoDateTime);\r\n  const { year, month, day } = isoDateTime.isoDate;\r\n  const time = RoundTime(isoDateTime.time, increment, unit, roundingMode);\r\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\r\n  return CombineISODateAndTimeRecord(isoDate, time);\r\n}\r\n\r\nexport function RoundTime(\r\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\r\n  increment: number,\r\n  unit: TimeUnitOrDay,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  let quantity;\r\n  switch (unit) {\r\n    case 'day':\r\n    case 'hour':\r\n      quantity = ((((hour * 60 + minute) * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'minute':\r\n      quantity = (((minute * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'second':\r\n      quantity = ((second * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'millisecond':\r\n      quantity = (millisecond * 1000 + microsecond) * 1000 + nanosecond;\r\n      break;\r\n    case 'microsecond':\r\n      quantity = microsecond * 1000 + nanosecond;\r\n      break;\r\n    case 'nanosecond':\r\n      quantity = nanosecond;\r\n  }\r\n  const nsPerUnit = NS_PER_TIME_UNIT[unit];\r\n  const result = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode) / nsPerUnit;\r\n  switch (unit) {\r\n    case 'day':\r\n      return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\r\n    case 'hour':\r\n      return BalanceTime(result, 0, 0, 0, 0, 0);\r\n    case 'minute':\r\n      return BalanceTime(hour, result, 0, 0, 0, 0);\r\n    case 'second':\r\n      return BalanceTime(hour, minute, result, 0, 0, 0);\r\n    case 'millisecond':\r\n      return BalanceTime(hour, minute, second, result, 0, 0);\r\n    case 'microsecond':\r\n      return BalanceTime(hour, minute, second, millisecond, result, 0);\r\n    case 'nanosecond':\r\n      return BalanceTime(hour, minute, second, millisecond, microsecond, result);\r\n    default:\r\n      throw new Error(`Invalid unit ${unit}`);\r\n  }\r\n}\r\n\r\nexport function RoundTimeDuration(\r\n  timeDuration: TimeDuration,\r\n  increment: number,\r\n  unit: Temporal.TimeUnit,\r\n  roundingMode: Temporal.RoundingMode\r\n) {\r\n  // unit must be a time unit\r\n  const divisor = NS_PER_TIME_UNIT[unit];\r\n  return timeDuration.round(BigInt(divisor * increment), roundingMode);\r\n}\r\n\r\nexport function TotalTimeDuration(timeDuration: TimeDuration, unit: TimeUnitOrDay) {\r\n  const divisor = NS_PER_TIME_UNIT[unit];\r\n  return timeDuration.fdiv(BigInt(divisor));\r\n}\r\n\r\nexport function CompareISODate(isoDate1: ISODate, isoDate2: ISODate) {\r\n  if (isoDate1.year !== isoDate2.year) return ComparisonResult(isoDate1.year - isoDate2.year);\r\n  if (isoDate1.month !== isoDate2.month) return ComparisonResult(isoDate1.month - isoDate2.month);\r\n  if (isoDate1.day !== isoDate2.day) return ComparisonResult(isoDate1.day - isoDate2.day);\r\n  return 0;\r\n}\r\n\r\nexport function CompareTimeRecord(time1: TimeRecord, time2: TimeRecord) {\r\n  if (time1.hour !== time2.hour) return ComparisonResult(time1.hour - time2.hour);\r\n  if (time1.minute !== time2.minute) return ComparisonResult(time1.minute - time2.minute);\r\n  if (time1.second !== time2.second) return ComparisonResult(time1.second - time2.second);\r\n  if (time1.millisecond !== time2.millisecond) return ComparisonResult(time1.millisecond - time2.millisecond);\r\n  if (time1.microsecond !== time2.microsecond) return ComparisonResult(time1.microsecond - time2.microsecond);\r\n  if (time1.nanosecond !== time2.nanosecond) return ComparisonResult(time1.nanosecond - time2.nanosecond);\r\n  return 0;\r\n}\r\n\r\nexport function CompareISODateTime(isoDateTime1: ISODateTime, isoDateTime2: ISODateTime) {\r\n  const dateResult = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\r\n  if (dateResult !== 0) return dateResult;\r\n  return CompareTimeRecord(isoDateTime1.time, isoDateTime2.time);\r\n}\r\n\r\n// Defaults to native bigint, or something \"native bigint-like\".\r\n// For users of Temporal that are running in environments without native BigInt,\r\n// the only guarantee we should give is that the returned object's toString will\r\n// return a string containing an accurate base 10 value of this bigint. This\r\n// form factor should correctly interop with other bigint compat libraries\r\n// easily.\r\ntype ExternalBigInt = bigint;\r\n\r\nexport function ToBigIntExternal(arg: unknown): ExternalBigInt {\r\n  const jsbiBI = BigInt(arg as string | number | bigint | boolean);\r\n  if (typeof (globalThis as any).BigInt !== 'undefined') return (globalThis as any).BigInt(jsbiBI.toString(10));\r\n  return jsbiBI as unknown as ExternalBigInt;\r\n}\r\n\r\n// rounding modes supported: floor, ceil, trunc\r\nexport function epochNsToMs(epochNanosecondsParam: bigint, mode: 'floor' | 'ceil' | 'trunc'): number {\r\n  const epochNanoseconds = epochNanosecondsParam;\r\n  const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\r\n  let epochMilliseconds = ToNumber(quotient);\r\n  if (mode === 'floor' && remainder < 0) epochMilliseconds -= 1;\r\n  if (mode === 'ceil' && remainder > 0) epochMilliseconds += 1;\r\n  return epochMilliseconds;\r\n}\r\n\r\nexport function epochMsToNs(epochMilliseconds: number): bigint {\r\n  if (!Number.isInteger(epochMilliseconds)) throw new RangeError('epoch milliseconds must be an integer');\r\n  return BigInt(epochMilliseconds) * MILLION;\r\n}\r\n\r\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\r\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\r\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\r\nexport const SystemUTCEpochNanoSeconds: () => bigint = (() => {\r\n  let ns = BigInt(Date.now() % 1e6);\r\n  return () => {\r\n    const now = Date.now();\r\n    const ms = BigInt(now);\r\n    const result = epochMsToNs(now) + ns;\r\n    ns = ms % MILLION;\r\n    if (result > NS_MAX) return NS_MAX;\r\n    if (result < NS_MIN) return NS_MIN;\r\n    return result;\r\n  };\r\n})();\r\n\r\nexport function DefaultTimeZone() {\r\n  return new Intl.DateTimeFormat().resolvedOptions().timeZone;\r\n}\r\n\r\nexport function ComparisonResult(value: number) {\r\n  return value < 0 ? -1 : value > 0 ? 1 : (value as 0);\r\n}\r\n\r\nexport function GetOptionsObject<T>(options: T) {\r\n  if (options === undefined) return Object.create(null) as NonNullable<T>;\r\n  if (IsObject(options) && options !== null) return options;\r\n  throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\r\n}\r\n\r\nexport function CreateOnePropObject<K extends string, V>(propName: K, propValue: V): { [k in K]: V } {\r\n  const o = Object.create(null);\r\n  o[propName] = propValue;\r\n  return o;\r\n}\r\n\r\ntype StringlyTypedKeys<T> = Exclude<keyof T, symbol | number>;\r\nfunction GetOption<P extends StringlyTypedKeys<O>, O extends Partial<Record<P, unknown>>>(\r\n  options: O,\r\n  property: P,\r\n  allowedValues: ReadonlyArray<O[P]>,\r\n  fallback: undefined\r\n): O[P];\r\nfunction GetOption<\r\n  P extends StringlyTypedKeys<O>,\r\n  O extends Partial<Record<P, unknown>>,\r\n  Fallback extends Required<O>[P] | typeof REQUIRED | undefined\r\n>(\r\n  options: O,\r\n  property: P,\r\n  allowedValues: ReadonlyArray<O[P]>,\r\n  fallback: Fallback\r\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P];\r\nfunction GetOption<\r\n  P extends StringlyTypedKeys<O>,\r\n  O extends Partial<Record<P, unknown>>,\r\n  Fallback extends Required<O>[P] | undefined\r\n>(\r\n  options: O,\r\n  property: P,\r\n  allowedValues: ReadonlyArray<O[P]>,\r\n  fallback: O[P]\r\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P] {\r\n  let value = options[property];\r\n  if (value !== undefined) {\r\n    value = ToString(value) as O[P];\r\n    if (!allowedValues.includes(value)) {\r\n      throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\r\n    }\r\n    return value;\r\n  }\r\n  if (fallback === REQUIRED) throw new RangeError(`${property} option is required`);\r\n  return fallback;\r\n}\r\n\r\n// This is a temporary implementation. Ideally we'd rely on Intl.DateTimeFormat\r\n// here, to provide the latest CLDR alias data, when implementations catch up to\r\n// the ECMA-402 change. The aliases below are taken from\r\n// https://github.com/unicode-org/cldr/blob/main/common/bcp47/calendar.xml\r\nexport function CanonicalizeCalendar(idParam: string): BuiltinCalendarId {\r\n  const id = ASCIILowercase(idParam);\r\n\r\n  if (!BUILTIN_CALENDAR_IDS.includes(ASCIILowercase(id))) {\r\n    throw new RangeError(`invalid calendar identifier ${id}`);\r\n  }\r\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(id, 'above code throws out any non-calendar IDs');\r\n\r\n  switch (id) {\r\n    case 'ethiopic-amete-alem':\r\n      // May need to be removed in the future.\r\n      // See https://github.com/tc39/ecma402/issues/285\r\n      return 'ethioaa';\r\n    // case 'gregorian':\r\n    // (Skip 'gregorian'. It isn't a valid identifier as it's a single\r\n    // subcomponent longer than 8 letters. It can only be used with the old\r\n    // @key=value syntax.)\r\n    case 'islamicc':\r\n      return 'islamic-civil';\r\n  }\r\n  return id;\r\n}\r\n\r\nfunction ASCIILowercase<T extends string>(str: T): T {\r\n  // The spec defines this operation distinct from String.prototype.lowercase,\r\n  // so we'll follow the spec here. Note that nasty security issues that can\r\n  // happen for some use cases if you're comparing case-modified non-ASCII\r\n  // values. For example, Turkish's \"I\" character was the source of a security\r\n  // issue involving \"file://\" URLs. See\r\n  // https://haacked.com/archive/2012/07/05/turkish-i-problem-and-why-you-should-care.aspx/.\r\n  let lowercase = '';\r\n  for (let ix = 0; ix < str.length; ix++) {\r\n    const code = str.charCodeAt(ix);\r\n    if (code >= 0x41 && code <= 0x5a) {\r\n      lowercase += String.fromCharCode(code + 0x20);\r\n    } else {\r\n      lowercase += String.fromCharCode(code);\r\n    }\r\n  }\r\n  return lowercase as T;\r\n}\r\n\r\n// This function isn't in the spec, but we put it in the polyfill to avoid\r\n// repeating the same (long) error message in many files.\r\nexport function ValueOfThrows(constructorName: string): never {\r\n  const compareCode =\r\n    constructorName === 'PlainMonthDay'\r\n      ? 'Temporal.PlainDate.compare(obj1.toPlainDate(year), obj2.toPlainDate(year))'\r\n      : `Temporal.${constructorName}.compare(obj1, obj2)`;\r\n\r\n  throw new TypeError(\r\n    'Do not use built-in arithmetic operators with Temporal objects. ' +\r\n      `When comparing, use ${compareCode}, not obj1 > obj2. ` +\r\n      \"When coercing to strings, use `${obj}` or String(obj), not '' + obj. \" +\r\n      'When coercing to numbers, use properties or methods of the object, not `+obj`. ' +\r\n      'When concatenating with strings, use `${str}${obj}` or str.concat(obj), not str + obj. ' +\r\n      'In React, coerce to a string before rendering a Temporal object.'\r\n  );\r\n}\r\n\r\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\r\nconst OFFSET_WITH_PARTS = new RegExp(`^${PARSE.offsetWithParts.source}$`);\r\n\r\nfunction bisect(\r\n  getState: (epochMs: number) => number,\r\n  leftParam: number,\r\n  rightParam: number,\r\n  lstateParam = getState(leftParam),\r\n  rstateParam = getState(rightParam)\r\n) {\r\n  let left = leftParam;\r\n  let right = rightParam;\r\n  let lstate = lstateParam;\r\n  let rstate = rstateParam;\r\n  while (right - left > 1) {\r\n    let middle = Math.trunc((left + right) / 2);\r\n    const mstate = getState(middle);\r\n    if (mstate === lstate) {\r\n      left = middle;\r\n      lstate = mstate;\r\n    } else if (mstate === rstate) {\r\n      right = middle;\r\n      rstate = mstate;\r\n    } else {\r\n      /* c8 ignore next */ assertNotReached(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\r\n    }\r\n  }\r\n  return right;\r\n}\r\n","import * as ES from './ecmascript';\r\nimport { DefineIntrinsic } from './intrinsicclass';\r\nimport type { Temporal } from '..';\r\nimport type {\r\n  BuiltinCalendarId,\r\n  CalendarDateRecord,\r\n  CalendarFieldsRecord,\r\n  CalendarYMD,\r\n  DateDuration,\r\n  FieldKey,\r\n  ISODate,\r\n  ISODateToFieldsType,\r\n  MonthDayFromFieldsObject,\r\n  Overflow,\r\n  Resolve\r\n} from './internaltypes';\r\n\r\nfunction arrayFromSet<T>(src: Set<T>): T[] {\r\n  return [...src];\r\n}\r\n\r\nfunction calendarDateWeekOfYear(id: BuiltinCalendarId, isoDate: ISODate): { week: number; year: number } | undefined {\r\n  // Supports only ISO8601 calendar; can be updated to add support for other calendars.\r\n  // Returns undefined for calendars without a well-defined week calendar system.\r\n  // eslint-disable-next-line max-len\r\n  // Also see: https://github.com/unicode-org/icu/blob/ab72ab1d4a3c3f9beeb7d92b0c7817ca93dfdb04/icu4c/source/i18n/calendar.cpp#L1606\r\n  if (id !== 'iso8601') return undefined;\r\n  const calendar = impl[id];\r\n  let yow = isoDate.year;\r\n  const { dayOfWeek, dayOfYear, daysInYear } = calendar.isoToDate(isoDate, {\r\n    dayOfWeek: true,\r\n    dayOfYear: true,\r\n    daysInYear: true\r\n  });\r\n  const fdow = calendar.getFirstDayOfWeek();\r\n  const mdow = calendar.getMinimalDaysInFirstWeek();\r\n  ES.uncheckedAssertNarrowedType<number>(fdow, 'guaranteed to exist for iso8601');\r\n  ES.uncheckedAssertNarrowedType<number>(mdow, 'guaranteed to exist for iso8601');\r\n\r\n  // For both the input date and the first day of its calendar year, calculate the day of week\r\n  // relative to first day of week in the relevant calendar (e.g., in iso8601, relative to Monday).\r\n  let relDow = (dayOfWeek + 7 - fdow) % 7;\r\n  // Assuming the year length is less than 7000 days.\r\n  let relDowJan1 = (dayOfWeek - dayOfYear + 7001 - fdow) % 7;\r\n\r\n  let woy = Math.floor((dayOfYear - 1 + relDowJan1) / 7);\r\n  if (7 - relDowJan1 >= mdow) {\r\n    ++woy;\r\n  }\r\n\r\n  // Adjust for weeks at the year end that overlap into the previous or next calendar year.\r\n  if (woy == 0) {\r\n    // Check for last week of previous year; if true, handle the case for\r\n    // first week of next year\r\n    const prevYearCalendar = calendar.isoToDate(calendar.dateAdd(isoDate, { years: -1 }, 'constrain'), {\r\n      daysInYear: true\r\n    });\r\n    let prevDoy = dayOfYear + prevYearCalendar.daysInYear;\r\n    woy = weekNumber(fdow, mdow, prevDoy, dayOfWeek);\r\n    yow--;\r\n  } else {\r\n    // For it to be week 1 of the next year, dayOfYear must be >= lastDoy - 5\r\n    //          L-5                  L\r\n    // doy: 359 360 361 362 363 364 365 001\r\n    // dow:      1   2   3   4   5   6   7\r\n    let lastDoy = daysInYear;\r\n    if (dayOfYear >= lastDoy - 5) {\r\n      let lastRelDow = (relDow + lastDoy - dayOfYear) % 7;\r\n      if (lastRelDow < 0) {\r\n        lastRelDow += 7;\r\n      }\r\n      if (6 - lastRelDow >= mdow && dayOfYear + 7 - relDow > lastDoy) {\r\n        woy = 1;\r\n        yow++;\r\n      }\r\n    }\r\n  }\r\n  return { week: woy, year: yow };\r\n}\r\n\r\nfunction ISODateSurpasses(sign: -1 | 0 | 1, y1: number, m1: number, d1: number, isoDate2: ISODate) {\r\n  if (y1 !== isoDate2.year) {\r\n    if (sign * (y1 - isoDate2.year) > 0) return true;\r\n  } else if (m1 !== isoDate2.month) {\r\n    if (sign * (m1 - isoDate2.month) > 0) return true;\r\n  } else if (d1 !== isoDate2.day) {\r\n    if (sign * (d1 - isoDate2.day) > 0) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\ntype ResolveFieldsReturn<Type extends ISODateToFieldsType> = Resolve<\r\n  CalendarFieldsRecord & {\r\n    year: Type extends 'date' ? number : never;\r\n    month: number;\r\n    monthCode: string;\r\n    day: number;\r\n  }\r\n>;\r\n\r\n/**\r\n * Shape of internal implementation of each built-in calendar. Note that\r\n * parameter types are simpler than CalendarProtocol because the `Calendar`\r\n * class performs validation and parameter normalization before handing control\r\n * over to CalendarImpl.\r\n *\r\n * There are two instances of this interface: one for the ISO calendar and\r\n * another that handles logic that's the same across all non-ISO calendars. The\r\n * latter is cloned for each non-ISO calendar at the end of this file.\r\n */\r\nexport interface CalendarImpl {\r\n  isoToDate<\r\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\r\n    T extends {\r\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\r\n    }\r\n  >(\r\n    isoDate: ISODate,\r\n    requestedFields: Request\r\n  ): T;\r\n  getFirstDayOfWeek(): number | undefined;\r\n  getMinimalDaysInFirstWeek(): number | undefined;\r\n  resolveFields<Type extends ISODateToFieldsType>(\r\n    fields: CalendarFieldsRecord,\r\n    type: Type\r\n  ): asserts fields is ResolveFieldsReturn<Type>;\r\n  dateToISO(fields: ResolveFieldsReturn<'date'>, overflow: Overflow): ISODate;\r\n  monthDayToISOReferenceDate(fields: ResolveFieldsReturn<'month-day'>, overflow: Overflow): ISODate;\r\n  dateAdd(date: ISODate, duration: Partial<DateDuration>, overflow: Overflow): ISODate;\r\n  dateUntil(one: ISODate, two: ISODate, largestUnit: 'year' | 'month' | 'week' | 'day'): DateDuration;\r\n  extraFields(fields: FieldKey[]): FieldKey[];\r\n  fieldKeysToIgnore(keys: FieldKey[]): FieldKey[];\r\n}\r\n\r\ntype CalendarImplementations = {\r\n  [k in BuiltinCalendarId]: CalendarImpl;\r\n};\r\n\r\n/**\r\n * Implementations for each calendar.\r\n * Registration for each of these calendars happens throughout this file. The ISO and non-ISO calendars are registered\r\n * separately - look for 'iso8601' for the ISO calendar registration, and all non-ISO calendar registrations happens\r\n * at the bottom of the file.\r\n */\r\nconst impl: CalendarImplementations = {} as unknown as CalendarImplementations;\r\n\r\n/**\r\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\r\n * guaranteed to be supported by all ECMAScript implementations, including those\r\n * without Intl (ECMA-402) support.\r\n */\r\nimpl['iso8601'] = {\r\n  resolveFields(fields, type) {\r\n    if ((type === 'date' || type === 'year-month') && fields.year === undefined) {\r\n      throw new TypeError('year is required');\r\n    }\r\n    if ((type === 'date' || type === 'month-day') && fields.day === undefined) {\r\n      throw new TypeError('day is required');\r\n    }\r\n    Object.assign(fields, resolveNonLunisolarMonth(fields));\r\n  },\r\n  dateToISO(fields, overflow) {\r\n    return ES.RegulateISODate(fields.year, fields.month, fields.day, overflow);\r\n  },\r\n  monthDayToISOReferenceDate(fields, overflow) {\r\n    const referenceISOYear = 1972;\r\n    const { month, day } = ES.RegulateISODate(fields.year ?? referenceISOYear, fields.month, fields.day, overflow);\r\n    return { month, day, year: referenceISOYear };\r\n  },\r\n  extraFields() {\r\n    return [];\r\n  },\r\n  fieldKeysToIgnore(keys) {\r\n    const result = new Set<FieldKey>();\r\n    for (let ix = 0; ix < keys.length; ix++) {\r\n      const key = keys[ix];\r\n      result.add(key);\r\n      if (key === 'month') {\r\n        result.add('monthCode');\r\n      } else if (key === 'monthCode') {\r\n        result.add('month');\r\n      }\r\n    }\r\n    return arrayFromSet(result);\r\n  },\r\n  dateAdd(isoDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow) {\r\n    let { year, month, day } = isoDate;\r\n    year += years;\r\n    month += months;\r\n    ({ year, month } = ES.BalanceISOYearMonth(year, month));\r\n    ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\r\n    day += days + 7 * weeks;\r\n    return ES.BalanceISODate(year, month, day);\r\n  },\r\n  dateUntil(one, two, largestUnit) {\r\n    const sign = -ES.CompareISODate(one, two);\r\n    if (sign === 0) return { years: 0, months: 0, weeks: 0, days: 0 };\r\n    ES.uncheckedAssertNarrowedType<-1 | 1>(sign, \"the - operator's return type is number\");\r\n\r\n    let years = 0;\r\n    let months = 0;\r\n    let intermediate;\r\n    if (largestUnit === 'year' || largestUnit === 'month') {\r\n      // We can skip right to the neighbourhood of the correct number of years,\r\n      // it'll be at least one less than two.year - one.year (unless it's zero)\r\n      let candidateYears = two.year - one.year;\r\n      if (candidateYears !== 0) candidateYears -= sign;\r\n      // loops at most twice\r\n      while (!ISODateSurpasses(sign, one.year + candidateYears, one.month, one.day, two)) {\r\n        years = candidateYears;\r\n        candidateYears += sign;\r\n      }\r\n\r\n      let candidateMonths = sign;\r\n      intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + candidateMonths);\r\n      // loops at most 12 times\r\n      while (!ISODateSurpasses(sign, intermediate.year, intermediate.month, one.day, two)) {\r\n        months = candidateMonths;\r\n        candidateMonths += sign;\r\n        intermediate = ES.BalanceISOYearMonth(intermediate.year, intermediate.month + sign);\r\n      }\r\n\r\n      if (largestUnit === 'month') {\r\n        months += years * 12;\r\n        years = 0;\r\n      }\r\n    }\r\n\r\n    intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + months);\r\n    const constrained = ES.ConstrainISODate(intermediate.year, intermediate.month, one.day);\r\n\r\n    let weeks = 0;\r\n    let days =\r\n      ES.ISODateToEpochDays(two.year, two.month - 1, two.day) -\r\n      ES.ISODateToEpochDays(constrained.year, constrained.month - 1, constrained.day);\r\n\r\n    if (largestUnit === 'week') {\r\n      weeks = Math.trunc(days / 7);\r\n      days %= 7;\r\n    }\r\n\r\n    return { years, months, weeks, days };\r\n  },\r\n  isoToDate<\r\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\r\n    T extends {\r\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\r\n    }\r\n  >({ year, month, day }: ISODate, requestedFields: Request): T {\r\n    // requestedFields parameter is not part of the spec text. It's an\r\n    // illustration of one way implementations may choose to optimize this\r\n    // operation.\r\n    const date: Partial<CalendarDateRecord> = {\r\n      era: undefined,\r\n      eraYear: undefined,\r\n      year,\r\n      month,\r\n      day,\r\n      daysInWeek: 7,\r\n      monthsInYear: 12\r\n    };\r\n    if (requestedFields.monthCode) date.monthCode = buildMonthCode(month);\r\n    if (requestedFields.dayOfWeek) {\r\n      // https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Disparate_variation\r\n      const shiftedMonth = month + (month < 3 ? 10 : -2);\r\n      const shiftedYear = year - (month < 3 ? 1 : 0);\r\n\r\n      const century = Math.floor(shiftedYear / 100);\r\n      const yearInCentury = shiftedYear - century * 100;\r\n\r\n      const monthTerm = Math.floor(2.6 * shiftedMonth - 0.2);\r\n      const yearTerm = yearInCentury + Math.floor(yearInCentury / 4);\r\n      const centuryTerm = Math.floor(century / 4) - 2 * century;\r\n\r\n      const dow = (day + monthTerm + yearTerm + centuryTerm) % 7;\r\n\r\n      date.dayOfWeek = dow + (dow <= 0 ? 7 : 0);\r\n    }\r\n    if (requestedFields.dayOfYear) {\r\n      let days = day;\r\n      for (let m = month - 1; m > 0; m--) {\r\n        days += ES.ISODaysInMonth(year, m);\r\n      }\r\n      date.dayOfYear = days;\r\n    }\r\n    if (requestedFields.weekOfYear) date.weekOfYear = calendarDateWeekOfYear('iso8601', { year, month, day });\r\n    if (requestedFields.daysInMonth) date.daysInMonth = ES.ISODaysInMonth(year, month);\r\n    if (requestedFields.daysInYear || requestedFields.inLeapYear) {\r\n      date.inLeapYear = ES.LeapYear(year);\r\n      date.daysInYear = date.inLeapYear ? 366 : 365;\r\n    }\r\n    return date as T;\r\n  },\r\n  getFirstDayOfWeek() {\r\n    return 1;\r\n  },\r\n  getMinimalDaysInFirstWeek() {\r\n    return 4;\r\n  }\r\n};\r\n\r\n// Note: Built-in calendars other than iso8601 are not part of the Temporal\r\n// proposal for ECMA-262. These calendars will be standardized as part of\r\n// ECMA-402. Code below here includes an implementation of these calendars to\r\n// validate the Temporal API and to get feedback. However, native non-ISO\r\n// calendar behavior is at least somewhat implementation-defined, so may not\r\n// match this polyfill's output exactly.\r\n//\r\n// Some ES implementations don't include ECMA-402. For this reason, it's helpful\r\n// to ensure a clean separation between the ISO calendar implementation which is\r\n// a part of ECMA-262 and the non-ISO calendar implementation which requires\r\n// ECMA-402.\r\n//\r\n// To ensure this separation, the implementation is split. A `CalendarImpl`\r\n// interface defines the common operations between both ISO and non-ISO\r\n// calendars.\r\n\r\n/**\r\n * This type is passed through from CalendarImpl#dateFromFields().\r\n * `monthExtra` is additional information used internally to identify lunisolar leap months.\r\n */\r\ntype CalendarDateFields = CalendarFieldsRecord & { monthExtra?: string };\r\n\r\n/**\r\n * This is a \"fully populated\" calendar date record. It's only lacking\r\n * `era`/`eraYear` (which may not be present in all calendars) and `monthExtra`\r\n * which is only used in some cases.\r\n */\r\ntype FullCalendarDate = {\r\n  era?: string;\r\n  eraYear?: number;\r\n  year: number;\r\n  month: number;\r\n  monthCode: string;\r\n  day: number;\r\n  monthExtra?: string;\r\n};\r\n\r\n// The types below are various subsets of calendar dates\r\ntype CalendarYM = { year: number; month: number };\r\ntype CalendarYearOnly = { year: number };\r\ntype EraAndEraYear = { era: string; eraYear: number };\r\n\r\nfunction nonLeapMonthCodeNumberPart(monthCode: string) {\r\n  if (!monthCode.startsWith('M')) {\r\n    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\r\n  }\r\n  const month = +monthCode.slice(1);\r\n  if (Number.isNaN(month)) throw new RangeError(`Invalid month code: ${monthCode}`);\r\n  return month;\r\n}\r\n\r\nfunction buildMonthCode(month: number, leap = false) {\r\n  const digitPart = `${month}`.padStart(2, '0');\r\n  const leapMarker = leap ? 'L' : '';\r\n  return `M${digitPart}${leapMarker}`;\r\n}\r\n\r\n/**\r\n * Safely merge a month, monthCode pair into an integer month.\r\n * If both are present, make sure they match.\r\n * This logic doesn't work for lunisolar calendars!\r\n * */\r\nfunction resolveNonLunisolarMonth<T extends { monthCode?: string; month?: number }>(\r\n  calendarDate: T,\r\n  overflow: Overflow | undefined = undefined,\r\n  monthsPerYear = 12\r\n) {\r\n  let { month, monthCode } = calendarDate;\r\n  if (monthCode === undefined) {\r\n    if (month === undefined) throw new TypeError('Either month or monthCode are required');\r\n    // The ISO calendar uses the default (undefined) value because it does\r\n    // constrain/reject after this method returns. Non-ISO calendars, however,\r\n    // rely on this function to constrain/reject out-of-range `month` values.\r\n    if (overflow === 'reject') ES.RejectToRange(month, 1, monthsPerYear);\r\n    if (overflow === 'constrain') month = ES.ConstrainToRange(month, 1, monthsPerYear);\r\n    monthCode = buildMonthCode(month);\r\n  } else {\r\n    const numberPart = nonLeapMonthCodeNumberPart(monthCode);\r\n    if (monthCode !== buildMonthCode(numberPart)) {\r\n      throw new RangeError(`Invalid month code: ${monthCode}`);\r\n    }\r\n    if (month !== undefined && month !== numberPart) {\r\n      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\r\n    }\r\n    month = numberPart;\r\n    if (month < 1 || month > monthsPerYear) throw new RangeError(`Invalid monthCode: ${monthCode}`);\r\n  }\r\n  return { ...calendarDate, month, monthCode };\r\n}\r\n\r\nfunction weekNumber(firstDayOfWeek: number, minimalDaysInFirstWeek: number, desiredDay: number, dayOfWeek: number) {\r\n  let periodStartDayOfWeek = (dayOfWeek - firstDayOfWeek - desiredDay + 1) % 7;\r\n  if (periodStartDayOfWeek < 0) periodStartDayOfWeek += 7;\r\n  let weekNo = Math.floor((desiredDay + periodStartDayOfWeek - 1) / 7);\r\n  if (7 - periodStartDayOfWeek >= minimalDaysInFirstWeek) {\r\n    ++weekNo;\r\n  }\r\n  return weekNo;\r\n}\r\n\r\n/**\r\n * This prototype implementation of non-ISO calendars makes many repeated calls\r\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\r\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\r\n * to a specific Temporal object, which speeds up multiple calendar calls on the\r\n * same Temporal object instance.  No invalidation or pruning is necessary\r\n * because each object's cache is thrown away when the object is GC-ed.\r\n */\r\nclass OneObjectCache {\r\n  map = new Map();\r\n  calls = 0;\r\n  // now = OneObjectCache.monotonicTimestamp();\r\n  hits = 0;\r\n  misses = 0;\r\n\r\n  // static monotonicTimestamp() {\r\n  //   return performance?.now() ?? Date.now();\r\n  // }\r\n\r\n  constructor(cacheToClone?: OneObjectCache) {\r\n    if (cacheToClone !== undefined) {\r\n      let i = 0;\r\n      for (const entry of cacheToClone.map.entries()) {\r\n        if (++i > OneObjectCache.MAX_CACHE_ENTRIES) break;\r\n        this.map.set(...entry);\r\n      }\r\n    }\r\n  }\r\n  get(key: string) {\r\n    const result = this.map.get(key);\r\n    if (result) {\r\n      this.hits++;\r\n      this.report();\r\n    }\r\n    this.calls++;\r\n    return result;\r\n  }\r\n  set(key: string, value: unknown) {\r\n    this.map.set(key, value);\r\n    this.misses++;\r\n    this.report();\r\n  }\r\n  report() {\r\n    // if (this.calls === 0) return;\r\n    // const ms = OneObjectCache.monotonicTimestamp() - this.now;\r\n    // const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\r\n    // const t = `${ms.toFixed(2)}ms`;\r\n    // // eslint-disable-next-line no-console\r\n    // console.log(`${this.calls} calls in ${t}. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\r\n  }\r\n  setObject(obj: ISODate) {\r\n    if (OneObjectCache.objectMap.get(obj)) throw new RangeError('object already cached');\r\n    OneObjectCache.objectMap.set(obj, this);\r\n    this.report();\r\n  }\r\n\r\n  static objectMap = new WeakMap();\r\n  static MAX_CACHE_ENTRIES = 1000;\r\n\r\n  /**\r\n   * Returns a WeakMap-backed cache that's used to store expensive results\r\n   * that are associated with a particular Temporal object instance.\r\n   *\r\n   * @param obj - object to associate with the cache\r\n   */\r\n  static getCacheForObject(obj: ISODate) {\r\n    let cache = OneObjectCache.objectMap.get(obj);\r\n    if (!cache) {\r\n      cache = new OneObjectCache();\r\n      OneObjectCache.objectMap.set(obj, cache);\r\n    }\r\n    return cache;\r\n  }\r\n}\r\n\r\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }: { isoYear: number; isoMonth: number; isoDay: number }) {\r\n  const yearString = ES.ISOYearString(isoYear);\r\n  const monthString = ES.ISODateTimePartString(isoMonth);\r\n  const dayString = ES.ISODateTimePartString(isoDay);\r\n  return `${yearString}-${monthString}-${dayString}T00:00Z`;\r\n}\r\n\r\nfunction simpleDateDiff(one: CalendarYMD, two: CalendarYMD) {\r\n  return {\r\n    years: one.year - two.year,\r\n    months: one.month - two.month,\r\n    days: one.day - two.day\r\n  };\r\n}\r\n\r\n/**\r\n * Implementation helper that's common to all non-ISO calendars\r\n */\r\nabstract class HelperBase {\r\n  abstract id: BuiltinCalendarId;\r\n  abstract monthsInYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): number;\r\n  abstract maximumMonthLength(calendarDate?: CalendarYM): number;\r\n  abstract minimumMonthLength(calendarDate?: CalendarYM): number;\r\n  abstract maxLengthOfMonthCodeInAnyYear(monthCode: string): number;\r\n  abstract estimateIsoDate(calendarDate: CalendarYMD): ISODate;\r\n  abstract inLeapYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): boolean;\r\n  abstract calendarType: 'solar' | 'lunar' | 'lunisolar';\r\n  reviseIntlEra?<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T;\r\n  eras: Era[] = [];\r\n  checkIcuBugs?(isoDate: ISODate): void;\r\n  private formatter?: globalThis.Intl.DateTimeFormat;\r\n  getFormatter() {\r\n    // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\r\n    // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\r\n    // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\r\n    // calendars that are used. Note that the HelperBase class is extended to\r\n    // create each calendar's implementation before any cache is created, so\r\n    // each calendar gets its own separate cached formatter.\r\n    if (typeof this.formatter === 'undefined') {\r\n      this.formatter = new Intl.DateTimeFormat(`en-US-u-ca-${this.id}`, {\r\n        day: 'numeric',\r\n        month: 'numeric',\r\n        year: 'numeric',\r\n        era: 'short',\r\n        timeZone: 'UTC'\r\n      });\r\n    }\r\n    return this.formatter;\r\n  }\r\n  getCalendarParts(isoString: string) {\r\n    let dateTimeFormat = this.getFormatter();\r\n    let legacyDate = new Date(isoString);\r\n\r\n    // PlainDate's minimum date -271821-04-19 is one day beyond legacy Date's\r\n    // minimum -271821-04-20, because of accommodating all Instants in all time\r\n    // zones. If we have -271821-04-19, instead format -271821-04-20 in a time\r\n    // zone that pushes the result into the previous day. This is a slow path\r\n    // because we create a new Intl.DateTimeFormat.\r\n    if (isoString === '-271821-04-19T00:00Z') {\r\n      const options = dateTimeFormat.resolvedOptions();\r\n      dateTimeFormat = new Intl.DateTimeFormat(options.locale, {\r\n        ...(options as Intl.DateTimeFormatOptions),\r\n        timeZone: 'Etc/GMT+1'\r\n      });\r\n      legacyDate = new Date('-271821-04-20T00:00Z');\r\n    }\r\n\r\n    try {\r\n      return dateTimeFormat.formatToParts(legacyDate);\r\n    } catch (e) {\r\n      throw new RangeError(`Invalid ISO date: ${isoString}`);\r\n    }\r\n  }\r\n  isoToCalendarDate(isoDate: ISODate, cache: OneObjectCache): FullCalendarDate {\r\n    const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\r\n    const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\r\n    const cached = cache.get(key);\r\n    if (cached) return cached;\r\n\r\n    const isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\r\n    const parts = this.getCalendarParts(isoString);\r\n    const result: Partial<FullCalendarDate> = {};\r\n    for (let i = 0; i < parts.length; i++) {\r\n      const { type, value } = parts[i];\r\n      // TODO: remove this type annotation when `relatedYear` gets into TS lib types\r\n      if (type === 'year' || type === ('relatedYear' as Intl.DateTimeFormatPartTypes)) {\r\n        if (this.hasEra) {\r\n          result.eraYear = +value;\r\n        } else {\r\n          result.year = +value;\r\n        }\r\n      }\r\n      if (type === 'month') {\r\n        const matches = /^([0-9]*)(.*?)$/.exec(value);\r\n        if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\r\n          throw new RangeError(`Unexpected month: ${value}`);\r\n        }\r\n        // If the month has no numeric part (should only see this for the Hebrew\r\n        // calendar with newer FF / Chromium versions; see\r\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\r\n        // placeholder month index of `1` and rely on the derived class to\r\n        // calculate the correct month index from the month name stored in\r\n        // `monthExtra`.\r\n        result.month = matches[1] ? +matches[1] : 1;\r\n        if (result.month < 1) {\r\n          throw new RangeError(\r\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\r\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)'\r\n          );\r\n        }\r\n        if (result.month > 13) {\r\n          throw new RangeError(\r\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\r\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\r\n          );\r\n        }\r\n\r\n        // The ICU formats for the Hebrew calendar no longer support a numeric\r\n        // month format. So we'll rely on the derived class to interpret it.\r\n        // `monthExtra` is also used on the Chinese calendar to handle a suffix\r\n        // \"bis\" indicating a leap month.\r\n        if (matches[2]) result.monthExtra = matches[2];\r\n      }\r\n      if (type === 'day') result.day = +value;\r\n      if (this.hasEra && type === 'era' && value != null && value !== '') {\r\n        // The convention for Temporal era values is lowercase, so following\r\n        // that convention in this prototype. Punctuation is removed, accented\r\n        // letters are normalized, and spaces are replaced with dashes.\r\n        // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\r\n        // The call to normalize() and the replacement regex deals with era\r\n        // names that contain non-ASCII characters like Japanese eras. Also\r\n        // ignore extra content in parentheses like JPN era date ranges.\r\n        result.era = value\r\n          .split(' (')[0]\r\n          .normalize('NFD')\r\n          .replace(/[^-0-9 \\p{L}]/gu, '')\r\n          .replace(/ /g, '-')\r\n          .toLowerCase();\r\n      }\r\n    }\r\n    if (this.hasEra && result.eraYear === undefined) {\r\n      // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\r\n      // output of Intl.DateTimeFormat.formatToParts.\r\n      throw new RangeError(\r\n        `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\r\n      );\r\n    }\r\n    // Translate old ICU era codes \"ERA0\" etc. into canonical era names.\r\n    if (this.hasEra) {\r\n      const replacement = this.eras.find((e) => result.era === e.genericName);\r\n      if (replacement) result.era = replacement.code;\r\n    }\r\n    // Translate eras that may be handled differently by Temporal vs. by Intl\r\n    // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\r\n    if (this.reviseIntlEra) {\r\n      const { era, eraYear } = this.reviseIntlEra(result, isoDate);\r\n      result.era = era;\r\n      result.eraYear = eraYear;\r\n    }\r\n    if (this.checkIcuBugs) this.checkIcuBugs(isoDate);\r\n\r\n    const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\r\n    if (calendarDate.year === undefined) throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\r\n    if (calendarDate.month === undefined) {\r\n      throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\r\n    }\r\n    if (calendarDate.day === undefined) throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\r\n    cache.set(key, calendarDate);\r\n    // Also cache the reverse mapping\r\n    const cacheReverse = (overflow: Overflow) => {\r\n      const keyReverse = JSON.stringify({\r\n        func: 'calendarToIsoDate',\r\n        year: calendarDate.year,\r\n        month: calendarDate.month,\r\n        day: calendarDate.day,\r\n        overflow,\r\n        id: this.id\r\n      });\r\n      cache.set(keyReverse, isoDate);\r\n    };\r\n    (['constrain', 'reject'] as const).forEach(cacheReverse);\r\n    return calendarDate;\r\n  }\r\n  validateCalendarDate(calendarDate: Partial<FullCalendarDate>): asserts calendarDate is FullCalendarDate {\r\n    const { month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\r\n    // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\r\n    // the derived class must deal with it.\r\n    if (monthExtra !== undefined) throw new RangeError('Unexpected `monthExtra` value');\r\n    if (year === undefined && eraYear === undefined) throw new TypeError('year or eraYear is required');\r\n    if (month === undefined && monthCode === undefined) throw new TypeError('month or monthCode is required');\r\n    if (day === undefined) throw new RangeError('Missing day');\r\n    if (monthCode !== undefined) {\r\n      if (typeof monthCode !== 'string') {\r\n        throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\r\n      }\r\n      if (!/^M([01]?\\d)(L?)$/.test(monthCode)) {\r\n        throw new RangeError(`Invalid monthCode: ${monthCode}`);\r\n      }\r\n    }\r\n    if (this.hasEra) {\r\n      if ((calendarDate['era'] === undefined) !== (calendarDate['eraYear'] === undefined)) {\r\n        throw new TypeError('properties era and eraYear must be provided together');\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Allows derived calendars to add additional fields and/or to make\r\n   * adjustments e.g. to set the era based on the date or to revise the month\r\n   * number in lunisolar calendars per\r\n   * https://github.com/tc39/proposal-temporal/issues/1203.\r\n   *\r\n   * The base implementation fills in missing values by assuming the simplest\r\n   * possible calendar:\r\n   * - no eras\r\n   * - non-lunisolar calendar (no leap months)\r\n   * */\r\n  adjustCalendarDate(\r\n    calendarDateParam: Partial<FullCalendarDate>,\r\n    cache: OneObjectCache | undefined = undefined,\r\n    overflow: Overflow = 'constrain',\r\n    // This param is only used by derived classes\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    fromLegacyDate = false\r\n  ): FullCalendarDate {\r\n    if (this.calendarType === 'lunisolar') throw new RangeError('Override required for lunisolar calendars');\r\n    let calendarDate = calendarDateParam;\r\n    this.validateCalendarDate(calendarDate);\r\n    const largestMonth = this.monthsInYear(calendarDate, cache);\r\n    let { month, monthCode } = calendarDate;\r\n\r\n    ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\r\n    return { ...(calendarDate as typeof calendarDate & CalendarYMD), month, monthCode };\r\n  }\r\n  regulateMonthDayNaive(calendarDate: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): FullCalendarDate {\r\n    const largestMonth = this.monthsInYear(calendarDate, cache);\r\n    let { month, day } = calendarDate;\r\n    if (overflow === 'reject') {\r\n      ES.RejectToRange(month, 1, largestMonth);\r\n      ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\r\n    } else {\r\n      month = ES.ConstrainToRange(month, 1, largestMonth);\r\n      day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\r\n    }\r\n    return { ...calendarDate, month, day };\r\n  }\r\n  calendarToIsoDate(dateParam: CalendarDateFields, overflow: Overflow = 'constrain', cache: OneObjectCache): ISODate {\r\n    const originalDate = dateParam as Partial<FullCalendarDate>;\r\n    // First, normalize the calendar date to ensure that (year, month, day)\r\n    // are all present, converting monthCode and eraYear if needed.\r\n    let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\r\n\r\n    // Fix obviously out-of-bounds values. Values that are valid generally, but\r\n    // not in this particular year, may not be caught here for some calendars.\r\n    // If so, these will be handled lower below.\r\n    date = this.regulateMonthDayNaive(date, overflow, cache);\r\n\r\n    const { year, month, day } = date;\r\n    const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\r\n    let cached = cache.get(key);\r\n    if (cached) return cached;\r\n    // If YMD are present in the input but the input has been constrained\r\n    // already, then cache both the original value and the constrained value.\r\n    let keyOriginal;\r\n    if (\r\n      originalDate.year !== undefined &&\r\n      originalDate.month !== undefined &&\r\n      originalDate.day !== undefined &&\r\n      (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)\r\n    ) {\r\n      keyOriginal = JSON.stringify({\r\n        func: 'calendarToIsoDate',\r\n        year: originalDate.year,\r\n        month: originalDate.month,\r\n        day: originalDate.day,\r\n        overflow,\r\n        id: this.id\r\n      });\r\n      cached = cache.get(keyOriginal);\r\n      if (cached) return cached;\r\n    }\r\n\r\n    // First, try to roughly guess the result\r\n    let isoEstimate = this.estimateIsoDate({ year, month, day });\r\n    const calculateSameMonthResult = (diffDays: number) => {\r\n      // If the estimate is in the same year & month as the target, then we can\r\n      // calculate the result exactly and short-circuit any additional logic.\r\n      // This optimization assumes that months are continuous. It would break if\r\n      // a calendar skipped days, like the Julian->Gregorian switchover. But\r\n      // current ICU calendars only skip days (japanese/roc/buddhist) because of\r\n      // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\r\n      // that's currently worked around by a custom calendarToIsoDate\r\n      // implementation in those calendars. So this optimization should be safe\r\n      // for all ICU calendars.\r\n      let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\r\n      if (date.day > this.minimumMonthLength(date)) {\r\n        // There's a chance that the calendar date is out of range. Throw or\r\n        // constrain if so.\r\n        let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\r\n        while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\r\n          if (overflow === 'reject') {\r\n            throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\r\n          }\r\n          // Back up a day at a time until we're not hanging over the month end\r\n          testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\r\n          testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\r\n        }\r\n      }\r\n      return testIsoEstimate;\r\n    };\r\n    let sign = 0;\r\n    let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\r\n    let diff = simpleDateDiff(date, roundtripEstimate);\r\n    if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\r\n      const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\r\n      isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\r\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\r\n      diff = simpleDateDiff(date, roundtripEstimate);\r\n      if (diff.years === 0 && diff.months === 0) {\r\n        isoEstimate = calculateSameMonthResult(diff.days);\r\n      } else {\r\n        sign = this.compareCalendarDates(date, roundtripEstimate);\r\n      }\r\n    }\r\n    // If the initial guess is not in the same month, then bisect the\r\n    // distance to the target, starting with 8 days per step.\r\n    let increment = 8;\r\n    while (sign) {\r\n      isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\r\n      const oldRoundtripEstimate = roundtripEstimate;\r\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\r\n      const oldSign = sign;\r\n      sign = this.compareCalendarDates(date, roundtripEstimate);\r\n      if (sign) {\r\n        diff = simpleDateDiff(date, roundtripEstimate);\r\n        if (diff.years === 0 && diff.months === 0) {\r\n          isoEstimate = calculateSameMonthResult(diff.days);\r\n          // Signal the loop condition that there's a match.\r\n          sign = 0;\r\n        } else if (oldSign && sign !== oldSign) {\r\n          if (increment > 1) {\r\n            // If the estimate overshot the target, try again with a smaller increment\r\n            // in the reverse direction.\r\n            increment /= 2;\r\n          } else {\r\n            // Increment is 1, and neither the previous estimate nor the new\r\n            // estimate is correct. The only way that can happen is if the\r\n            // original date was an invalid value that will be constrained or\r\n            // rejected here.\r\n            if (overflow === 'reject') {\r\n              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\r\n            } else {\r\n              // To constrain, pick the earliest value\r\n              const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\r\n              // If current value is larger, then back up to the previous value.\r\n              if (order > 0) isoEstimate = this.addDaysIso(isoEstimate, -1);\r\n              sign = 0;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    cache.set(key, isoEstimate);\r\n    if (keyOriginal) cache.set(keyOriginal, isoEstimate);\r\n    if (\r\n      date.year === undefined ||\r\n      date.month === undefined ||\r\n      date.day === undefined ||\r\n      date.monthCode === undefined ||\r\n      (this.hasEra && (date.era === undefined || date.eraYear === undefined))\r\n    ) {\r\n      throw new RangeError('Unexpected missing property');\r\n    }\r\n    return isoEstimate;\r\n  }\r\n  compareCalendarDates(date1: CalendarYMD, date2: CalendarYMD) {\r\n    if (date1.year !== date2.year) return ES.ComparisonResult(date1.year - date2.year);\r\n    if (date1.month !== date2.month) return ES.ComparisonResult(date1.month - date2.month);\r\n    if (date1.day !== date2.day) return ES.ComparisonResult(date1.day - date2.day);\r\n    return 0;\r\n  }\r\n  /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\r\n  regulateDate(calendarDate: CalendarYMD, overflow: Overflow = 'constrain', cache: OneObjectCache): FullCalendarDate {\r\n    const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\r\n    return this.isoToCalendarDate(isoDate, cache);\r\n  }\r\n  addDaysIso(isoDate: ISODate, days: number): ISODate {\r\n    const added = ES.BalanceISODate(isoDate.year, isoDate.month, isoDate.day + days);\r\n    return added;\r\n  }\r\n  addDaysCalendar(calendarDate: CalendarYMD, days: number, cache: OneObjectCache): FullCalendarDate {\r\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n    const addedIso = this.addDaysIso(isoDate, days);\r\n    const addedCalendar = this.isoToCalendarDate(addedIso, cache);\r\n    return addedCalendar;\r\n  }\r\n  addMonthsCalendar(\r\n    calendarDateParam: CalendarYMD,\r\n    months: number,\r\n    overflow: Overflow,\r\n    cache: OneObjectCache\r\n  ): CalendarYMD {\r\n    let calendarDate = calendarDateParam;\r\n    const { day } = calendarDate;\r\n    for (let i = 0, absMonths = Math.abs(months); i < absMonths; i++) {\r\n      const { month } = calendarDate;\r\n      const oldCalendarDate = calendarDate;\r\n      const days =\r\n        months < 0\r\n          ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\r\n          : this.daysInMonth(calendarDate, cache);\r\n      const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n      let addedIso = this.addDaysIso(isoDate, days);\r\n      calendarDate = this.isoToCalendarDate(addedIso, cache);\r\n\r\n      // Normally, we can advance one month by adding the number of days in the\r\n      // current month. However, if we're at the end of the current month and\r\n      // the next month has fewer days, then we rolled over to the after-next\r\n      // month. Below we detect this condition and back up until we're back in\r\n      // the desired month.\r\n      if (months > 0) {\r\n        const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\r\n        while (calendarDate.month - 1 !== month % monthsInOldYear) {\r\n          addedIso = this.addDaysIso(addedIso, -1);\r\n          calendarDate = this.isoToCalendarDate(addedIso, cache);\r\n        }\r\n      }\r\n\r\n      if (calendarDate.day !== day) {\r\n        // try to retain the original day-of-month, if possible\r\n        calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\r\n      }\r\n    }\r\n    if (overflow === 'reject' && calendarDate.day !== day) {\r\n      throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\r\n    }\r\n    return calendarDate;\r\n  }\r\n  addCalendar(\r\n    calendarDate: CalendarYMD & { monthCode: string },\r\n    { years = 0, months = 0, weeks = 0, days = 0 },\r\n    overflow: Overflow,\r\n    cache: OneObjectCache\r\n  ): FullCalendarDate {\r\n    const { year, day, monthCode } = calendarDate;\r\n    const addedYears = this.adjustCalendarDate({ year: year + years, monthCode, day }, cache);\r\n    const addedMonths = this.addMonthsCalendar(addedYears, months, overflow, cache);\r\n    const initialDays = days + weeks * 7;\r\n    const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\r\n    return addedDays;\r\n  }\r\n  untilCalendar(\r\n    calendarOne: FullCalendarDate,\r\n    calendarTwo: FullCalendarDate,\r\n    largestUnit: Temporal.DateUnit,\r\n    cache: OneObjectCache\r\n  ): { years: number; months: number; weeks: number; days: number } {\r\n    let days = 0;\r\n    let weeks = 0;\r\n    let months = 0;\r\n    let years = 0;\r\n    switch (largestUnit) {\r\n      case 'day':\r\n        days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\r\n        break;\r\n      case 'week': {\r\n        const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\r\n        days = totalDays % 7;\r\n        weeks = (totalDays - days) / 7;\r\n        break;\r\n      }\r\n      case 'month':\r\n      case 'year': {\r\n        const sign = this.compareCalendarDates(calendarTwo, calendarOne);\r\n        if (!sign) {\r\n          return { years: 0, months: 0, weeks: 0, days: 0 };\r\n        }\r\n        const diffYears = calendarTwo.year - calendarOne.year;\r\n        const diffDays = calendarTwo.day - calendarOne.day;\r\n        if (largestUnit === 'year' && diffYears) {\r\n          let diffInYearSign = 0;\r\n          if (calendarTwo.monthCode > calendarOne.monthCode) diffInYearSign = 1;\r\n          if (calendarTwo.monthCode < calendarOne.monthCode) diffInYearSign = -1;\r\n          if (!diffInYearSign) diffInYearSign = Math.sign(diffDays);\r\n          const isOneFurtherInYear = diffInYearSign * sign < 0;\r\n          years = isOneFurtherInYear ? diffYears - sign : diffYears;\r\n        }\r\n        const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\r\n        // Now we have less than one year remaining. Add one month at a time\r\n        // until we go over the target, then back up one month and calculate\r\n        // remaining days and weeks.\r\n        let current;\r\n        let next: CalendarYMD = yearsAdded;\r\n        do {\r\n          months += sign;\r\n          current = next;\r\n          next = this.addMonthsCalendar(current, sign, 'constrain', cache);\r\n          if (next.day !== calendarOne.day) {\r\n            // In case the day was constrained down, try to un-constrain it\r\n            next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\r\n          }\r\n        } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\r\n        months -= sign; // correct for loop above which overshoots by 1\r\n        const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\r\n        days = remainingDays;\r\n        break;\r\n      }\r\n    }\r\n    return { years, months, weeks, days };\r\n  }\r\n  daysInMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\r\n    // Add enough days to roll over to the next month. One we're in the next\r\n    // month, we can calculate the length of the current month. NOTE: This\r\n    // algorithm assumes that months are continuous. It would break if a\r\n    // calendar skipped days, like the Julian->Gregorian switchover. But current\r\n    // ICU calendars only skip days (japanese/roc/buddhist) because of a bug\r\n    // (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158) that's\r\n    // currently worked around by a custom calendarToIsoDate implementation in\r\n    // those calendars. So this code should be safe for all ICU calendars.\r\n    const { day } = calendarDate;\r\n    const max = this.maximumMonthLength(calendarDate);\r\n    const min = this.minimumMonthLength(calendarDate);\r\n    // easiest case: we already know the month length if min and max are the same.\r\n    if (min === max) return min;\r\n\r\n    // Add enough days to get into the next month, without skipping it\r\n    const increment = day <= max - min ? max : min;\r\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n    const addedIsoDate = this.addDaysIso(isoDate, increment);\r\n    const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\r\n\r\n    // Now back up to the last day of the original month\r\n    const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\r\n    const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\r\n    return endOfMonthCalendar.day;\r\n  }\r\n  daysInPreviousMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\r\n    const { day, month, year } = calendarDate;\r\n\r\n    // Check to see if we already know the month length, and return it if so\r\n    const previousMonthYear = month > 1 ? year : year - 1;\r\n    let previousMonthDate = { year: previousMonthYear, month, day: 1 };\r\n    const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\r\n    previousMonthDate = { ...previousMonthDate, month: previousMonth };\r\n    const min = this.minimumMonthLength(previousMonthDate);\r\n    const max = this.maximumMonthLength(previousMonthDate);\r\n    if (min === max) return max;\r\n\r\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\r\n    const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\r\n    const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\r\n    return lastDayOfPreviousMonthCalendar.day;\r\n  }\r\n  startOfCalendarYear(calendarDate: CalendarYearOnly): CalendarYMD & { monthCode: string } {\r\n    return { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\r\n  }\r\n  startOfCalendarMonth(calendarDate: CalendarYM): CalendarYMD {\r\n    return { year: calendarDate.year, month: calendarDate.month, day: 1 };\r\n  }\r\n  calendarDaysUntil(calendarOne: CalendarYMD, calendarTwo: CalendarYMD, cache: OneObjectCache): number {\r\n    const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\r\n    const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\r\n    return (\r\n      ES.ISODateToEpochDays(twoIso.year, twoIso.month - 1, twoIso.day) -\r\n      ES.ISODateToEpochDays(oneIso.year, oneIso.month - 1, oneIso.day)\r\n    );\r\n  }\r\n  // Override if calendar uses eras\r\n  hasEra = false;\r\n  // See https://github.com/tc39/proposal-temporal/issues/1784\r\n  erasBeginMidYear = false;\r\n  // Override this to shortcut the search space if certain month codes only\r\n  // occur long in the past\r\n  monthDaySearchStartYear(monthCode: string, day: number) {\r\n    void monthCode, day;\r\n    return 1972;\r\n  }\r\n  monthDayFromFields(fields: MonthDayFromFieldsObject, overflow: Overflow, cache: OneObjectCache): ISODate {\r\n    let { era, eraYear, year, month, monthCode, day } = fields;\r\n    if (month !== undefined && year === undefined && (!this.hasEra || era === undefined || eraYear === undefined)) {\r\n      throw new TypeError('when month is present, year (or era and eraYear) are required');\r\n    }\r\n    if (monthCode === undefined || year !== undefined || (this.hasEra && eraYear !== undefined)) {\r\n      // Apply overflow behaviour to year/month/day, to get correct monthCode/day\r\n      ({ monthCode, day } = this.isoToCalendarDate(this.calendarToIsoDate(fields, overflow, cache), cache));\r\n    }\r\n\r\n    let isoYear, isoMonth, isoDay;\r\n    let closestCalendar, closestIso;\r\n    // Look backwards starting from one of the calendar years spanning ISO year\r\n    // 1972, up to 20 calendar years prior, to find a year that has this month\r\n    // and day. Normal months and days will match immediately, but for leap days\r\n    // and leap months we may have to look for a while. For searches longer than\r\n    // 20 years, override the start date in monthDaySearchStartYear.\r\n    const startDateIso = {\r\n      year: this.monthDaySearchStartYear(monthCode, day),\r\n      month: 12,\r\n      day: 31\r\n    };\r\n    const calendarOfStartDateIso = this.isoToCalendarDate(startDateIso, cache);\r\n    // Note: relies on lexicographical ordering of monthCodes\r\n    const calendarYear =\r\n      calendarOfStartDateIso.monthCode > monthCode ||\r\n      (calendarOfStartDateIso.monthCode === monthCode && calendarOfStartDateIso.day >= day)\r\n        ? calendarOfStartDateIso.year\r\n        : calendarOfStartDateIso.year - 1;\r\n    for (let i = 0; i < 20; i++) {\r\n      const testCalendarDate: FullCalendarDate = this.adjustCalendarDate(\r\n        { day, monthCode, year: calendarYear - i },\r\n        cache\r\n      );\r\n      const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\r\n      const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\r\n      ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\r\n      if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\r\n        return { month: isoMonth, day: isoDay, year: isoYear };\r\n      } else if (overflow === 'constrain') {\r\n        // If the requested day is never present in any instance of this month\r\n        // code, and the round trip date is an instance of this month code with\r\n        // the most possible days, we are as close as we can get.\r\n        const maxDayForMonthCode = this.maxLengthOfMonthCodeInAnyYear(roundTripCalendarDate.monthCode);\r\n        if (\r\n          roundTripCalendarDate.monthCode === monthCode &&\r\n          roundTripCalendarDate.day === maxDayForMonthCode &&\r\n          day > maxDayForMonthCode\r\n        ) {\r\n          return { month: isoMonth, day: isoDay, year: isoYear };\r\n        }\r\n        // non-ISO constrain algorithm tries to find the closest date in a matching month\r\n        if (\r\n          closestCalendar === undefined ||\r\n          (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\r\n            roundTripCalendarDate.day > closestCalendar.day)\r\n        ) {\r\n          closestCalendar = roundTripCalendarDate;\r\n          closestIso = isoDate;\r\n        }\r\n      }\r\n    }\r\n    if (overflow === 'constrain' && closestIso !== undefined) return closestIso;\r\n    throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\r\n  }\r\n  getFirstDayOfWeek(): number | undefined {\r\n    return undefined;\r\n  }\r\n  getMinimalDaysInFirstWeek(): number | undefined {\r\n    return undefined;\r\n  }\r\n}\r\n\r\ninterface HebrewMonthInfo {\r\n  [m: string]: (\r\n    | {\r\n        leap: undefined;\r\n        regular: number;\r\n      }\r\n    | {\r\n        leap: number;\r\n        regular: undefined;\r\n      }\r\n    | {\r\n        leap: number;\r\n        regular: number;\r\n      }\r\n  ) & {\r\n    monthCode: string;\r\n    days:\r\n      | number\r\n      | {\r\n          min: number;\r\n          max: number;\r\n        };\r\n  };\r\n}\r\n\r\nclass HebrewHelper extends HelperBase {\r\n  id = 'hebrew' as const;\r\n  calendarType = 'lunisolar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    const { year } = calendarDate;\r\n    // FYI: In addition to adding a month in leap years, the Hebrew calendar\r\n    // also has per-year changes to the number of days of Heshvan and Kislev.\r\n    // Given that these can be calculated by counting the number of days in\r\n    // those months, I assume that these DO NOT need to be exposed as\r\n    // Hebrew-only prototype fields or methods.\r\n    return (7 * year + 1) % 19 < 7;\r\n  }\r\n  monthsInYear(calendarDate: CalendarYearOnly) {\r\n    return this.inLeapYear(calendarDate) ? 13 : 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    return this.minMaxMonthLength(calendarDate, 'min');\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    return this.minMaxMonthLength(calendarDate, 'max');\r\n  }\r\n  minMaxMonthLength(calendarDate: CalendarYM, minOrMax: 'min' | 'max') {\r\n    const { month, year } = calendarDate;\r\n    const monthCode = this.getMonthCode(year, month);\r\n    const monthInfo = Object.entries(this.months).find((m) => m[1].monthCode === monthCode);\r\n    if (monthInfo === undefined) throw new RangeError(`unmatched Hebrew month: ${month}`);\r\n    const daysInMonth = monthInfo[1].days;\r\n    return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    return ['M04', 'M06', 'M08', 'M10', 'M12'].includes(monthCode) ? 29 : 30;\r\n  }\r\n  /** Take a guess at what ISO date a particular calendar date corresponds to */\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year } = calendarDate;\r\n    return { year: year - 3760, month: 1, day: 1 };\r\n  }\r\n  months: HebrewMonthInfo = {\r\n    Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\r\n    Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\r\n    Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\r\n    Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\r\n    Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\r\n    Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\r\n    'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\r\n    'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\r\n    Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\r\n    Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\r\n    Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\r\n    Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\r\n    Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\r\n    Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\r\n  };\r\n  getMonthCode(year: number, month: number) {\r\n    if (this.inLeapYear({ year })) {\r\n      return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\r\n    } else {\r\n      return buildMonthCode(month);\r\n    }\r\n  }\r\n  override adjustCalendarDate(\r\n    calendarDate: Partial<FullCalendarDate>,\r\n    cache?: OneObjectCache,\r\n    overflow: Overflow = 'constrain',\r\n    fromLegacyDate = false\r\n  ): FullCalendarDate {\r\n    let { year, month, monthCode, day, monthExtra } = calendarDate as Omit<typeof calendarDate, 'day'> & {\r\n      day: number;\r\n    };\r\n    if (year === undefined) throw new TypeError('Missing property: year');\r\n    if (fromLegacyDate) {\r\n      // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\r\n      // output returns the numeric equivalent of `month` as a string, meaning\r\n      // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\r\n      // means Adar. In this case, `month` will already be correct and no action\r\n      // is needed. However, in Node 14 and later formatToParts returns the name\r\n      // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\r\n      // correct `month` using the string name as a key.\r\n      if (monthExtra) {\r\n        const monthInfo = this.months[monthExtra];\r\n        if (!monthInfo) throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\r\n        month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\r\n      }\r\n      // Because we're getting data from legacy Date, then `month` will always be present\r\n      monthCode = this.getMonthCode(year, month as number);\r\n      return { year, month: month as number, day, monthCode };\r\n    } else {\r\n      // When called without input coming from legacy Date output, simply ensure\r\n      // that all fields are present.\r\n      this.validateCalendarDate(calendarDate);\r\n      if (month === undefined) {\r\n        ES.assertExists(monthCode);\r\n        if (monthCode.endsWith('L')) {\r\n          if (monthCode !== 'M05L') {\r\n            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\r\n          }\r\n          month = 6;\r\n          if (!this.inLeapYear({ year })) {\r\n            if (overflow === 'reject') {\r\n              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\r\n            } else {\r\n              // constrain to same day of next month (Adar)\r\n              month = 6;\r\n              monthCode = 'M06';\r\n            }\r\n          }\r\n        } else {\r\n          month = nonLeapMonthCodeNumberPart(monthCode);\r\n          // if leap month is before this one, the month index is one more than the month code\r\n          if (this.inLeapYear({ year }) && month >= 6) month++;\r\n          const largestMonth = this.monthsInYear({ year });\r\n          if (month < 1 || month > largestMonth) throw new RangeError(`Invalid monthCode: ${monthCode}`);\r\n        }\r\n      } else {\r\n        if (overflow === 'reject') {\r\n          ES.RejectToRange(month, 1, this.monthsInYear({ year }));\r\n          ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\r\n        } else {\r\n          month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\r\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\r\n        }\r\n        if (monthCode === undefined) {\r\n          monthCode = this.getMonthCode(year, month);\r\n        } else {\r\n          const calculatedMonthCode = this.getMonthCode(year, month);\r\n          if (calculatedMonthCode !== monthCode) {\r\n            throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\r\n          }\r\n        }\r\n      }\r\n      return { ...calendarDate, day, month, monthCode, year };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * For Temporal purposes, the Islamic calendar is simple because it's always the\r\n * same 12 months in the same order.\r\n */\r\nabstract class IslamicBaseHelper extends HelperBase {\r\n  abstract override id: BuiltinCalendarId;\r\n  calendarType = 'lunar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    const startOfYearCalendar = { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\r\n    const startOfNextYearCalendar = { year: calendarDate.year + 1, month: 1, monthCode: 'M01', day: 1 };\r\n    const result = this.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\r\n    return result === 355;\r\n  }\r\n  monthsInYear(/* calendarYear, cache */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(/* calendarDate */) {\r\n    return 29;\r\n  }\r\n  maximumMonthLength(/* calendarDate */) {\r\n    return 30;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(/* monthCode */) {\r\n    return 30;\r\n  }\r\n  DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\r\n  DAYS_PER_ISO_YEAR = 365.2425;\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year } = this.adjustCalendarDate(calendarDate);\r\n    return { year: Math.floor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\r\n  }\r\n}\r\n\r\n// There are 6 Islamic calendars with the same implementation in this polyfill.\r\n// They vary only in their ID. They do emit different output from the underlying\r\n// Intl implementation, but our code for each of them is identical.\r\nclass IslamicHelper extends IslamicBaseHelper {\r\n  id = 'islamic' as const;\r\n}\r\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\r\n  id = 'islamic-umalqura' as const;\r\n}\r\nclass IslamicTblaHelper extends IslamicBaseHelper {\r\n  id = 'islamic-tbla' as const;\r\n}\r\nclass IslamicCivilHelper extends IslamicBaseHelper {\r\n  id = 'islamic-civil' as const;\r\n}\r\nclass IslamicRgsaHelper extends IslamicBaseHelper {\r\n  id = 'islamic-rgsa' as const;\r\n}\r\nclass IslamicCcHelper extends IslamicBaseHelper {\r\n  id = 'islamicc' as const;\r\n}\r\n\r\nclass PersianHelper extends HelperBase {\r\n  id = 'persian' as const;\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    // If the last month has 30 days, it's a leap year.\r\n    return this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache) === 30;\r\n  }\r\n  monthsInYear(/* calendarYear, cache */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    if (month === 12) return 29;\r\n    return month <= 6 ? 31 : 30;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    if (month === 12) return 30;\r\n    return month <= 6 ? 31 : 30;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    return month <= 6 ? 31 : 30;\r\n  }\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year } = this.adjustCalendarDate(calendarDate);\r\n    return { year: year + 621, month: 1, day: 1 };\r\n  }\r\n}\r\n\r\ninterface IndianMonthInfo {\r\n  [month: number]: {\r\n    length: number;\r\n    month: number;\r\n    day: number;\r\n    leap?: {\r\n      length: number;\r\n      month: number;\r\n      day: number;\r\n    };\r\n    nextYear?: true | undefined;\r\n  };\r\n}\r\n\r\nclass IndianHelper extends HelperBase {\r\n  id = 'indian' as const;\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    // From https://en.wikipedia.org/wiki/Indian_national_calendar:\r\n    // Years are counted in the Saka era, which starts its year 0 in the year 78\r\n    // of the Common Era. To determine leap years, add 78 to the Saka year – if\r\n    // the result is a leap year in the Gregorian calendar, then the Saka year\r\n    // is a leap year as well.\r\n    return isGregorianLeapYear(calendarDate.year + 78);\r\n  }\r\n  monthsInYear(/* calendarYear, cache */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    return this.getMonthInfo(calendarDate).length;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    return this.getMonthInfo(calendarDate).length;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    let monthInfo = this.months[month];\r\n    monthInfo = monthInfo.leap ?? monthInfo;\r\n    return monthInfo.length;\r\n  }\r\n  // Indian months always start at the same well-known Gregorian month and\r\n  // day. So this conversion is easy and fast. See\r\n  // https://en.wikipedia.org/wiki/Indian_national_calendar\r\n  months: IndianMonthInfo = {\r\n    1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\r\n    2: { length: 31, month: 4, day: 21 },\r\n    3: { length: 31, month: 5, day: 22 },\r\n    4: { length: 31, month: 6, day: 22 },\r\n    5: { length: 31, month: 7, day: 23 },\r\n    6: { length: 31, month: 8, day: 23 },\r\n    7: { length: 30, month: 9, day: 23 },\r\n    8: { length: 30, month: 10, day: 23 },\r\n    9: { length: 30, month: 11, day: 22 },\r\n    10: { length: 30, month: 12, day: 22 },\r\n    11: { length: 30, month: 1, nextYear: true, day: 21 },\r\n    12: { length: 30, month: 2, nextYear: true, day: 20 }\r\n  };\r\n  getMonthInfo(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    let monthInfo = this.months[month];\r\n    if (monthInfo === undefined) throw new RangeError(`Invalid month: ${month}`);\r\n    if (this.inLeapYear(calendarDate) && monthInfo.leap) monthInfo = monthInfo.leap;\r\n    return monthInfo;\r\n  }\r\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\r\n    // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\r\n    // calendar fast!\r\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\r\n    const monthInfo = this.getMonthInfo(calendarDate);\r\n    const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\r\n    const isoMonth = monthInfo.month;\r\n    const isoDay = monthInfo.day;\r\n    const isoDate = ES.BalanceISODate(isoYear, isoMonth, isoDay + calendarDate.day - 1);\r\n    return isoDate;\r\n  }\r\n  // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\r\n  // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\r\n  // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\r\n  // expected.\r\n  vulnerableToBceBug =\r\n    new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\r\n  override checkIcuBugs(isoDate: ISODate) {\r\n    if (this.vulnerableToBceBug && isoDate.year < 1) {\r\n      throw new RangeError(\r\n        `calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\r\n          ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Era metadata defined for each calendar.\r\n * TODO: instead of optional properties, this should really have rules\r\n * encoded in the type, e.g. isoEpoch is required unless reverseOf is present.\r\n *  */\r\ninterface InputEra {\r\n  /**\r\n   * Era code, used to populate the 'era' field of Temporal instances.\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   */\r\n  code: string;\r\n\r\n  /**\r\n   * Names are additionally accepted as alternate era codes on input, and the\r\n   * first name is also output in error messages (and may be the era code if\r\n   * desired.)\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   * If absent, this field defaults to a single element matching the code.\r\n   */\r\n  names?: string[];\r\n\r\n  /**\r\n   * Signed calendar year where this era begins.Will be\r\n   * 1 (or 0 for zero-based eras) for the anchor era assuming that `year`\r\n   * numbering starts at the beginning of the anchor era, which is true\r\n   * for all ICU calendars except Japanese. If an era starts mid-year\r\n   * then a calendar month and day are included. Otherwise\r\n   * `{ month: 1, day: 1 }` is assumed.\r\n   */\r\n  anchorEpoch?: CalendarYearOnly | CalendarYMD;\r\n\r\n  /** ISO date of the first day of this era */\r\n  isoEpoch?: { year: number; month: number; day: number };\r\n\r\n  /**\r\n   * If present, then this era counts years backwards like BC\r\n   * and this property points to the forward era. This must be\r\n   * the last (oldest) era in the array.\r\n   * */\r\n  reverseOf?: string;\r\n\r\n  /**\r\n   * If true, the era's years are 0-based. If omitted or false,\r\n   * then the era's years are 1-based.\r\n   * */\r\n  hasYearZero?: boolean;\r\n\r\n  /**\r\n   * Override if this era is the anchor. Not normally used because\r\n   * anchor eras are inferred.\r\n   * */\r\n  isAnchor?: boolean;\r\n}\r\n/**\r\n * Transformation of the `InputEra` type with all fields filled in by\r\n * `adjustEras()`\r\n * */\r\ninterface Era {\r\n  /**\r\n   * Era code, used to populate the 'era' field of Temporal instances.\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   */\r\n  code: string;\r\n\r\n  /**\r\n   * Names are additionally accepted as alternate era codes on input, and the\r\n   * first name is also output in error messages (and may be the era code if\r\n   * desired.)\r\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\r\n   * If absent, this field defaults to a single element matching the code.\r\n   */\r\n  names: string[];\r\n\r\n  /**\r\n   * alternate name of the era used in old versions of ICU data\r\n   * format is `era{n}` where n is the zero-based index of the era\r\n   * with the oldest era being 0.\r\n   * */\r\n  genericName: string;\r\n\r\n  /**\r\n   * Signed calendar year where this era begins. Will be 1 (or 0 for zero-based\r\n   * eras) for the anchor era assuming that `year` numbering starts at the\r\n   * beginning of the anchor era, which is true for all ICU calendars except\r\n   * Japanese. For input, the month and day are optional. If an era starts\r\n   * mid-year then a calendar month and day are included.\r\n   * Otherwise `{ month: 1, day: 1 }` is assumed.\r\n   */\r\n  anchorEpoch: CalendarYMD;\r\n\r\n  /** ISO date of the first day of this era */\r\n  isoEpoch: ISODate;\r\n\r\n  /**\r\n   * If present, then this era counts years backwards like BC\r\n   * and this property points to the forward era. This must be\r\n   * the last (oldest) era in the array.\r\n   * */\r\n  reverseOf?: Era;\r\n\r\n  /**\r\n   * If true, the era's years are 0-based. If omitted or false,\r\n   * then the era's years are 1-based.\r\n   * */\r\n  hasYearZero?: boolean;\r\n\r\n  /**\r\n   * Override if this era is the anchor. Not normally used because\r\n   * anchor eras are inferred.\r\n   * */\r\n  isAnchor?: boolean;\r\n}\r\n\r\n/**\r\n * This function adds additional metadata that makes it easier to work with\r\n * eras. Note that it mutates and normalizes the original era objects, which is\r\n * OK because this is non-observable, internal-only metadata.\r\n *\r\n * The result is an array of eras with the shape defined above.\r\n * */\r\nfunction adjustEras(erasParam: InputEra[]): { eras: Era[]; anchorEra: Era } {\r\n  let eras: (InputEra | Era)[] = erasParam;\r\n  if (eras.length === 0) {\r\n    throw new RangeError('Invalid era data: eras are required');\r\n  }\r\n  if (eras.length === 1 && eras[0].reverseOf) {\r\n    throw new RangeError('Invalid era data: anchor era cannot count years backwards');\r\n  }\r\n  if (eras.length === 1 && !eras[0].code) {\r\n    throw new RangeError('Invalid era data: at least one named era is required');\r\n  }\r\n  if (eras.filter((e) => e.reverseOf != null).length > 1) {\r\n    throw new RangeError('Invalid era data: only one era can count years backwards');\r\n  }\r\n\r\n  // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\r\n  // eras can never be anchors. The era without an `anchorEpoch` property is the\r\n  // anchor.\r\n  let anchorEra: Era | InputEra | undefined;\r\n  eras.forEach((e) => {\r\n    if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\r\n      if (anchorEra) throw new RangeError('Invalid era data: cannot have multiple anchor eras');\r\n      anchorEra = e;\r\n      e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\r\n    } else if (!e.code) {\r\n      throw new RangeError('If era name is blank, it must be the anchor era');\r\n    }\r\n  });\r\n\r\n  // If the era name is undefined, then it's an anchor that doesn't interact\r\n  // with eras at all. For example, Japanese `year` is always the same as ISO\r\n  // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\r\n  // Strip it from the list that's returned.\r\n  eras = eras.filter((e) => e.code);\r\n\r\n  eras.forEach((e) => {\r\n    // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\r\n    // Replace the string-valued \"reverseOf\" property with the actual era object\r\n    // that's reversed.\r\n    const { reverseOf } = e;\r\n    if (reverseOf) {\r\n      const reversedEra = eras.find((era) => era.code === reverseOf);\r\n      if (reversedEra === undefined) {\r\n        throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\r\n      }\r\n      e.reverseOf = reversedEra as Era; // genericName property added later\r\n      e.anchorEpoch = reversedEra.anchorEpoch;\r\n      e.isoEpoch = reversedEra.isoEpoch;\r\n    }\r\n    type YMD = {\r\n      year: number;\r\n      month: number;\r\n      day: number;\r\n    };\r\n    if ((e.anchorEpoch as YMD).month === undefined) (e.anchorEpoch as YMD).month = 1;\r\n    if ((e.anchorEpoch as YMD).day === undefined) (e.anchorEpoch as YMD).day = 1;\r\n  });\r\n\r\n  // Ensure that the latest epoch is first in the array. This lets us try to\r\n  // match eras in index order, with the last era getting the remaining older\r\n  // years. Any reverse-signed era must be at the end.\r\n  eras.sort((e1, e2) => {\r\n    if (e1.reverseOf) return 1;\r\n    if (e2.reverseOf) return -1;\r\n    if (!e1.isoEpoch || !e2.isoEpoch) throw new RangeError('Invalid era data: missing ISO epoch');\r\n    return e2.isoEpoch.year - e1.isoEpoch.year;\r\n  });\r\n\r\n  // If there's a reversed era, then the one before it must be the era that's\r\n  // being reversed.\r\n  const lastEraReversed = eras[eras.length - 1].reverseOf;\r\n  if (lastEraReversed) {\r\n    if (lastEraReversed !== eras[eras.length - 2]) {\r\n      throw new RangeError('Invalid era data: invalid reverse-sign era');\r\n    }\r\n  }\r\n\r\n  // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\r\n  // zero-based index, with the oldest era being zero. This format is used by\r\n  // older versions of ICU data.\r\n  eras.forEach((e, i) => {\r\n    (e as Era).genericName = `era${eras.length - 1 - i}`;\r\n  });\r\n\r\n  return { eras: eras as Era[], anchorEra: (anchorEra || eras[0]) as Era };\r\n}\r\n\r\nfunction isGregorianLeapYear(year: number) {\r\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\r\n}\r\n\r\n/** Base for all Gregorian-like calendars. */\r\nabstract class GregorianBaseHelperFixedEpoch extends HelperBase {\r\n  id: BuiltinCalendarId;\r\n  isoEpoch: ISODate;\r\n\r\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\r\n    super();\r\n    this.id = id;\r\n    this.isoEpoch = isoEpoch;\r\n  }\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\r\n    return isGregorianLeapYear(year);\r\n  }\r\n  monthsInYear(/* calendarDate */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM): number {\r\n    const { month } = calendarDate;\r\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\r\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM): number {\r\n    return this.minimumMonthLength(calendarDate);\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\r\n  }\r\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\r\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\r\n    return ES.RegulateISODate(\r\n      calendarDate.year + this.isoEpoch.year,\r\n      calendarDate.month + this.isoEpoch.month,\r\n      calendarDate.day + this.isoEpoch.day,\r\n      'constrain'\r\n    );\r\n  }\r\n}\r\n\r\n/** Base for Gregorian-like calendars with eras. */\r\nabstract class GregorianBaseHelper extends HelperBase {\r\n  id: BuiltinCalendarId;\r\n  anchorEra: Era;\r\n\r\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\r\n    super();\r\n    this.id = id;\r\n    const { eras, anchorEra } = adjustEras(originalEras);\r\n    this.anchorEra = anchorEra;\r\n    this.eras = eras;\r\n  }\r\n  override hasEra = true;\r\n  calendarType = 'solar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    // Calendars that don't override this method use the same months and leap\r\n    // years as Gregorian. Once we know the ISO year corresponding to the\r\n    // calendar year, we'll know if it's a leap year or not.\r\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\r\n    return isGregorianLeapYear(year);\r\n  }\r\n  monthsInYear(/* calendarDate */) {\r\n    return 12;\r\n  }\r\n  minimumMonthLength(calendarDate: CalendarYM): number {\r\n    const { month } = calendarDate;\r\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\r\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\r\n  }\r\n  maximumMonthLength(calendarDate: CalendarYM): number {\r\n    return this.minimumMonthLength(calendarDate);\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    const month = nonLeapMonthCodeNumberPart(monthCode);\r\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\r\n  }\r\n  /** Fill in missing parts of the (year, era, eraYear) tuple */\r\n  completeEraYear(\r\n    calendarDate: FullCalendarDate\r\n  ): FullCalendarDate & Required<Pick<FullCalendarDate, 'era' | 'eraYear'>> {\r\n    const checkField = (property: keyof FullCalendarDate, value: string | number | undefined, names?: string[]) => {\r\n      const currentValue = calendarDate[property];\r\n      if (currentValue != null && currentValue != value && !((names || []) as unknown[]).includes(currentValue)) {\r\n        // Prefer displaying an era alias, instead of \"gregory-inverse\"\r\n        const preferredName = names?.[0];\r\n        const expected = preferredName ? `${value} (also called ${preferredName})` : value;\r\n        throw new RangeError(`Input ${property} ${currentValue} doesn't match calculated value ${expected}`);\r\n      }\r\n    };\r\n    const eraFromYear = (year: number) => {\r\n      let eraYear;\r\n      const adjustedCalendarDate = { ...calendarDate, year };\r\n      const matchingEra = this.eras.find((e, i) => {\r\n        if (i === this.eras.length - 1) {\r\n          if (e.reverseOf) {\r\n            // This is a reverse-sign era (like BCE) which must be the oldest\r\n            // era. Count years backwards.\r\n            if (year > 0) throw new RangeError(`Signed year ${year} is invalid for era ${e.code}`);\r\n            eraYear = e.anchorEpoch.year - year;\r\n            return true;\r\n          }\r\n          // last era always gets all \"leftover\" (older than epoch) years,\r\n          // so no need for a comparison like below.\r\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\r\n          return true;\r\n        }\r\n        const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\r\n        if (comparison >= 0) {\r\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n      if (!matchingEra) throw new RangeError(`Year ${year} was not matched by any era`);\r\n      return { eraYear: eraYear as unknown as number, era: matchingEra.code, eraNames: matchingEra.names };\r\n    };\r\n\r\n    let { year, eraYear, era } = calendarDate;\r\n    if (year != null) {\r\n      const matchData = eraFromYear(year);\r\n      ({ eraYear, era } = matchData);\r\n      checkField('era', era, matchData?.eraNames);\r\n      checkField('eraYear', eraYear);\r\n    } else if (eraYear != null) {\r\n      if (era === undefined) throw new RangeError('era and eraYear must be provided together');\r\n      // TS limitation: https://github.com/microsoft/TypeScript/issues/11498\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      const matchingEra = this.eras.find(({ code, names = [] }) => code === era || names.includes(era!));\r\n      if (!matchingEra) throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\r\n      if (matchingEra.reverseOf) {\r\n        year = matchingEra.anchorEpoch.year - eraYear;\r\n      } else {\r\n        year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\r\n      }\r\n      checkField('year', year);\r\n      // We'll accept dates where the month/day is earlier than the start of\r\n      // the era or after its end as long as it's in the same year. If that\r\n      // happens, we'll adjust the era/eraYear pair to be the correct era for\r\n      // the `year`.\r\n      ({ eraYear, era } = eraFromYear(year));\r\n    } else {\r\n      throw new RangeError('Either year or eraYear and era are required');\r\n    }\r\n    return { ...calendarDate, year, eraYear, era };\r\n  }\r\n  override adjustCalendarDate(\r\n    calendarDateParam: Partial<FullCalendarDate>,\r\n    cache?: OneObjectCache,\r\n    overflow: Overflow = 'constrain'\r\n  ): FullCalendarDate {\r\n    let calendarDate = calendarDateParam;\r\n    // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\r\n    const { month, monthCode } = calendarDate;\r\n    if (month === undefined) calendarDate = { ...calendarDate, month: nonLeapMonthCodeNumberPart(monthCode as string) };\r\n    this.validateCalendarDate(calendarDate);\r\n    calendarDate = this.completeEraYear(calendarDate);\r\n    return super.adjustCalendarDate(calendarDate, cache, overflow);\r\n  }\r\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\r\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\r\n    const { year, month, day } = calendarDate;\r\n    const { anchorEra } = this;\r\n    const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\r\n    return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\r\n  }\r\n}\r\n\r\n/**\r\n * Some calendars are identical to Gregorian except era and year. For these\r\n * calendars, we can avoid using Intl.DateTimeFormat and just calculate the\r\n * year, era, and eraYear. This is faster (because Intl.DateTimeFormat is slow\r\n * and uses a huge amount of RAM), and it avoids ICU bugs like\r\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\r\n */\r\nabstract class SameMonthDayAsGregorianBaseHelper extends GregorianBaseHelper {\r\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\r\n    super(id, originalEras);\r\n  }\r\n  override isoToCalendarDate(isoDate: ISODate): FullCalendarDate {\r\n    // Month and day are same as ISO, so bypass Intl.DateTimeFormat and\r\n    // calculate the year, era, and eraYear here.\r\n    const { year: isoYear, month, day } = isoDate;\r\n    const monthCode = buildMonthCode(month);\r\n    const year = isoYear - this.anchorEra.isoEpoch.year + 1;\r\n    return this.completeEraYear({ year, month, monthCode, day });\r\n  }\r\n}\r\nconst OrthodoxOps = {\r\n  inLeapYear(calendarDate: CalendarYearOnly) {\r\n    // Leap years happen one year before the Julian leap year. Note that this\r\n    // calendar is based on the Julian calendar which has a leap year every 4\r\n    // years, unlike the Gregorian calendar which doesn't have leap years on\r\n    // years divisible by 100 except years divisible by 400.\r\n    //\r\n    // Note that we're assuming that leap years in before-epoch times match\r\n    // how leap years are defined now. This is probably not accurate but I'm\r\n    // not sure how better to do it.\r\n    const { year } = calendarDate;\r\n    return (year + 1) % 4 === 0;\r\n  },\r\n  monthsInYear(/* calendarDate */) {\r\n    return 13;\r\n  },\r\n  minimumMonthLength(calendarDate: CalendarYM) {\r\n    const { month } = calendarDate;\r\n    // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\r\n    if (month === 13) return this.inLeapYear(calendarDate) ? 6 : 5;\r\n    return 30;\r\n  },\r\n  maximumMonthLength(calendarDate: CalendarYM) {\r\n    return this.minimumMonthLength(calendarDate);\r\n  },\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    return monthCode === 'M13' ? 6 : 30;\r\n  }\r\n};\r\nabstract class OrthodoxBaseHelperFixedEpoch extends GregorianBaseHelperFixedEpoch {\r\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\r\n    super(id, isoEpoch);\r\n  }\r\n  override inLeapYear = OrthodoxOps.inLeapYear;\r\n  override monthsInYear = OrthodoxOps.monthsInYear;\r\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\r\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\r\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\r\n}\r\nabstract class OrthodoxBaseHelper extends GregorianBaseHelper {\r\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\r\n    super(id, originalEras);\r\n  }\r\n  override inLeapYear = OrthodoxOps.inLeapYear;\r\n  override monthsInYear = OrthodoxOps.monthsInYear;\r\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\r\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\r\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\r\n}\r\n\r\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\r\n// with the following differences:\r\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\r\n//   two use negative year numbers before epoch)\r\n// - Coptic has a different epoch date\r\n// - Ethiopic has an additional second era that starts at the same date as the\r\n//   zero era of ethioaa.\r\nclass EthioaaHelper extends OrthodoxBaseHelperFixedEpoch {\r\n  constructor() {\r\n    super('ethioaa', { year: -5492, month: 7, day: 17 });\r\n  }\r\n}\r\nclass CopticHelper extends OrthodoxBaseHelper {\r\n  constructor() {\r\n    super('coptic', [\r\n      { code: 'coptic', isoEpoch: { year: 284, month: 8, day: 29 } },\r\n      { code: 'coptic-inverse', reverseOf: 'coptic' }\r\n    ]);\r\n  }\r\n}\r\n\r\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\r\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\r\nclass EthiopicHelper extends OrthodoxBaseHelper {\r\n  constructor() {\r\n    super('ethiopic', [\r\n      { code: 'ethioaa', names: ['ethiopic-amete-alem', 'mundi'], isoEpoch: { year: -5492, month: 7, day: 17 } },\r\n      { code: 'ethiopic', names: ['incar'], isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\r\n    ]);\r\n  }\r\n}\r\n\r\nclass RocHelper extends SameMonthDayAsGregorianBaseHelper {\r\n  constructor() {\r\n    super('roc', [\r\n      { code: 'roc', names: ['minguo'], isoEpoch: { year: 1912, month: 1, day: 1 } },\r\n      { code: 'roc-inverse', names: ['before-roc'], reverseOf: 'roc' }\r\n    ]);\r\n  }\r\n}\r\n\r\nclass BuddhistHelper extends GregorianBaseHelperFixedEpoch {\r\n  constructor() {\r\n    super('buddhist', { year: -543, month: 1, day: 1 });\r\n  }\r\n}\r\n\r\nclass GregoryHelper extends SameMonthDayAsGregorianBaseHelper {\r\n  constructor() {\r\n    super('gregory', [\r\n      { code: 'gregory', names: ['ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\r\n      { code: 'gregory-inverse', names: ['be', 'bce'], reverseOf: 'gregory' }\r\n    ]);\r\n  }\r\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T /*, isoDate: IsoDate*/): T {\r\n    let { era, eraYear } = calendarDate;\r\n    // Firefox 96 introduced a bug where the `'short'` format of the era\r\n    // option mistakenly returns the one-letter (narrow) format instead. The\r\n    // code below handles either the correct or Firefox-buggy format. See\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\r\n    if (era === 'b') era = 'gregory-inverse';\r\n    if (era === 'a') era = 'gregory';\r\n    return { era, eraYear } as T;\r\n  }\r\n}\r\n\r\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\r\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\r\n// eras include:\r\n// - Start/end dates of older eras are not precisely defined, which is\r\n//   challenging given Temporal's need for precision\r\n// - Some era dates and/or names are disputed by historians\r\n// - As historical research proceeds, new eras are discovered and existing era\r\n//   dates are modified, leading to considerable churn which is not good for\r\n//   Temporal use.\r\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\r\n//    on future historical scholarship\r\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\r\n//    that's not reflected in the ICU implementation.\r\n//\r\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\r\n//\r\n// Here's a full list of CLDR/ICU eras:\r\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\r\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\r\n//\r\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\r\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\r\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\r\n// Japanese calendar doesn't seem to take this into account, so neither do we:\r\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\r\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\r\n// '1 1, 6 Meiji, 12:00:00 PM'\r\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\r\n// '12 31, 5 Meiji, 12:00:00 PM'\r\nclass JapaneseHelper extends SameMonthDayAsGregorianBaseHelper {\r\n  constructor() {\r\n    super('japanese', [\r\n      // The Japanese calendar `year` is just the ISO year, because (unlike other\r\n      // ICU calendars) there's no obvious \"default era\", we use the ISO year.\r\n      { code: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\r\n      { code: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\r\n      { code: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\r\n      { code: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\r\n      { code: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\r\n      { code: 'japanese', names: ['japanese', 'gregory', 'ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\r\n      { code: 'japanese-inverse', names: ['japanese-inverse', 'gregory-inverse', 'bc', 'bce'], reverseOf: 'japanese' }\r\n    ]);\r\n  }\r\n\r\n  override erasBeginMidYear = true;\r\n\r\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T {\r\n    const { era, eraYear } = calendarDate;\r\n    const { year: isoYear } = isoDate;\r\n    if (this.eras.find((e) => e.code === era)) return { era, eraYear } as T;\r\n    return (\r\n      isoYear < 1 ? { era: 'japanese-inverse', eraYear: 1 - isoYear } : { era: 'japanese', eraYear: isoYear }\r\n    ) as T;\r\n  }\r\n}\r\n\r\ninterface ChineseMonthInfo {\r\n  [key: string]: { monthIndex: number; daysInMonth: number };\r\n}\r\ninterface ChineseDraftMonthInfo {\r\n  [key: string]: { monthIndex: number; daysInMonth?: number };\r\n}\r\n\r\nabstract class ChineseBaseHelper extends HelperBase {\r\n  abstract override id: BuiltinCalendarId;\r\n  calendarType = 'lunisolar' as const;\r\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    const months = this.getMonthList(calendarDate.year, cache);\r\n    return Object.entries(months).length === 13;\r\n  }\r\n  monthsInYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\r\n    return this.inLeapYear(calendarDate, cache) ? 13 : 12;\r\n  }\r\n  minimumMonthLength(/* calendarDate */) {\r\n    return 29;\r\n  }\r\n  maximumMonthLength(/* calendarDate */) {\r\n    return 30;\r\n  }\r\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\r\n    // See note below about ICU4C vs ICU4X. It is possible this override should\r\n    // always return 30.\r\n    return ['M01L', 'M09L', 'M10L', 'M11L', 'M12L'].includes(monthCode) ? 29 : 30;\r\n  }\r\n  override monthDaySearchStartYear(monthCode: string, day: number) {\r\n    // Note that ICU4C actually has _no_ years in which leap months M01L and\r\n    // M09L through M12L have 30 days. The values marked with (*) here are years\r\n    // in which the leap month occurs with 29 days. ICU4C disagrees with ICU4X\r\n    // here and it is not clear which is correct.\r\n    const monthMap: Record<string, [number, number]> = {\r\n      M01L: [1651, 1651], // *\r\n      M02L: [1947, 1765],\r\n      M03L: [1966, 1955],\r\n      M04L: [1963, 1944],\r\n      M05L: [1971, 1952],\r\n      M06L: [1960, 1941],\r\n      M07L: [1968, 1938],\r\n      M08L: [1957, 1718],\r\n      M09L: [1832, 1832], // *\r\n      M10L: [1870, 1870], // *\r\n      M11L: [1814, 1814], // *\r\n      M12L: [1890, 1890] // *\r\n    };\r\n    const years = monthMap[monthCode] ?? [1972, 1972];\r\n    return day < 30 ? years[0] : years[1];\r\n  }\r\n  getMonthList(calendarYear: number, cache: OneObjectCache): ChineseMonthInfo {\r\n    if (calendarYear === undefined) {\r\n      throw new TypeError('Missing year');\r\n    }\r\n    const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\r\n    const cached = cache.get(key);\r\n    if (cached) return cached;\r\n    const dateTimeFormat = this.getFormatter();\r\n    const getCalendarDate = (isoYear: number, daysPastFeb1: number) => {\r\n      const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\r\n      const legacyDate = new Date(isoStringFeb1);\r\n      // Now add the requested number of days, which may wrap to the next month.\r\n      legacyDate.setUTCDate(daysPastFeb1 + 1);\r\n      const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\r\n      // The 'month' and 'day' parts are guaranteed to be present because the\r\n      // formatter was created with month and day options.\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month')!.value;\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      const calendarDay = +newYearGuess.find((tv) => tv.type === 'day')!.value;\r\n      const calendarYearPartToVerify = newYearGuess.find((tv) => (tv.type as string) === 'relatedYear');\r\n      let calendarYearToVerify: number | undefined;\r\n      if (calendarYearPartToVerify !== undefined) {\r\n        calendarYearToVerify = +calendarYearPartToVerify.value;\r\n      } else {\r\n        // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\r\n        // output of Intl.DateTimeFormat.formatToParts.\r\n        throw new RangeError(\r\n          `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\r\n        );\r\n      }\r\n      return { calendarMonthString, calendarDay, calendarYearToVerify };\r\n    };\r\n\r\n    // First, find a date close to Chinese New Year. Feb 17 will either be in\r\n    // the first month or near the end of the last month of the previous year.\r\n    let isoDaysDelta = 17;\r\n    let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\r\n\r\n    // If we didn't guess the first month correctly, add (almost in some months)\r\n    // a lunar month\r\n    if (calendarMonthString !== '1') {\r\n      isoDaysDelta += 29;\r\n      ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\r\n    }\r\n\r\n    // Now back up to near the start of the first month, but not too near that\r\n    // off-by-one issues matter.\r\n    isoDaysDelta -= calendarDay - 5;\r\n    const result = {} as ChineseDraftMonthInfo;\r\n    let monthIndex = 1;\r\n    let oldCalendarDay: number | undefined;\r\n    let oldMonthString: string | undefined;\r\n    let done = false;\r\n    do {\r\n      ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\r\n      if (oldCalendarDay) {\r\n        result[oldMonthString as string].daysInMonth = oldCalendarDay + 30 - calendarDay;\r\n      }\r\n      if (calendarYearToVerify !== calendarYear) {\r\n        done = true;\r\n      } else {\r\n        result[calendarMonthString] = { monthIndex: monthIndex++ };\r\n        // Move to the next month. Because months are sometimes 29 days, the day of the\r\n        // calendar month will move forward slowly but not enough to flip over to a new\r\n        // month before the loop ends at 12-13 months.\r\n        isoDaysDelta += 30;\r\n      }\r\n      oldCalendarDay = calendarDay;\r\n      oldMonthString = calendarMonthString;\r\n    } while (!done);\r\n    result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\r\n\r\n    cache.set(key, result);\r\n    return result as ChineseMonthInfo;\r\n  }\r\n  estimateIsoDate(calendarDate: CalendarYMD) {\r\n    const { year, month } = calendarDate;\r\n    return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\r\n  }\r\n  override adjustCalendarDate(\r\n    calendarDate: Partial<FullCalendarDate>,\r\n    cache: OneObjectCache,\r\n    overflow: Overflow = 'constrain',\r\n    fromLegacyDate = false\r\n  ): FullCalendarDate {\r\n    let { year, month, monthExtra, day, monthCode } = calendarDate;\r\n    if (year === undefined) throw new TypeError('Missing property: year');\r\n    if (fromLegacyDate) {\r\n      // Legacy Date output returns a string that's an integer with an optional\r\n      // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\r\n      // month. Below we'll normalize the output.\r\n      if (monthExtra && monthExtra !== 'bis') throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\r\n      const monthCode = buildMonthCode(month as number, monthExtra !== undefined);\r\n      const monthString = `${month}${monthExtra || ''}`;\r\n      const months = this.getMonthList(year, cache);\r\n      const monthInfo = months[monthString];\r\n      if (monthInfo === undefined) throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\r\n      month = monthInfo.monthIndex;\r\n      return { year, month, day: day as number, monthCode };\r\n    } else {\r\n      // When called without input coming from legacy Date output,\r\n      // simply ensure that all fields are present.\r\n      this.validateCalendarDate(calendarDate);\r\n      if (month === undefined) {\r\n        ES.assertExists(monthCode);\r\n        const months = this.getMonthList(year, cache);\r\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\r\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\r\n        let monthInfo = months[numberPart];\r\n        month = monthInfo && monthInfo.monthIndex;\r\n\r\n        // If this leap month isn't present in this year, constrain to the same\r\n        // day of the previous month.\r\n        if (month === undefined && monthCode.endsWith('L') && monthCode != 'M13L' && overflow === 'constrain') {\r\n          const withoutML = +monthCode.replace(/^M0?|L$/g, '');\r\n          monthInfo = months[withoutML];\r\n          if (monthInfo) {\r\n            month = monthInfo.monthIndex;\r\n            monthCode = buildMonthCode(withoutML);\r\n          }\r\n        }\r\n        if (month === undefined) {\r\n          throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\r\n        }\r\n      } else if (monthCode === undefined) {\r\n        const months = this.getMonthList(year, cache);\r\n        const monthEntries = Object.entries(months);\r\n        const largestMonth = monthEntries.length;\r\n        if (overflow === 'reject') {\r\n          ES.RejectToRange(month, 1, largestMonth);\r\n          ES.RejectToRange(day as number, 1, this.maximumMonthLength());\r\n        } else {\r\n          month = ES.ConstrainToRange(month, 1, largestMonth);\r\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\r\n        }\r\n        const matchingMonthEntry = monthEntries.find((entry) => entry[1].monthIndex === month);\r\n        if (matchingMonthEntry === undefined) {\r\n          throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\r\n        }\r\n        monthCode = buildMonthCode(\r\n          +matchingMonthEntry[0].replace('bis', ''),\r\n          matchingMonthEntry[0].indexOf('bis') !== -1\r\n        );\r\n      } else {\r\n        // Both month and monthCode are present. Make sure they don't conflict.\r\n        const months = this.getMonthList(year, cache);\r\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\r\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\r\n        const monthInfo = months[numberPart];\r\n        if (!monthInfo) throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\r\n        if (month !== monthInfo.monthIndex) {\r\n          throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\r\n        }\r\n      }\r\n      return { ...calendarDate, year, month, monthCode, day: day as number };\r\n    }\r\n  }\r\n}\r\n\r\nclass ChineseHelper extends ChineseBaseHelper {\r\n  id = 'chinese' as const;\r\n}\r\n\r\n// Dangi (Korean) calendar has same implementation as Chinese\r\nclass DangiHelper extends ChineseBaseHelper {\r\n  id = 'dangi' as const;\r\n}\r\n\r\n/**\r\n * Common implementation of all non-ISO calendars.\r\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\r\n * This split allowed an easy separation between code that was similar between\r\n * ISO and non-ISO implementations vs. code that was very different.\r\n */\r\nclass NonIsoCalendar implements CalendarImpl {\r\n  constructor(private readonly helper: HelperBase) {}\r\n  extraFields(fields: FieldKey[]): FieldKey[] {\r\n    if (this.helper.hasEra && fields.includes('year')) {\r\n      return ['era', 'eraYear'];\r\n    }\r\n    return [];\r\n  }\r\n  resolveFields(fields: CalendarFieldsRecord /* , type */) {\r\n    if (this.helper.calendarType !== 'lunisolar') {\r\n      const cache = new OneObjectCache();\r\n      const largestMonth = this.helper.monthsInYear({ year: fields.year ?? 1972 }, cache);\r\n      resolveNonLunisolarMonth(fields, undefined, largestMonth);\r\n    }\r\n  }\r\n  dateToISO(fields: CalendarDateFields, overflow: Overflow) {\r\n    const cache = new OneObjectCache();\r\n    const result = this.helper.calendarToIsoDate(fields, overflow, cache);\r\n    cache.setObject(result);\r\n    return result;\r\n  }\r\n  monthDayToISOReferenceDate(fields: MonthDayFromFieldsObject, overflow: Overflow) {\r\n    const cache = new OneObjectCache();\r\n    const result = this.helper.monthDayFromFields(fields, overflow, cache);\r\n    // result.year is a reference year where this month/day exists in this calendar\r\n    cache.setObject(result);\r\n    return result;\r\n  }\r\n  fieldKeysToIgnore(\r\n    keys: Exclude<keyof Temporal.PlainDateLike, 'calendar'>[]\r\n  ): Exclude<keyof Temporal.PlainDateLike, 'calendar'>[] {\r\n    const result = new Set<(typeof keys)[number]>();\r\n    for (let ix = 0; ix < keys.length; ix++) {\r\n      const key = keys[ix];\r\n      result.add(key);\r\n      switch (key) {\r\n        case 'era':\r\n          result.add('eraYear');\r\n          result.add('year');\r\n          break;\r\n        case 'eraYear':\r\n          result.add('era');\r\n          result.add('year');\r\n          break;\r\n        case 'year':\r\n          result.add('era');\r\n          result.add('eraYear');\r\n          break;\r\n        case 'month':\r\n          result.add('monthCode');\r\n          // See https://github.com/tc39/proposal-temporal/issues/1784\r\n          if (this.helper.erasBeginMidYear) {\r\n            result.add('era');\r\n            result.add('eraYear');\r\n          }\r\n          break;\r\n        case 'monthCode':\r\n          result.add('month');\r\n          if (this.helper.erasBeginMidYear) {\r\n            result.add('era');\r\n            result.add('eraYear');\r\n          }\r\n          break;\r\n        case 'day':\r\n          if (this.helper.erasBeginMidYear) {\r\n            result.add('era');\r\n            result.add('eraYear');\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    return arrayFromSet(result);\r\n  }\r\n  dateAdd(isoDate: ISODate, { years, months, weeks, days }: DateDuration, overflow: Overflow) {\r\n    const cache = OneObjectCache.getCacheForObject(isoDate);\r\n    const calendarDate = this.helper.isoToCalendarDate(isoDate, cache);\r\n    const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\r\n    const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\r\n    // The new object's cache starts with the cache of the old object\r\n    if (!OneObjectCache.getCacheForObject(isoAdded)) {\r\n      const newCache = new OneObjectCache(cache);\r\n      newCache.setObject(isoAdded);\r\n    }\r\n    return isoAdded;\r\n  }\r\n  dateUntil(one: ISODate, two: ISODate, largestUnit: Temporal.DateUnit) {\r\n    const cacheOne = OneObjectCache.getCacheForObject(one);\r\n    const cacheTwo = OneObjectCache.getCacheForObject(two);\r\n    const calendarOne = this.helper.isoToCalendarDate(one, cacheOne);\r\n    const calendarTwo = this.helper.isoToCalendarDate(two, cacheTwo);\r\n    const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\r\n    return result;\r\n  }\r\n  isoToDate<\r\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\r\n    T extends {\r\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\r\n    }\r\n  >(isoDate: ISODate, requestedFields: Request): T {\r\n    const cache = OneObjectCache.getCacheForObject(isoDate);\r\n    const calendarDate: Partial<CalendarDateRecord> & FullCalendarDate = this.helper.isoToCalendarDate(isoDate, cache);\r\n    if (requestedFields.dayOfWeek) {\r\n      calendarDate.dayOfWeek = impl['iso8601'].isoToDate(isoDate, { dayOfWeek: true }).dayOfWeek;\r\n    }\r\n    if (requestedFields.dayOfYear) {\r\n      const startOfYear = this.helper.startOfCalendarYear(calendarDate);\r\n      const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\r\n      calendarDate.dayOfYear = diffDays + 1;\r\n    }\r\n    if (requestedFields.weekOfYear) calendarDate.weekOfYear = calendarDateWeekOfYear(this.helper.id, isoDate);\r\n    calendarDate.daysInWeek = 7;\r\n    if (requestedFields.daysInMonth) calendarDate.daysInMonth = this.helper.daysInMonth(calendarDate, cache);\r\n    if (requestedFields.daysInYear) {\r\n      const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\r\n      const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\r\n      calendarDate.daysInYear = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\r\n    }\r\n    if (requestedFields.monthsInYear) calendarDate.monthsInYear = this.helper.monthsInYear(calendarDate, cache);\r\n    if (requestedFields.inLeapYear) calendarDate.inLeapYear = this.helper.inLeapYear(calendarDate, cache);\r\n    return calendarDate as T;\r\n  }\r\n  getFirstDayOfWeek(): number | undefined {\r\n    return this.helper.getFirstDayOfWeek();\r\n  }\r\n  getMinimalDaysInFirstWeek(): number | undefined {\r\n    return this.helper.getMinimalDaysInFirstWeek();\r\n  }\r\n}\r\n\r\nfor (const Helper of [\r\n  HebrewHelper,\r\n  PersianHelper,\r\n  EthiopicHelper,\r\n  EthioaaHelper,\r\n  CopticHelper,\r\n  ChineseHelper,\r\n  DangiHelper,\r\n  RocHelper,\r\n  IndianHelper,\r\n  BuddhistHelper,\r\n  GregoryHelper,\r\n  JapaneseHelper,\r\n  IslamicHelper,\r\n  IslamicUmalquraHelper,\r\n  IslamicTblaHelper,\r\n  IslamicCivilHelper,\r\n  IslamicRgsaHelper,\r\n  IslamicCcHelper\r\n]) {\r\n  const helper = new Helper();\r\n  // Construct a new NonIsoCalendar instance with the given Helper implementation that contains\r\n  // per-calendar logic.\r\n  impl[helper.id] = new NonIsoCalendar(helper);\r\n}\r\n\r\nfunction calendarImpl(calendar: BuiltinCalendarId) {\r\n  return impl[calendar];\r\n}\r\n// Probably not what the intrinsics mechanism was intended for, but view this as\r\n// an export of calendarImpl while avoiding circular dependencies\r\nDefineIntrinsic('calendarImpl', calendarImpl);\r\n","import { assert } from './assert';\r\nimport * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport {\r\n  CAL_ID,\r\n  CALENDAR,\r\n  CreateSlots,\r\n  DATE,\r\n  DATETIME,\r\n  DAYS,\r\n  EPOCHNANOSECONDS,\r\n  GetSlot,\r\n  HasSlot,\r\n  HOURS,\r\n  INST,\r\n  ISO_DATE,\r\n  ISO_DATE_TIME,\r\n  LOCALE,\r\n  MD,\r\n  MICROSECONDS,\r\n  MILLISECONDS,\r\n  MINUTES,\r\n  MONTHS,\r\n  NANOSECONDS,\r\n  OPTIONS,\r\n  ORIGINAL,\r\n  ResetSlot,\r\n  SECONDS,\r\n  SetSlot,\r\n  TIME,\r\n  TIME_FMT,\r\n  TZ_CANONICAL,\r\n  TZ_ORIGINAL,\r\n  WEEKS,\r\n  YEARS,\r\n  YM\r\n} from './slots';\r\nimport type { Temporal } from '..';\r\nimport type { DateTimeFormatParams as Params, DateTimeFormatReturn as Return } from './internaltypes';\r\n\r\n// Save the original Intl.DateTimeFormat, it will likely be overwritten\r\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\r\n\r\ntype LazySlot = typeof DATE | typeof YM | typeof MD | typeof TIME_FMT | typeof DATETIME | typeof INST;\r\n\r\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\r\n// so we'll only create those instances when we need them.\r\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\r\nfunction getSlotLazy(obj: DateTimeFormatImpl, slot: LazySlot) {\r\n  let val = GetSlot(obj, slot);\r\n  if (typeof val === 'function') {\r\n    // If we get here, `val` is an \"amender function\". It will take the user's\r\n    // options and transform them into suitable options to be passed into the\r\n    // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\r\n    // will vary depending on the Temporal type, so that's why we store separate\r\n    // formatters in separate props on the polyfill's DateTimeFormat instances.\r\n    // The efficiency happens because we don't create an (expensive) formatter\r\n    // until the user calls toLocaleString for that Temporal type.\r\n    val = new OriginalIntlDateTimeFormat(GetSlot(obj, LOCALE), val(GetSlot(obj, OPTIONS)));\r\n    ResetSlot(obj, slot, val);\r\n  }\r\n  return val;\r\n}\r\n\r\nfunction createDateTimeFormat(\r\n  dtf: DateTimeFormatImpl,\r\n  locale: Params['constructor'][0],\r\n  optionsParam: Params['constructor'][1]\r\n) {\r\n  const hasOptions = typeof optionsParam !== 'undefined';\r\n  let options: Intl.DateTimeFormatOptions;\r\n  if (hasOptions) {\r\n    // Read all the options in the expected order and copy them to a\r\n    // null-prototype object with which we can do further operations\r\n    // unobservably\r\n    const props: (keyof Intl.DateTimeFormatOptions)[] = [\r\n      'localeMatcher',\r\n      'calendar',\r\n      'numberingSystem',\r\n      'hour12',\r\n      'hourCycle',\r\n      'timeZone',\r\n      'weekday',\r\n      'era',\r\n      'year',\r\n      'month',\r\n      'day',\r\n      'dayPeriod',\r\n      'hour',\r\n      'minute',\r\n      'second',\r\n      'fractionalSecondDigits',\r\n      'timeZoneName',\r\n      'formatMatcher',\r\n      'dateStyle',\r\n      'timeStyle'\r\n    ];\r\n    options = ES.ToObject(optionsParam);\r\n    const newOptions = Object.create(null);\r\n    for (let i = 0; i < props.length; i++) {\r\n      const prop = props[i];\r\n      if (Object.prototype.hasOwnProperty.call(options, prop)) {\r\n        newOptions[prop] = options[prop];\r\n      }\r\n    }\r\n    options = newOptions;\r\n  } else {\r\n    options = Object.create(null);\r\n  }\r\n  const original = new OriginalIntlDateTimeFormat(locale, options);\r\n  const ro = original.resolvedOptions();\r\n\r\n  CreateSlots(dtf);\r\n\r\n  // DateTimeFormat instances are very expensive to create. Therefore, they will\r\n  // be lazily created only when needed, using the locale and options provided.\r\n  // But it's possible for callers to mutate those inputs before lazy creation\r\n  // happens. For this reason, we clone the inputs instead of caching the\r\n  // original objects. To avoid the complexity of deep cloning any inputs that\r\n  // are themselves objects (e.g. the locales array, or options property values\r\n  // that will be coerced to strings), we rely on `resolvedOptions()` to do the\r\n  // coercion and cloning for us. Unfortunately, we can't just use the resolved\r\n  // options as-is because our options-amending logic adds additional fields if\r\n  // the user doesn't supply any unit fields like year, month, day, hour, etc.\r\n  // Therefore, we limit the properties in the clone to properties that were\r\n  // present in the original input.\r\n  if (hasOptions) {\r\n    const clonedResolved = Object.assign(Object.create(null), ro);\r\n    for (const prop in clonedResolved) {\r\n      if (!Object.prototype.hasOwnProperty.call(options, prop)) {\r\n        delete clonedResolved[prop as keyof typeof clonedResolved];\r\n      }\r\n    }\r\n    // hour12/hourCycle don't show up in resolvedOptions() unless the chosen\r\n    // format includes an hour component, so copy them explicitly in case they\r\n    // would otherwise be lost\r\n    clonedResolved.hour12 = options.hour12;\r\n    clonedResolved.hourCycle = options.hourCycle;\r\n    SetSlot(dtf, OPTIONS, clonedResolved);\r\n  } else {\r\n    SetSlot(dtf, OPTIONS, options);\r\n  }\r\n\r\n  SetSlot(dtf, LOCALE, ro.locale);\r\n  SetSlot(dtf, ORIGINAL, original);\r\n  SetSlot(dtf, TZ_CANONICAL, ro.timeZone);\r\n  SetSlot(dtf, CAL_ID, ro.calendar);\r\n  SetSlot(dtf, DATE, dateAmend);\r\n  SetSlot(dtf, YM, yearMonthAmend);\r\n  SetSlot(dtf, MD, monthDayAmend);\r\n  SetSlot(dtf, TIME_FMT, timeAmend);\r\n  SetSlot(dtf, DATETIME, datetimeAmend);\r\n  SetSlot(dtf, INST, instantAmend);\r\n\r\n  // Save the original time zone, for a few reasons:\r\n  // - Clearer error messages\r\n  // - More clearly follows the spec for InitializeDateTimeFormat\r\n  // - Because it follows the spec more closely, will make it easier to integrate\r\n  //   support of offset strings and other potential changes like proposal-canonical-tz.\r\n  const timeZoneOption = hasOptions ? options.timeZone : undefined;\r\n  if (timeZoneOption === undefined) {\r\n    SetSlot(dtf, TZ_ORIGINAL, ro.timeZone);\r\n  } else {\r\n    const id = ES.ToString(timeZoneOption);\r\n    if (id.startsWith('−')) {\r\n      // The initial (Node 23) implementation of offset time zones allowed use\r\n      // of the Unicode minus sign, which was disallowed by a later spec change.\r\n      throw new RangeError('Unicode minus (U+2212) is not supported in time zone offsets');\r\n    }\r\n    // store a normalized identifier\r\n    SetSlot(dtf, TZ_ORIGINAL, ES.ToTemporalTimeZoneIdentifier(id));\r\n  }\r\n  return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\r\n}\r\n\r\nfunction IsPatchedDateTimeFormat(item: unknown): item is DateTimeFormatImpl {\r\n  return HasSlot(item, ORIGINAL);\r\n}\r\n\r\nclass DateTimeFormatImpl {\r\n  constructor(locales: Params['constructor'][0] = undefined, options: Params['constructor'][1] = undefined) {\r\n    createDateTimeFormat(this, locales, options);\r\n  }\r\n\r\n  get format() {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    const boundFormat = format.bind(this);\r\n    Object.defineProperties(boundFormat, {\r\n      length: { value: 1, enumerable: false, writable: false, configurable: true },\r\n      name: { value: '', enumerable: false, writable: false, configurable: true }\r\n    });\r\n    return boundFormat;\r\n  }\r\n\r\n  formatRange(a: Params['formatRange'][0], b: Params['formatRange'][1]): Return['formatRange'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return formatRange.call(this, a, b);\r\n  }\r\n\r\n  formatToParts?<P extends readonly unknown[]>(\r\n    datetime: Params['formatToParts'][0],\r\n    ...rest: P\r\n  ): Return['formatToParts'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return formatToParts.call(this, datetime, ...rest);\r\n  }\r\n\r\n  formatRangeToParts?(\r\n    a: Params['formatRangeToParts'][0],\r\n    b: Params['formatRangeToParts'][1]\r\n  ): Return['formatRangeToParts'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return formatRangeToParts.call(this, a, b);\r\n  }\r\n\r\n  resolvedOptions(): Return['resolvedOptions'] {\r\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\r\n    return resolvedOptions.call(this);\r\n  }\r\n}\r\n\r\nif (!('formatToParts' in OriginalIntlDateTimeFormat.prototype)) {\r\n  delete DateTimeFormatImpl.prototype.formatToParts;\r\n}\r\n\r\nif (!('formatRangeToParts' in OriginalIntlDateTimeFormat.prototype)) {\r\n  delete DateTimeFormatImpl.prototype.formatRangeToParts;\r\n}\r\nexport type { DateTimeFormatImpl };\r\n\r\ninterface DateTimeFormatInterface {\r\n  (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\r\n  new (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\r\n  supportedLocalesOf: typeof Intl.DateTimeFormat.supportedLocalesOf;\r\n}\r\n\r\n// A non-class constructor is needed because Intl.DateTimeFormat must be able to\r\n// be called without 'new'\r\nexport const DateTimeFormat = function (\r\n  locales: Params['constructor'][0] = undefined,\r\n  options: Params['constructor'][1] = undefined\r\n): DateTimeFormatImpl {\r\n  return new DateTimeFormatImpl(locales, options);\r\n} as unknown as DateTimeFormatInterface;\r\nDateTimeFormatImpl.prototype.constructor = DateTimeFormat;\r\n\r\nObject.defineProperty(DateTimeFormat, 'prototype', {\r\n  value: DateTimeFormatImpl.prototype,\r\n  writable: false,\r\n  enumerable: false,\r\n  configurable: false\r\n});\r\nDateTimeFormat.supportedLocalesOf = OriginalIntlDateTimeFormat.supportedLocalesOf;\r\nMakeIntrinsicClass(DateTimeFormat as unknown as typeof Intl.DateTimeFormat, 'Intl.DateTimeFormat');\r\n\r\nfunction resolvedOptions(this: DateTimeFormatImpl): Return['resolvedOptions'] {\r\n  const resolved = GetSlot(this, ORIGINAL).resolvedOptions();\r\n  resolved.timeZone = GetSlot(this, TZ_ORIGINAL);\r\n  return resolved;\r\n}\r\n\r\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\r\n// And if so, why doesn't formatRange also accept extra params?\r\nfunction format<P extends readonly unknown[]>(\r\n  this: DateTimeFormatImpl,\r\n  datetime: Params['format'][0],\r\n  ...rest: P\r\n): Return['format'] {\r\n  let overrides = extractOverrides(datetime, this);\r\n  let formatter, formatArgs: [Params['format'][0], ...unknown[]];\r\n  if (overrides.formatter) {\r\n    formatter = overrides.formatter;\r\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\r\n  } else {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n    formatArgs = [datetime, ...rest];\r\n  }\r\n  return formatter.format(...(formatArgs as [number | Date | undefined]));\r\n}\r\n\r\nfunction formatToParts<P extends readonly unknown[]>(\r\n  this: DateTimeFormatImpl,\r\n  datetime: Params['formatToParts'][0],\r\n  ...rest: P\r\n): Return['formatToParts'] {\r\n  let overrides = extractOverrides(datetime, this);\r\n  let formatter, formatArgs;\r\n  if (overrides.formatter) {\r\n    formatter = overrides.formatter;\r\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\r\n  } else {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n    formatArgs = [datetime, ...rest];\r\n  }\r\n  return formatter.formatToParts(...(formatArgs as [number | Date | undefined]));\r\n}\r\n\r\nfunction formatRange(this: DateTimeFormatImpl, aParam: Params['formatRange'][0], bParam: Params['formatRange'][1]) {\r\n  if (aParam === undefined || bParam === undefined) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\r\n  }\r\n  const a = toDateTimeFormattable(aParam);\r\n  const b = toDateTimeFormattable(bParam);\r\n  let formatArgs = [a, b] as const;\r\n  let formatter;\r\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\r\n  }\r\n  if (isTemporalObject(a)) {\r\n    if (!sameTemporalType(a, b)) {\r\n      throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\r\n    }\r\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\r\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\r\n    if (aformatter) {\r\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\r\n      formatter = aformatter;\r\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\r\n    }\r\n  }\r\n  if (!formatter) {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n  }\r\n  return formatter.formatRange(...(formatArgs as [number, number]));\r\n}\r\n\r\nfunction formatRangeToParts(\r\n  this: DateTimeFormatImpl,\r\n  aParam: Params['formatRangeToParts'][0],\r\n  bParam: Params['formatRangeToParts'][1]\r\n) {\r\n  if (aParam === undefined || bParam === undefined) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\r\n  }\r\n  const a = toDateTimeFormattable(aParam);\r\n  const b = toDateTimeFormattable(bParam);\r\n  let formatArgs = [a, b] as const;\r\n  let formatter;\r\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\r\n    throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\r\n  }\r\n  if (isTemporalObject(a)) {\r\n    if (!sameTemporalType(a, b)) {\r\n      throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\r\n    }\r\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\r\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\r\n    if (aformatter) {\r\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\r\n      formatter = aformatter;\r\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\r\n    }\r\n  }\r\n  if (!formatter) {\r\n    formatter = GetSlot(this, ORIGINAL);\r\n  }\r\n  return formatter.formatRangeToParts(...(formatArgs as [number, number]));\r\n}\r\n\r\n// \"false\" is a signal to delete this option\r\ntype MaybeFalseOptions = {\r\n  [K in keyof Intl.DateTimeFormatOptions]?: Intl.DateTimeFormatOptions[K] | false;\r\n};\r\n\r\nfunction amend(optionsParam: Intl.DateTimeFormatOptions = {}, amended: MaybeFalseOptions = {}) {\r\n  const options = Object.assign({}, optionsParam);\r\n  const props = [\r\n    'year',\r\n    'month',\r\n    'day',\r\n    'hour',\r\n    'minute',\r\n    'second',\r\n    'weekday',\r\n    'dayPeriod',\r\n    'timeZoneName',\r\n    'dateStyle',\r\n    'timeStyle'\r\n  ] as const;\r\n  for (let i = 0; i < props.length; i++) {\r\n    const opt = props[i];\r\n    // TODO: can this be typed more cleanly?\r\n    type OptionMaybeFalse = (typeof options)[typeof opt] | false;\r\n    (options[opt] as OptionMaybeFalse) = opt in amended ? amended[opt] : options[opt];\r\n    if ((options[opt] as OptionMaybeFalse) === false || options[opt] === undefined) delete options[opt];\r\n  }\r\n  return options;\r\n}\r\n\r\ntype OptionsType<T extends TypesWithToLocaleString> = NonNullable<Parameters<T['toLocaleString']>[1]>;\r\n\r\nfunction timeAmend(originalOptions: OptionsType<Temporal.PlainTime>) {\r\n  const options = amend(originalOptions, {\r\n    year: false,\r\n    month: false,\r\n    day: false,\r\n    weekday: false,\r\n    timeZoneName: false,\r\n    dateStyle: false\r\n  });\r\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\r\n    // Try to fake what timeStyle should do if not printing the time zone name\r\n    delete options.timeStyle;\r\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\r\n  }\r\n  if (!hasTimeOptions(options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format Temporal.PlainTime with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, {\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction yearMonthAmend(originalOptions: OptionsType<Temporal.PlainYearMonth>) {\r\n  // Try to fake what dateStyle should do for dates without a day. This is not\r\n  // accurate for locales that always print the era\r\n  const dateStyleHacks = {\r\n    short: { year: '2-digit', month: 'numeric' },\r\n    medium: { year: 'numeric', month: 'short' },\r\n    long: { year: 'numeric', month: 'long' },\r\n    full: { year: 'numeric', month: 'long' }\r\n  };\r\n  const options = amend(originalOptions, {\r\n    day: false,\r\n    hour: false,\r\n    minute: false,\r\n    second: false,\r\n    weekday: false,\r\n    dayPeriod: false,\r\n    timeZoneName: false,\r\n    timeStyle: false\r\n  });\r\n  if ('dateStyle' in options && options.dateStyle) {\r\n    const style = options.dateStyle;\r\n    delete options.dateStyle;\r\n    Object.assign(options, dateStyleHacks[style]);\r\n  }\r\n  if (!('year' in options || 'month' in options || 'era' in options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainYearMonth with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, { year: 'numeric', month: 'numeric' });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction monthDayAmend(originalOptions: OptionsType<Temporal.PlainMonthDay>) {\r\n  // Try to fake what dateStyle should do for dates without a day\r\n  const dateStyleHacks = {\r\n    short: { month: 'numeric', day: 'numeric' },\r\n    medium: { month: 'short', day: 'numeric' },\r\n    long: { month: 'long', day: 'numeric' },\r\n    full: { month: 'long', day: 'numeric' }\r\n  };\r\n  const options = amend(originalOptions, {\r\n    year: false,\r\n    hour: false,\r\n    minute: false,\r\n    second: false,\r\n    weekday: false,\r\n    dayPeriod: false,\r\n    timeZoneName: false,\r\n    timeStyle: false\r\n  });\r\n  if ('dateStyle' in options && options.dateStyle) {\r\n    const style = options.dateStyle;\r\n    delete options.dateStyle;\r\n    Object.assign(options, dateStyleHacks[style]);\r\n  }\r\n  if (!('month' in options || 'day' in options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainMonthDay with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, { month: 'numeric', day: 'numeric' });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction dateAmend(originalOptions: OptionsType<Temporal.PlainDate>) {\r\n  const options = amend(originalOptions, {\r\n    hour: false,\r\n    minute: false,\r\n    second: false,\r\n    dayPeriod: false,\r\n    timeZoneName: false,\r\n    timeStyle: false\r\n  });\r\n  if (!hasDateOptions(options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainDate with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, {\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction datetimeAmend(originalOptions: OptionsType<Temporal.PlainDateTime>) {\r\n  const options = amend(originalOptions, { timeZoneName: false });\r\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\r\n    // Try to fake what timeStyle should do if not printing the time zone name\r\n    delete options.timeStyle;\r\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\r\n\r\n    // If moving to a fake timeStyle while dateStyle is present, we also have to\r\n    // move to a fake dateStyle. dateStyle is mutually exclusive with hour etc.\r\n    if (options.dateStyle) {\r\n      const dateStyleHacks = {\r\n        short: { year: 'numeric', month: 'numeric', day: 'numeric' },\r\n        medium: { year: 'numeric', month: 'short', day: 'numeric' },\r\n        long: { year: 'numeric', month: 'long', day: 'numeric' },\r\n        full: { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' }\r\n      };\r\n      Object.assign(options, dateStyleHacks[options.dateStyle]);\r\n      delete options.dateStyle;\r\n    }\r\n  }\r\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\r\n    if (hasAnyDateTimeOptions(originalOptions)) {\r\n      throw new TypeError(`cannot format PlainDateTime with options [${Object.keys(originalOptions)}]`);\r\n    }\r\n    Object.assign(options, {\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction instantAmend(optionsParam: OptionsType<Temporal.Instant>) {\r\n  let options = optionsParam;\r\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\r\n    options = Object.assign({}, options, {\r\n      year: 'numeric',\r\n      month: 'numeric',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      second: 'numeric'\r\n    });\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction hasDateOptions(options: OptionsType<TypesWithToLocaleString>) {\r\n  return (\r\n    'year' in options ||\r\n    'month' in options ||\r\n    'day' in options ||\r\n    'weekday' in options ||\r\n    'dateStyle' in options ||\r\n    'era' in options\r\n  );\r\n}\r\n\r\nfunction hasTimeOptions(options: OptionsType<TypesWithToLocaleString>) {\r\n  return (\r\n    'hour' in options ||\r\n    'minute' in options ||\r\n    'second' in options ||\r\n    'timeStyle' in options ||\r\n    'dayPeriod' in options ||\r\n    'fractionalSecondDigits' in options\r\n  );\r\n}\r\n\r\nfunction hasAnyDateTimeOptions(originalOptions: OptionsType<TypesWithToLocaleString>) {\r\n  return (\r\n    hasDateOptions(originalOptions) ||\r\n    hasTimeOptions(originalOptions) ||\r\n    'dateStyle' in originalOptions ||\r\n    'timeStyle' in originalOptions ||\r\n    'timeZoneName' in originalOptions\r\n  );\r\n}\r\n\r\nfunction isTemporalObject(\r\n  obj: unknown\r\n): obj is\r\n  | Temporal.PlainDate\r\n  | Temporal.PlainTime\r\n  | Temporal.PlainDateTime\r\n  | Temporal.ZonedDateTime\r\n  | Temporal.PlainYearMonth\r\n  | Temporal.PlainMonthDay\r\n  | Temporal.Instant {\r\n  return (\r\n    ES.IsTemporalDate(obj) ||\r\n    ES.IsTemporalTime(obj) ||\r\n    ES.IsTemporalDateTime(obj) ||\r\n    ES.IsTemporalZonedDateTime(obj) ||\r\n    ES.IsTemporalYearMonth(obj) ||\r\n    ES.IsTemporalMonthDay(obj) ||\r\n    ES.IsTemporalInstant(obj)\r\n  );\r\n}\r\n\r\nfunction toDateTimeFormattable(value: unknown) {\r\n  if (isTemporalObject(value)) return value;\r\n  return ES.ToNumber(value);\r\n}\r\n\r\nfunction sameTemporalType(x: unknown, y: unknown) {\r\n  if (!isTemporalObject(x) || !isTemporalObject(y)) return false;\r\n  if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y)) return false;\r\n  if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y)) return false;\r\n  if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y)) return false;\r\n  if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y)) return false;\r\n  if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y)) return false;\r\n  if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y)) return false;\r\n  if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y)) return false;\r\n  return true;\r\n}\r\n\r\ntype TypesWithToLocaleString =\r\n  | Temporal.PlainDateTime\r\n  | Temporal.PlainDate\r\n  | Temporal.PlainTime\r\n  | Temporal.PlainYearMonth\r\n  | Temporal.PlainMonthDay\r\n  | Temporal.ZonedDateTime\r\n  | Temporal.Instant;\r\n\r\nfunction extractOverrides(temporalObj: Params['format'][0], main: DateTimeFormatImpl) {\r\n  if (ES.IsTemporalTime(temporalObj)) {\r\n    const isoDateTime = {\r\n      isoDate: { year: 1970, month: 1, day: 1 },\r\n      time: GetSlot(temporalObj, TIME)\r\n    };\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, TIME_FMT)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalYearMonth(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== mainCalendar) {\r\n      throw new RangeError(\r\n        `cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${mainCalendar}`\r\n      );\r\n    }\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, YM)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalMonthDay(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== mainCalendar) {\r\n      throw new RangeError(\r\n        `cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${mainCalendar}`\r\n      );\r\n    }\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, MD)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalDate(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\r\n      throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${mainCalendar}`);\r\n    }\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, DATE)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalDateTime(temporalObj)) {\r\n    const calendar = GetSlot(temporalObj, CALENDAR);\r\n    const mainCalendar = GetSlot(main, CAL_ID);\r\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\r\n      throw new RangeError(\r\n        `cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${mainCalendar}`\r\n      );\r\n    }\r\n    const isoDateTime = GetSlot(temporalObj, ISO_DATE_TIME);\r\n    return {\r\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\r\n      formatter: getSlotLazy(main, DATETIME)\r\n    };\r\n  }\r\n\r\n  if (ES.IsTemporalZonedDateTime(temporalObj)) {\r\n    throw new TypeError(\r\n      'Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.'\r\n    );\r\n  }\r\n\r\n  if (ES.IsTemporalInstant(temporalObj)) {\r\n    return {\r\n      epochNs: GetSlot(temporalObj, EPOCHNANOSECONDS),\r\n      formatter: getSlotLazy(main, INST)\r\n    };\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\nfunction temporalDurationToCompatibilityRecord(duration: Temporal.Duration) {\r\n  const record = Object.create(null);\r\n  record.years = GetSlot(duration, YEARS);\r\n  record.months = GetSlot(duration, MONTHS);\r\n  record.weeks = GetSlot(duration, WEEKS);\r\n  record.days = GetSlot(duration, DAYS);\r\n  record.hours = GetSlot(duration, HOURS);\r\n  record.minutes = GetSlot(duration, MINUTES);\r\n  record.seconds = GetSlot(duration, SECONDS);\r\n  record.milliseconds = GetSlot(duration, MILLISECONDS);\r\n  record.microseconds = GetSlot(duration, MICROSECONDS);\r\n  record.nanoseconds = GetSlot(duration, NANOSECONDS);\r\n  return record;\r\n}\r\n\r\nconst { format: IntlDurationFormatPrototypeFormat, formatToParts: IntlDurationFormatPrototypeFormatToParts } =\r\n  Intl.DurationFormat?.prototype ?? Object.create(null);\r\n\r\nexport function ModifiedIntlDurationFormatPrototypeFormat(\r\n  this: Intl.DurationFormat,\r\n  durationLike: Temporal.DurationLike\r\n) {\r\n  Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\r\n  const duration = ES.ToTemporalDuration(durationLike);\r\n  const record = temporalDurationToCompatibilityRecord(duration);\r\n  return IntlDurationFormatPrototypeFormat.call(this, record);\r\n}\r\n\r\nif (Intl.DurationFormat?.prototype) {\r\n  Intl.DurationFormat.prototype.format = ModifiedIntlDurationFormatPrototypeFormat;\r\n  Intl.DurationFormat.prototype.formatToParts = function formatToParts(durationLike: Temporal.DurationLike) {\r\n    Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\r\n    const duration = ES.ToTemporalDuration(durationLike);\r\n    const record = temporalDurationToCompatibilityRecord(duration);\r\n    return IntlDurationFormatPrototypeFormatToParts.call(this, record);\r\n  };\r\n}\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { EPOCHNANOSECONDS, GetSlot } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { InstantParams as Params, InstantReturn as Return } from './internaltypes';\r\n\r\nexport class Instant implements Temporal.Instant {\r\n  constructor(epochNanoseconds: bigint) {\r\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\r\n    //       to improve the error message.\r\n    if (arguments.length < 1) {\r\n      throw new TypeError('missing argument: epochNanoseconds is required');\r\n    }\r\n\r\n    const ns = BigInt(epochNanoseconds);\r\n    ES.CreateTemporalInstantSlots(this, ns);\r\n  }\r\n\r\n  get epochMilliseconds(): Return['epochMilliseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const value = GetSlot(this, EPOCHNANOSECONDS);\r\n    return ES.epochNsToMs(value, 'floor');\r\n  }\r\n  get epochNanoseconds(): Return['epochNanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.ToBigIntExternal(BigInt(GetSlot(this, EPOCHNANOSECONDS)));\r\n  }\r\n\r\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.AddDurationToInstant('add', this, temporalDurationLike);\r\n  }\r\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.AddDurationToInstant('subtract', this, temporalDurationLike);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.DifferenceTemporalInstant('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.DifferenceTemporalInstant('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\r\n    const maximumIncrements = {\r\n      hour: 24,\r\n      minute: 1440,\r\n      second: 86400,\r\n      millisecond: 86400e3,\r\n      microsecond: 86400e6,\r\n      nanosecond: 86400e9\r\n    };\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximumIncrements[smallestUnit], true);\r\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\r\n    const roundedNs = ES.RoundTemporalInstant(ns, roundingIncrement, smallestUnit, roundingMode);\r\n    return ES.CreateTemporalInstant(roundedNs);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const other = ES.ToTemporalInstant(otherParam);\r\n    const one = GetSlot(this, EPOCHNANOSECONDS);\r\n    const two = GetSlot(other, EPOCHNANOSECONDS);\r\n    return BigInt(one) === BigInt(two);\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    let timeZone = resolvedOptions.timeZone;\r\n    if (timeZone !== undefined) timeZone = ES.ToTemporalTimeZoneIdentifier(timeZone);\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\r\n    const roundedNs = ES.RoundTemporalInstant(ns, increment, unit, roundingMode);\r\n    const roundedInstant = ES.CreateTemporalInstant(roundedNs);\r\n    return ES.TemporalInstantToString(roundedInstant, timeZone, precision);\r\n  }\r\n  toJSON(): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return ES.TemporalInstantToString(this, undefined, 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('Instant');\r\n  }\r\n  toZonedDateTimeISO(timeZoneParam: Params['toZonedDateTimeISO'][0]): Return['toZonedDateTimeISO'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\r\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\r\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, 'iso8601');\r\n  }\r\n\r\n  static fromEpochMilliseconds(epochMilliseconds: Params['fromEpochMilliseconds'][0]): Return['fromEpochMilliseconds'] {\r\n    const epochNanoseconds = ES.epochMsToNs(ES.ToNumber(epochMilliseconds));\r\n    return ES.CreateTemporalInstant(epochNanoseconds);\r\n  }\r\n  static fromEpochNanoseconds(\r\n    epochNanosecondsParam: Params['fromEpochNanoseconds'][0]\r\n  ): Return['fromEpochNanoseconds'] {\r\n    const epochNanoseconds = BigInt(epochNanosecondsParam);\r\n    return ES.CreateTemporalInstant(epochNanoseconds);\r\n  }\r\n  static from(item: Params['from'][0]): Return['from'] {\r\n    return ES.ToTemporalInstant(item);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalInstant(oneParam);\r\n    const two = ES.ToTemporalInstant(twoParam);\r\n    const oneNs = GetSlot(one, EPOCHNANOSECONDS);\r\n    const twoNs = GetSlot(two, EPOCHNANOSECONDS);\r\n    if (oneNs < twoNs) return -1;\r\n    if (oneNs > twoNs) return 1;\r\n    return 0;\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.Instant';\r\n}\r\n\r\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, GetSlot, ISO_DATE, TIME } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { CalendarDateRecord, PlainDateParams as Params, PlainDateReturn as Return } from './internaltypes';\r\n\r\nexport class PlainDate implements Temporal.PlainDate {\r\n  constructor(\r\n    isoYear: Params['constructor'][0],\r\n    isoMonth: Params['constructor'][1],\r\n    isoDay: Params['constructor'][2],\r\n    calendarParam: Params['constructor'][3] = 'iso8601'\r\n  ) {\r\n    const year = ES.ToIntegerWithTruncation(isoYear);\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const day = ES.ToIntegerWithTruncation(isoDay);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n    ES.RejectISODate(year, month, day);\r\n\r\n    ES.CreateTemporalDateSlots(this, { year, month, day }, calendar);\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get dayOfWeek(): Return['dayOfWeek'] {\r\n    return getCalendarProperty(this, 'dayOfWeek');\r\n  }\r\n  get dayOfYear(): Return['dayOfYear'] {\r\n    return getCalendarProperty(this, 'dayOfYear');\r\n  }\r\n  get weekOfYear(): Return['weekOfYear'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.week;\r\n  }\r\n  get yearOfWeek(): Return['yearOfWeek'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.year;\r\n  }\r\n  get daysInWeek(): Return['daysInWeek'] {\r\n    return getCalendarProperty(this, 'daysInWeek');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  with(temporalDateLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    if (!ES.IsObject(temporalDateLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalDateLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\r\n    const partialDate = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalDateLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      [],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialDate);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const isoDate = ES.CalendarDateFromFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalDate(isoDate, calendar);\r\n  }\r\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\r\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE), calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.AddDurationToDate('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.AddDurationToDate('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.DifferenceTemporalPlainDate('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.DifferenceTemporalPlainDate('since', this, other, options);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const other = ES.ToTemporalDate(otherParam);\r\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    return ES.TemporalDateToString(this, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return ES.TemporalDateToString(this);\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainDate');\r\n  }\r\n  toPlainDateTime(temporalTime: Params['toPlainDateTime'][0] = undefined): Return['toPlainDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE), time);\r\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\r\n  }\r\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n\r\n    let timeZone, temporalTime;\r\n    if (ES.IsObject(item)) {\r\n      const timeZoneLike = item.timeZone;\r\n      if (timeZoneLike === undefined) {\r\n        timeZone = ES.ToTemporalTimeZoneIdentifier(item);\r\n      } else {\r\n        timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneLike);\r\n        temporalTime = item.plainTime;\r\n      }\r\n    } else {\r\n      timeZone = ES.ToTemporalTimeZoneIdentifier(item);\r\n    }\r\n\r\n    const isoDate = GetSlot(this, ISO_DATE);\r\n    let epochNs;\r\n    if (temporalTime === undefined) {\r\n      epochNs = ES.GetStartOfDay(timeZone, isoDate);\r\n    } else {\r\n      temporalTime = ES.ToTemporalTime(temporalTime);\r\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoDate, GetSlot(temporalTime, TIME));\r\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, isoDateTime, 'compatible');\r\n    }\r\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\r\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, 'constrain');\r\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\r\n  }\r\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDate);\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\r\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, 'constrain');\r\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalDate(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalDate(oneParam);\r\n    const two = ES.ToTemporalDate(twoParam);\r\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainDate';\r\n}\r\n\r\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  date: Temporal.PlainDate,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(date, ES.IsTemporalDate);\r\n  const isoDate = GetSlot(date, ISO_DATE);\r\n  return ES.calendarImplForObj(date).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\n\r\nimport { CALENDAR, GetSlot, ISO_DATE_TIME } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { CalendarDateRecord, PlainDateTimeParams as Params, PlainDateTimeReturn as Return } from './internaltypes';\r\n\r\nexport class PlainDateTime implements Temporal.PlainDateTime {\r\n  constructor(\r\n    isoYear: Params['constructor'][0],\r\n    isoMonth: Params['constructor'][1],\r\n    isoDay: Params['constructor'][2],\r\n    hourParam: Params['constructor'][3] = 0,\r\n    minuteParam: Params['constructor'][4] = 0,\r\n    secondParam: Params['constructor'][5] = 0,\r\n    millisecondParam: Params['constructor'][6] = 0,\r\n    microsecondParam: Params['constructor'][7] = 0,\r\n    nanosecondParam: Params['constructor'][8] = 0,\r\n    calendarParam: Params['constructor'][9] = 'iso8601'\r\n  ) {\r\n    const year = ES.ToIntegerWithTruncation(isoYear);\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const day = ES.ToIntegerWithTruncation(isoDay);\r\n    const hour = hourParam === undefined ? 0 : ES.ToIntegerWithTruncation(hourParam);\r\n    const minute = minuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(minuteParam);\r\n    const second = secondParam === undefined ? 0 : ES.ToIntegerWithTruncation(secondParam);\r\n    const millisecond = millisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(millisecondParam);\r\n    const microsecond = microsecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(microsecondParam);\r\n    const nanosecond = nanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(nanosecondParam);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n\r\n    ES.RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\r\n\r\n    ES.CreateTemporalDateTimeSlots(\r\n      this,\r\n      { isoDate: { year, month, day }, time: { hour, minute, second, millisecond, microsecond, nanosecond } },\r\n      calendar\r\n    );\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get hour(): Return['hour'] {\r\n    return getTimeProperty(this, 'hour');\r\n  }\r\n  get minute(): Return['minute'] {\r\n    return getTimeProperty(this, 'minute');\r\n  }\r\n  get second(): Return['second'] {\r\n    return getTimeProperty(this, 'second');\r\n  }\r\n  get millisecond(): Return['millisecond'] {\r\n    return getTimeProperty(this, 'millisecond');\r\n  }\r\n  get microsecond(): Return['microsecond'] {\r\n    return getTimeProperty(this, 'microsecond');\r\n  }\r\n  get nanosecond(): Return['nanosecond'] {\r\n    return getTimeProperty(this, 'nanosecond');\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get dayOfWeek(): Return['dayOfWeek'] {\r\n    return getCalendarProperty(this, 'dayOfWeek');\r\n  }\r\n  get dayOfYear(): Return['dayOfYear'] {\r\n    return getCalendarProperty(this, 'dayOfYear');\r\n  }\r\n  get weekOfYear(): Return['weekOfYear'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.week;\r\n  }\r\n  get yearOfWeek(): Return['yearOfWeek'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.year;\r\n  }\r\n  get daysInWeek(): Return['daysInWeek'] {\r\n    return getCalendarProperty(this, 'daysInWeek');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  with(temporalDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    if (!ES.IsObject(temporalDateTimeLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalDateTimeLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\r\n    let fields = {\r\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\r\n      ...isoDateTime.time\r\n    };\r\n    const partialDateTime = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalDateTimeLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialDateTime);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalDateTime(newDateTime, calendar);\r\n  }\r\n  withPlainTime(temporalTime: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\r\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE_TIME).isoDate, time);\r\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\r\n  }\r\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\r\n    return ES.CreateTemporalDateTime(GetSlot(this, ISO_DATE_TIME), calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.AddDurationToDateTime('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.AddDurationToDateTime('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.DifferenceTemporalPlainDateTime('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.DifferenceTemporalPlainDateTime('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\r\n    const maximumIncrements = {\r\n      day: 1,\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    };\r\n    const maximum = maximumIncrements[smallestUnit];\r\n    const inclusive = maximum === 1;\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\r\n\r\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\r\n    if (roundingIncrement === 1 && smallestUnit === 'nanosecond') {\r\n      return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\r\n    }\r\n    const result = ES.RoundISODateTime(isoDateTime, roundingIncrement, smallestUnit, roundingMode);\r\n\r\n    return ES.CreateTemporalDateTime(result, GetSlot(this, CALENDAR));\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const other = ES.ToTemporalDateTime(otherParam);\r\n    if (ES.CompareISODateTime(GetSlot(this, ISO_DATE_TIME), GetSlot(other, ISO_DATE_TIME)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    const result = ES.RoundISODateTime(GetSlot(this, ISO_DATE_TIME), increment, unit, roundingMode);\r\n    ES.RejectDateTimeRange(result);\r\n    return ES.ISODateTimeToString(result, GetSlot(this, CALENDAR), precision, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.ISODateTimeToString(GetSlot(this, ISO_DATE_TIME), GetSlot(this, CALENDAR), 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainDateTime');\r\n  }\r\n\r\n  toZonedDateTime(\r\n    temporalTimeZoneLike: Params['toZonedDateTime'][0],\r\n    options: Params['toZonedDateTime'][1] = undefined\r\n  ): Return['toZonedDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\r\n    const epochNs = ES.GetEpochNanosecondsFor(timeZone, GetSlot(this, ISO_DATE_TIME), disambiguation);\r\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainDate(): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE_TIME).isoDate, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainTime(): Return['toPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\r\n    return ES.CreateTemporalTime(GetSlot(this, ISO_DATE_TIME).time);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalDateTime(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalDateTime(oneParam);\r\n    const two = ES.ToTemporalDateTime(twoParam);\r\n    return ES.CompareISODateTime(GetSlot(one, ISO_DATE_TIME), GetSlot(two, ISO_DATE_TIME));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainDateTime';\r\n}\r\n\r\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  dt: Temporal.PlainDateTime,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\r\n  const isoDate = GetSlot(dt, ISO_DATE_TIME).isoDate;\r\n  return ES.calendarImplForObj(dt).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n\r\nfunction getTimeProperty(dt: Temporal.PlainDateTime, prop: Temporal.TimeUnit) {\r\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\r\n  return GetSlot(dt, ISO_DATE_TIME).time[prop];\r\n}\r\n","import { DEBUG } from './debug';\r\nimport { assert } from './assert';\r\nimport * as ES from './ecmascript';\r\nimport { ModifiedIntlDurationFormatPrototypeFormat } from './intl';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport {\r\n  YEARS,\r\n  MONTHS,\r\n  WEEKS,\r\n  DAYS,\r\n  HOURS,\r\n  MINUTES,\r\n  SECONDS,\r\n  MILLISECONDS,\r\n  MICROSECONDS,\r\n  NANOSECONDS,\r\n  CALENDAR,\r\n  EPOCHNANOSECONDS,\r\n  CreateSlots,\r\n  GetSlot,\r\n  ISO_DATE,\r\n  SetSlot,\r\n  TIME_ZONE\r\n} from './slots';\r\nimport { TimeDuration } from './timeduration';\r\nimport type { Temporal } from '..';\r\nimport type { DurationParams as Params, DurationReturn as Return } from './internaltypes';\r\n\r\nexport class Duration implements Temporal.Duration {\r\n  constructor(\r\n    yearsParam: Params['constructor'][0] = 0,\r\n    monthsParam: Params['constructor'][1] = 0,\r\n    weeksParam: Params['constructor'][2] = 0,\r\n    daysParam: Params['constructor'][3] = 0,\r\n    hoursParam: Params['constructor'][4] = 0,\r\n    minutesParam: Params['constructor'][5] = 0,\r\n    secondsParam: Params['constructor'][6] = 0,\r\n    millisecondsParam: Params['constructor'][7] = 0,\r\n    microsecondsParam: Params['constructor'][8] = 0,\r\n    nanosecondsParam: Params['constructor'][9] = 0\r\n  ) {\r\n    const years = yearsParam === undefined ? 0 : ES.ToIntegerIfIntegral(yearsParam);\r\n    const months = monthsParam === undefined ? 0 : ES.ToIntegerIfIntegral(monthsParam);\r\n    const weeks = weeksParam === undefined ? 0 : ES.ToIntegerIfIntegral(weeksParam);\r\n    const days = daysParam === undefined ? 0 : ES.ToIntegerIfIntegral(daysParam);\r\n    const hours = hoursParam === undefined ? 0 : ES.ToIntegerIfIntegral(hoursParam);\r\n    const minutes = minutesParam === undefined ? 0 : ES.ToIntegerIfIntegral(minutesParam);\r\n    const seconds = secondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(secondsParam);\r\n    const milliseconds = millisecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(millisecondsParam);\r\n    const microseconds = microsecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(microsecondsParam);\r\n    const nanoseconds = nanosecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(nanosecondsParam);\r\n\r\n    ES.RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n\r\n    CreateSlots(this);\r\n    SetSlot(this, YEARS, years);\r\n    SetSlot(this, MONTHS, months);\r\n    SetSlot(this, WEEKS, weeks);\r\n    SetSlot(this, DAYS, days);\r\n    SetSlot(this, HOURS, hours);\r\n    SetSlot(this, MINUTES, minutes);\r\n    SetSlot(this, SECONDS, seconds);\r\n    SetSlot(this, MILLISECONDS, milliseconds);\r\n    SetSlot(this, MICROSECONDS, microseconds);\r\n    SetSlot(this, NANOSECONDS, nanoseconds);\r\n\r\n    if (DEBUG) {\r\n      Object.defineProperty(this, '_repr_', {\r\n        value: `Temporal.Duration <${ES.TemporalDurationToString(this, 'auto')}>`,\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: false\r\n      });\r\n    }\r\n  }\r\n  get years(): Return['years'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, YEARS);\r\n  }\r\n  get months(): Return['months'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MONTHS);\r\n  }\r\n  get weeks(): Return['weeks'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, WEEKS);\r\n  }\r\n  get days(): Return['days'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, DAYS);\r\n  }\r\n  get hours(): Return['hours'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, HOURS);\r\n  }\r\n  get minutes(): Return['minutes'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MINUTES);\r\n  }\r\n  get seconds(): Return['seconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, SECONDS);\r\n  }\r\n  get milliseconds(): Return['milliseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MILLISECONDS);\r\n  }\r\n  get microseconds(): Return['microseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, MICROSECONDS);\r\n  }\r\n  get nanoseconds(): Return['nanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return GetSlot(this, NANOSECONDS);\r\n  }\r\n  get sign(): Return['sign'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.DurationSign(this);\r\n  }\r\n  get blank(): Return['blank'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.DurationSign(this) === 0;\r\n  }\r\n  with(durationLike: Params['with'][0]): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    const partialDuration = ES.ToTemporalPartialDurationRecord(durationLike);\r\n    const {\r\n      years = GetSlot(this, YEARS),\r\n      months = GetSlot(this, MONTHS),\r\n      weeks = GetSlot(this, WEEKS),\r\n      days = GetSlot(this, DAYS),\r\n      hours = GetSlot(this, HOURS),\r\n      minutes = GetSlot(this, MINUTES),\r\n      seconds = GetSlot(this, SECONDS),\r\n      milliseconds = GetSlot(this, MILLISECONDS),\r\n      microseconds = GetSlot(this, MICROSECONDS),\r\n      nanoseconds = GetSlot(this, NANOSECONDS)\r\n    } = partialDuration;\r\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\r\n  }\r\n  negated(): Return['negated'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.CreateNegatedTemporalDuration(this);\r\n  }\r\n  abs(): Return['abs'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return new Duration(\r\n      Math.abs(GetSlot(this, YEARS)),\r\n      Math.abs(GetSlot(this, MONTHS)),\r\n      Math.abs(GetSlot(this, WEEKS)),\r\n      Math.abs(GetSlot(this, DAYS)),\r\n      Math.abs(GetSlot(this, HOURS)),\r\n      Math.abs(GetSlot(this, MINUTES)),\r\n      Math.abs(GetSlot(this, SECONDS)),\r\n      Math.abs(GetSlot(this, MILLISECONDS)),\r\n      Math.abs(GetSlot(this, MICROSECONDS)),\r\n      Math.abs(GetSlot(this, NANOSECONDS))\r\n    );\r\n  }\r\n  add(other: Params['add'][0]): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.AddDurations('add', this, other);\r\n  }\r\n  subtract(other: Params['subtract'][0]): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.AddDurations('subtract', this, other);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n\r\n    const existingLargestUnit = ES.DefaultTemporalLargestUnit(this);\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n\r\n    let largestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'largestUnit', 'datetime', undefined, ['auto']);\r\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(roundTo);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    let smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'datetime', undefined);\r\n\r\n    let smallestUnitPresent = true;\r\n    if (!smallestUnit) {\r\n      smallestUnitPresent = false;\r\n      smallestUnit = 'nanosecond';\r\n    }\r\n    const defaultLargestUnit = ES.LargerOfTwoTemporalUnits(existingLargestUnit, smallestUnit);\r\n    let largestUnitPresent = true;\r\n    if (!largestUnit) {\r\n      largestUnitPresent = false;\r\n      largestUnit = defaultLargestUnit;\r\n    }\r\n    if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\r\n    if (!smallestUnitPresent && !largestUnitPresent) {\r\n      throw new RangeError('at least one of smallestUnit or largestUnit is required');\r\n    }\r\n    if (ES.LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\r\n      throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\r\n    }\r\n\r\n    const maximumIncrements = {\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    } as { [k in Temporal.DateTimeUnit]?: number };\r\n    const maximum = maximumIncrements[smallestUnit];\r\n    if (maximum !== undefined) ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\r\n    if (roundingIncrement > 1 && ES.TemporalUnitCategory(smallestUnit) === 'date' && largestUnit !== smallestUnit) {\r\n      throw new RangeError('For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit');\r\n    }\r\n\r\n    if (zonedRelativeTo) {\r\n      let duration = ES.ToInternalDurationRecord(this);\r\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\r\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\r\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\r\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\r\n      duration = ES.DifferenceZonedDateTimeWithRounding(\r\n        relativeEpochNs,\r\n        targetEpochNs,\r\n        timeZone,\r\n        calendar,\r\n        largestUnit,\r\n        roundingIncrement,\r\n        smallestUnit,\r\n        roundingMode\r\n      );\r\n      if (ES.TemporalUnitCategory(largestUnit) === 'date') largestUnit = 'hour';\r\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\r\n    }\r\n\r\n    if (plainRelativeTo) {\r\n      let duration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n      const targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\r\n\r\n      // Delegate the date part addition to the calendar\r\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\r\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\r\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\r\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\r\n\r\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\r\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\r\n      duration = ES.DifferencePlainDateTimeWithRounding(\r\n        isoDateTime,\r\n        targetDateTime,\r\n        calendar,\r\n        largestUnit,\r\n        roundingIncrement,\r\n        smallestUnit,\r\n        roundingMode\r\n      );\r\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\r\n    }\r\n\r\n    // No reference date to calculate difference relative to\r\n    if (ES.IsCalendarUnit(existingLargestUnit)) {\r\n      throw new RangeError(`a starting point is required for ${existingLargestUnit}s balancing`);\r\n    }\r\n    if (ES.IsCalendarUnit(largestUnit)) {\r\n      throw new RangeError(`a starting point is required for ${largestUnit}s balancing`);\r\n    }\r\n    assert(!ES.IsCalendarUnit(smallestUnit), 'smallestUnit was larger than largestUnit');\r\n    let internalDuration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n    if (smallestUnit === 'day') {\r\n      // First convert time units up to days\r\n      const { quotient, remainder } = internalDuration.time.divmod(ES.DAY_NANOS);\r\n      let days = internalDuration.date.days + ES.ToNumber(quotient) + ES.TotalTimeDuration(remainder, 'day');\r\n      days = ES.RoundNumberToIncrement(days, roundingIncrement, roundingMode);\r\n      const dateDuration = { years: 0, months: 0, weeks: 0, days };\r\n      internalDuration = ES.CombineDateAndTimeDuration(dateDuration, TimeDuration.ZERO);\r\n    } else {\r\n      const timeDuration = ES.RoundTimeDuration(internalDuration.time, roundingIncrement, smallestUnit, roundingMode);\r\n      internalDuration = ES.CombineDateAndTimeDuration(ES.ZeroDateDuration(), timeDuration);\r\n    }\r\n    return ES.TemporalDurationFromInternal(internalDuration, largestUnit);\r\n  }\r\n  total(optionsParam: Params['total'][0]): Return['total'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n\r\n    if (optionsParam === undefined) throw new TypeError('options argument is required');\r\n    const options =\r\n      typeof optionsParam === 'string'\r\n        ? (ES.CreateOnePropObject('unit', optionsParam) as Exclude<typeof optionsParam, string>)\r\n        : ES.GetOptionsObject(optionsParam);\r\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(options);\r\n    const unit = ES.GetTemporalUnitValuedOption(options, 'unit', 'datetime', ES.REQUIRED);\r\n\r\n    if (zonedRelativeTo) {\r\n      const duration = ES.ToInternalDurationRecord(this);\r\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\r\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\r\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\r\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\r\n      return ES.DifferenceZonedDateTimeWithTotal(relativeEpochNs, targetEpochNs, timeZone, calendar, unit);\r\n    }\r\n\r\n    if (plainRelativeTo) {\r\n      const duration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n      let targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\r\n\r\n      // Delegate the date part addition to the calendar\r\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\r\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\r\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\r\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\r\n\r\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\r\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\r\n      return ES.ToNumber(ES.DifferencePlainDateTimeWithTotal(isoDateTime, targetDateTime, calendar, unit));\r\n    }\r\n\r\n    // No reference date to calculate difference relative to\r\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\r\n    if (ES.IsCalendarUnit(largestUnit)) {\r\n      throw new RangeError(`a starting point is required for ${largestUnit}s total`);\r\n    }\r\n    if (ES.IsCalendarUnit(unit)) {\r\n      throw new RangeError(`a starting point is required for ${unit}s total`);\r\n    }\r\n    const duration = ES.ToInternalDurationRecordWith24HourDays(this);\r\n    return ES.TotalTimeDuration(duration.time, unit);\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour' || smallestUnit === 'minute') {\r\n      throw new RangeError('smallestUnit must be a time unit other than \"hours\" or \"minutes\"');\r\n    }\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    ES.uncheckedAssertNarrowedType<Exclude<typeof precision, 'minute'>>(\r\n      precision,\r\n      'Precision cannot be \"minute\" because of RangeError above'\r\n    );\r\n\r\n    if (unit === 'nanosecond' && increment === 1) return ES.TemporalDurationToString(this, precision);\r\n\r\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\r\n    let internalDuration = ES.ToInternalDurationRecord(this);\r\n    const timeDuration = ES.RoundTimeDuration(internalDuration.time, increment, unit, roundingMode);\r\n    internalDuration = ES.CombineDateAndTimeDuration(internalDuration.date, timeDuration);\r\n    const roundedDuration = ES.TemporalDurationFromInternal(\r\n      internalDuration,\r\n      ES.LargerOfTwoTemporalUnits(largestUnit, 'second')\r\n    );\r\n    return ES.TemporalDurationToString(roundedDuration, precision);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    return ES.TemporalDurationToString(this, 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\r\n    if (typeof Intl.DurationFormat === 'function') {\r\n      const formatter = new Intl.DurationFormat(locales, options as Intl.DurationFormatOptions);\r\n      return ModifiedIntlDurationFormatPrototypeFormat.call(formatter, this);\r\n    }\r\n    console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\r\n    return ES.TemporalDurationToString(this, 'auto');\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('Duration');\r\n  }\r\n  static from(item: Params['from'][0]): Return['from'] {\r\n    return ES.ToTemporalDuration(item);\r\n  }\r\n  static compare(\r\n    oneParam: Params['compare'][0],\r\n    twoParam: Params['compare'][1],\r\n    options: Params['compare'][2] = undefined\r\n  ): Return['compare'] {\r\n    const one = ES.ToTemporalDuration(oneParam);\r\n    const two = ES.ToTemporalDuration(twoParam);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(resolvedOptions);\r\n\r\n    if (\r\n      GetSlot(one, YEARS) === GetSlot(two, YEARS) &&\r\n      GetSlot(one, MONTHS) === GetSlot(two, MONTHS) &&\r\n      GetSlot(one, WEEKS) === GetSlot(two, WEEKS) &&\r\n      GetSlot(one, DAYS) === GetSlot(two, DAYS) &&\r\n      GetSlot(one, HOURS) === GetSlot(two, HOURS) &&\r\n      GetSlot(one, MINUTES) === GetSlot(two, MINUTES) &&\r\n      GetSlot(one, SECONDS) === GetSlot(two, SECONDS) &&\r\n      GetSlot(one, MILLISECONDS) === GetSlot(two, MILLISECONDS) &&\r\n      GetSlot(one, MICROSECONDS) === GetSlot(two, MICROSECONDS) &&\r\n      GetSlot(one, NANOSECONDS) === GetSlot(two, NANOSECONDS)\r\n    ) {\r\n      return 0;\r\n    }\r\n\r\n    const largestUnit1 = ES.DefaultTemporalLargestUnit(one);\r\n    const largestUnit2 = ES.DefaultTemporalLargestUnit(two);\r\n    const duration1 = ES.ToInternalDurationRecord(one);\r\n    const duration2 = ES.ToInternalDurationRecord(two);\r\n\r\n    if (\r\n      zonedRelativeTo &&\r\n      (ES.TemporalUnitCategory(largestUnit1) === 'date' || ES.TemporalUnitCategory(largestUnit2) === 'date')\r\n    ) {\r\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\r\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\r\n      const epochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\r\n\r\n      const after1 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration1);\r\n      const after2 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration2);\r\n      return ES.ComparisonResult(Number(after1 - after2));\r\n    }\r\n\r\n    let d1 = duration1.date.days;\r\n    let d2 = duration2.date.days;\r\n    if (ES.IsCalendarUnit(largestUnit1) || ES.IsCalendarUnit(largestUnit2)) {\r\n      if (!plainRelativeTo) {\r\n        throw new RangeError('A starting point is required for years, months, or weeks comparison');\r\n      }\r\n      d1 = ES.DateDurationDays(duration1.date, plainRelativeTo);\r\n      d2 = ES.DateDurationDays(duration2.date, plainRelativeTo);\r\n    }\r\n    const timeDuration1 = duration1.time.add24HourDays(d1);\r\n    const timeDuration2 = duration2.time.add24HourDays(d2);\r\n    return timeDuration1.cmp(timeDuration2);\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.Duration';\r\n}\r\n\r\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { CalendarDateRecord, PlainMonthDayParams as Params, PlainMonthDayReturn as Return } from './internaltypes';\r\n\r\nexport class PlainMonthDay implements Temporal.PlainMonthDay {\r\n  constructor(\r\n    isoMonth: Params['constructor'][0],\r\n    isoDay: Params['constructor'][0],\r\n    calendarParam = 'iso8601',\r\n    referenceISOYear = 1972\r\n  ) {\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const day = ES.ToIntegerWithTruncation(isoDay);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n    const year = ES.ToIntegerWithTruncation(referenceISOYear);\r\n\r\n    ES.RejectISODate(year, month, day);\r\n    ES.CreateTemporalMonthDaySlots(this, { year, month, day }, calendar);\r\n  }\r\n\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n\r\n  with(temporalMonthDayLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    if (!ES.IsObject(temporalMonthDayLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalMonthDayLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\r\n    const partialMonthDay = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalMonthDayLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      [],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialMonthDay);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    const other = ES.ToTemporalMonthDay(otherParam);\r\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    return ES.TemporalMonthDayToString(this, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    return ES.TemporalMonthDayToString(this);\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainMonthDay');\r\n  }\r\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\r\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\r\n    const calendar = GetSlot(this, CALENDAR);\r\n\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\r\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['year'], [], []);\r\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\r\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\r\n    return ES.CreateTemporalDate(isoDate, calendar);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalMonthDay(item, options);\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainMonthDay';\r\n}\r\n\r\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  md: Temporal.PlainMonthDay,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(md, ES.IsTemporalMonthDay);\r\n  const isoDate = GetSlot(md, ISO_DATE);\r\n  return ES.calendarImplForObj(md).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n","import * as ES from './ecmascript';\r\nimport type { Temporal } from '..';\r\n\r\nfunction SystemDateTime(timeZone: string) {\r\n  return ES.GetISODateTimeFor(timeZone, ES.SystemUTCEpochNanoSeconds());\r\n}\r\n\r\nconst instant: (typeof Temporal.Now)['instant'] = () => {\r\n  return ES.CreateTemporalInstant(ES.SystemUTCEpochNanoSeconds());\r\n};\r\nconst plainDateTimeISO: (typeof Temporal.Now)['plainDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  const isoDateTime = SystemDateTime(timeZone);\r\n  return ES.CreateTemporalDateTime(isoDateTime, 'iso8601');\r\n};\r\nconst zonedDateTimeISO: (typeof Temporal.Now)['zonedDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), timeZone, 'iso8601');\r\n};\r\nconst plainDateISO: (typeof Temporal.Now)['plainDateISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  const isoDateTime = SystemDateTime(timeZone);\r\n  return ES.CreateTemporalDate(isoDateTime.isoDate, 'iso8601');\r\n};\r\nconst plainTimeISO: (typeof Temporal.Now)['plainTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\r\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\r\n  const isoDateTime = SystemDateTime(timeZone);\r\n  return ES.CreateTemporalTime(isoDateTime.time);\r\n};\r\nconst timeZoneId: (typeof Temporal.Now)['timeZoneId'] = () => {\r\n  return ES.DefaultTimeZone();\r\n};\r\n\r\nexport const Now: typeof Temporal.Now = {\r\n  instant,\r\n  plainDateTimeISO,\r\n  plainDateISO,\r\n  plainTimeISO,\r\n  timeZoneId,\r\n  zonedDateTimeISO,\r\n  [Symbol.toStringTag]: 'Temporal.Now'\r\n};\r\nObject.defineProperty(Now, Symbol.toStringTag, {\r\n  value: 'Temporal.Now',\r\n  writable: false,\r\n  enumerable: false,\r\n  configurable: true\r\n});\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\n\r\nimport { GetSlot, TIME } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type { PlainTimeParams as Params, PlainTimeReturn as Return } from './internaltypes';\r\n\r\nexport class PlainTime implements Temporal.PlainTime {\r\n  constructor(isoHour = 0, isoMinute = 0, isoSecond = 0, isoMillisecond = 0, isoMicrosecond = 0, isoNanosecond = 0) {\r\n    const hour = isoHour === undefined ? 0 : ES.ToIntegerWithTruncation(isoHour);\r\n    const minute = isoMinute === undefined ? 0 : ES.ToIntegerWithTruncation(isoMinute);\r\n    const second = isoSecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoSecond);\r\n    const millisecond = isoMillisecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMillisecond);\r\n    const microsecond = isoMicrosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMicrosecond);\r\n    const nanosecond = isoNanosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoNanosecond);\r\n\r\n    ES.RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n    const time = { hour, minute, second, millisecond, microsecond, nanosecond };\r\n\r\n    ES.CreateTemporalTimeSlots(this, time);\r\n  }\r\n\r\n  get hour(): Return['hour'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).hour;\r\n  }\r\n  get minute(): Return['minute'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).minute;\r\n  }\r\n  get second(): Return['second'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).second;\r\n  }\r\n  get millisecond(): Return['millisecond'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).millisecond;\r\n  }\r\n  get microsecond(): Return['microsecond'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).microsecond;\r\n  }\r\n  get nanosecond(): Return['nanosecond'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return GetSlot(this, TIME).nanosecond;\r\n  }\r\n\r\n  with(temporalTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    if (!ES.IsObject(temporalTimeLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalTimeLike);\r\n\r\n    const partialTime = ES.ToTemporalTimeRecord(temporalTimeLike, 'partial');\r\n\r\n    const fields = ES.ToTemporalTimeRecord(this);\r\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = Object.assign(fields, partialTime);\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(\r\n      hour,\r\n      minute,\r\n      second,\r\n      millisecond,\r\n      microsecond,\r\n      nanosecond,\r\n      overflow\r\n    ));\r\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.AddDurationToTime('add', this, temporalDurationLike);\r\n  }\r\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.AddDurationToTime('subtract', this, temporalDurationLike);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.DifferenceTemporalPlainTime('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.DifferenceTemporalPlainTime('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\r\n    const MAX_INCREMENTS = {\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    };\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, MAX_INCREMENTS[smallestUnit], false);\r\n\r\n    const time = ES.RoundTime(GetSlot(this, TIME), roundingIncrement, smallestUnit, roundingMode);\r\n    return ES.CreateTemporalTime(time);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    const other = ES.ToTemporalTime(otherParam);\r\n    return ES.CompareTimeRecord(GetSlot(this, TIME), GetSlot(other, TIME)) === 0;\r\n  }\r\n\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    const time = ES.RoundTime(GetSlot(this, TIME), increment, unit, roundingMode);\r\n    return ES.TimeRecordToString(time, precision);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return ES.TimeRecordToString(GetSlot(this, TIME), 'auto');\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalTime);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainTime');\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalTime(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalTime(oneParam);\r\n    const two = ES.ToTemporalTime(twoParam);\r\n    return ES.CompareTimeRecord(GetSlot(one, TIME), GetSlot(two, TIME));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainTime';\r\n}\r\n\r\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\r\n","import * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type {\r\n  CalendarDateRecord,\r\n  PlainYearMonthParams as Params,\r\n  PlainYearMonthReturn as Return\r\n} from './internaltypes';\r\n\r\nexport class PlainYearMonth implements Temporal.PlainYearMonth {\r\n  constructor(\r\n    isoYear: Params['constructor'][0],\r\n    isoMonth: Params['constructor'][1],\r\n    calendarParam: Params['constructor'][2] = 'iso8601',\r\n    referenceISODay: Params['constructor'][3] = 1\r\n  ) {\r\n    const year = ES.ToIntegerWithTruncation(isoYear);\r\n    const month = ES.ToIntegerWithTruncation(isoMonth);\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n    const day = ES.ToIntegerWithTruncation(referenceISODay);\r\n\r\n    ES.RejectISODate(year, month, day);\r\n    ES.CreateTemporalYearMonthSlots(this, { year, month, day }, calendar);\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  with(temporalYearMonthLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    if (!ES.IsObject(temporalYearMonthLike)) {\r\n      throw new TypeError('invalid argument');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalYearMonthLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\r\n    const partialYearMonth = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalYearMonthLike,\r\n      ['year', 'month', 'monthCode'],\r\n      [],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialYearMonth);\r\n\r\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\r\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, overflow);\r\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.AddDurationToYearMonth('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.AddDurationToYearMonth('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.DifferenceTemporalPlainYearMonth('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.DifferenceTemporalPlainYearMonth('since', this, other, options);\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    const other = ES.ToTemporalYearMonth(otherParam);\r\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    return ES.TemporalYearMonthToString(this, showCalendar);\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return ES.TemporalYearMonthToString(this);\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    return new DateTimeFormat(locales, options).format(this);\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('PlainYearMonth');\r\n  }\r\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\r\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\r\n    const calendar = GetSlot(this, CALENDAR);\r\n\r\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\r\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['day'], [], []);\r\n    const mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\r\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\r\n    return ES.CreateTemporalDate(isoDate, calendar);\r\n  }\r\n\r\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalYearMonth(item, options);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalYearMonth(oneParam);\r\n    const two = ES.ToTemporalYearMonth(twoParam);\r\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.PlainYearMonth';\r\n}\r\n\r\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  ym: Temporal.PlainYearMonth,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(ym, ES.IsTemporalYearMonth);\r\n  const isoDate = GetSlot(ym, ISO_DATE);\r\n  return ES.calendarImplForObj(ym).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n","import { assert } from './assert';\r\nimport * as ES from './ecmascript';\r\nimport { MakeIntrinsicClass } from './intrinsicclass';\r\nimport { CALENDAR, EPOCHNANOSECONDS, TIME, TIME_ZONE, GetSlot } from './slots';\r\nimport { TimeDuration } from './timeduration';\r\nimport type { Temporal } from '..';\r\nimport { DateTimeFormat } from './intl';\r\nimport type {\r\n  BuiltinCalendarId,\r\n  CalendarDateRecord,\r\n  ZonedDateTimeParams as Params,\r\n  ZonedDateTimeReturn as Return\r\n} from './internaltypes';\r\n\r\nconst customResolvedOptions = DateTimeFormat.prototype.resolvedOptions as Intl.DateTimeFormat['resolvedOptions'];\r\n\r\nexport class ZonedDateTime implements Temporal.ZonedDateTime {\r\n  constructor(epochNanosecondsParam: bigint, timeZoneParam: string, calendarParam = 'iso8601') {\r\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\r\n    //       to improve the error message.\r\n    if (arguments.length < 1) {\r\n      throw new TypeError('missing argument: epochNanoseconds is required');\r\n    }\r\n    const epochNanoseconds = epochNanosecondsParam;\r\n    let timeZone = ES.RequireString(timeZoneParam);\r\n    const { tzName, offsetMinutes } = ES.ParseTimeZoneIdentifier(timeZone);\r\n    if (offsetMinutes === undefined) {\r\n      // if offsetMinutes is undefined, then tzName must be present\r\n      const record = ES.GetAvailableNamedTimeZoneIdentifier(tzName);\r\n      if (!record) throw new RangeError(`unknown time zone ${tzName}`);\r\n      timeZone = record.identifier;\r\n    } else {\r\n      timeZone = ES.FormatOffsetTimeZoneIdentifier(offsetMinutes);\r\n    }\r\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\r\n\r\n    ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\r\n  }\r\n  get calendarId(): Return['calendarId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return GetSlot(this, CALENDAR);\r\n  }\r\n  get timeZoneId(): Return['timeZoneId'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return GetSlot(this, TIME_ZONE);\r\n  }\r\n  get year(): Return['year'] {\r\n    return getCalendarProperty(this, 'year');\r\n  }\r\n  get month(): Return['month'] {\r\n    return getCalendarProperty(this, 'month');\r\n  }\r\n  get monthCode(): Return['monthCode'] {\r\n    return getCalendarProperty(this, 'monthCode');\r\n  }\r\n  get day(): Return['day'] {\r\n    return getCalendarProperty(this, 'day');\r\n  }\r\n  get hour(): Return['hour'] {\r\n    return getTimeProperty(this, 'hour');\r\n  }\r\n  get minute(): Return['minute'] {\r\n    return getTimeProperty(this, 'minute');\r\n  }\r\n  get second(): Return['second'] {\r\n    return getTimeProperty(this, 'second');\r\n  }\r\n  get millisecond(): Return['millisecond'] {\r\n    return getTimeProperty(this, 'millisecond');\r\n  }\r\n  get microsecond(): Return['microsecond'] {\r\n    return getTimeProperty(this, 'microsecond');\r\n  }\r\n  get nanosecond(): Return['nanosecond'] {\r\n    return getTimeProperty(this, 'nanosecond');\r\n  }\r\n  get era(): Return['era'] {\r\n    return getCalendarProperty(this, 'era');\r\n  }\r\n  get eraYear(): Return['eraYear'] {\r\n    return getCalendarProperty(this, 'eraYear');\r\n  }\r\n  get epochMilliseconds(): Return['epochMilliseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const value = GetSlot(this, EPOCHNANOSECONDS);\r\n    return ES.epochNsToMs(value, 'floor');\r\n  }\r\n  get epochNanoseconds(): Return['epochNanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\r\n  }\r\n  get dayOfWeek(): Return['dayOfWeek'] {\r\n    return getCalendarProperty(this, 'dayOfWeek');\r\n  }\r\n  get dayOfYear(): Return['dayOfYear'] {\r\n    return getCalendarProperty(this, 'dayOfYear');\r\n  }\r\n  get weekOfYear(): Return['weekOfYear'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.week;\r\n  }\r\n  get yearOfWeek(): Return['yearOfWeek'] {\r\n    return getCalendarProperty(this, 'weekOfYear')?.year;\r\n  }\r\n  get hoursInDay(): Return['hoursInDay'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const today = dateTime(this).isoDate;\r\n    const tomorrow = ES.BalanceISODate(today.year, today.month, today.day + 1);\r\n    const todayNs = ES.GetStartOfDay(timeZone, today);\r\n    const tomorrowNs = ES.GetStartOfDay(timeZone, tomorrow);\r\n    const diff = TimeDuration.fromEpochNsDiff(tomorrowNs, todayNs);\r\n    return ES.TotalTimeDuration(diff, 'hour');\r\n  }\r\n  get daysInWeek(): Return['daysInWeek'] {\r\n    return getCalendarProperty(this, 'daysInWeek');\r\n  }\r\n  get daysInMonth(): Return['daysInMonth'] {\r\n    return getCalendarProperty(this, 'daysInMonth');\r\n  }\r\n  get daysInYear(): Return['daysInYear'] {\r\n    return getCalendarProperty(this, 'daysInYear');\r\n  }\r\n  get monthsInYear(): Return['monthsInYear'] {\r\n    return getCalendarProperty(this, 'monthsInYear');\r\n  }\r\n  get inLeapYear(): Return['inLeapYear'] {\r\n    return getCalendarProperty(this, 'inLeapYear');\r\n  }\r\n  get offset(): Return['offset'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const offsetNs = ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\r\n    return ES.FormatUTCOffsetNanoseconds(BigInt(offsetNs));\r\n  }\r\n  get offsetNanoseconds(): Return['offsetNanoseconds'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\r\n  }\r\n  with(temporalZonedDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    if (!ES.IsObject(temporalZonedDateTimeLike)) {\r\n      throw new TypeError('invalid zoned-date-time-like');\r\n    }\r\n    ES.RejectTemporalLikeObject(temporalZonedDateTimeLike);\r\n\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const epochNs = GetSlot(this, EPOCHNANOSECONDS);\r\n    const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, epochNs);\r\n    const isoDateTime = dateTime(this);\r\n    let fields = {\r\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\r\n      ...isoDateTime.time,\r\n      offset: ES.FormatUTCOffsetNanoseconds(BigInt(offsetNs))\r\n    };\r\n    const partialZonedDateTime = ES.PrepareCalendarFields(\r\n      calendar,\r\n      temporalZonedDateTimeLike,\r\n      ['year', 'month', 'monthCode', 'day'],\r\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset'],\r\n      'partial'\r\n    );\r\n    fields = ES.CalendarMergeFields(calendar, fields, partialZonedDateTime);\r\n\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\r\n    const offset = ES.GetTemporalOffsetOption(resolvedOptions, 'prefer');\r\n    const overflow = ES.GetTemporalOverflowOption(resolvedOptions);\r\n\r\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\r\n    const newOffsetNs = ES.ParseDateTimeUTCOffset(fields.offset);\r\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\r\n      newDateTime.isoDate,\r\n      newDateTime.time,\r\n      'option',\r\n      newOffsetNs,\r\n      timeZone,\r\n      disambiguation,\r\n      offset,\r\n      /* matchMinute = */ false\r\n    );\r\n\r\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\r\n  }\r\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const calendar = GetSlot(this, CALENDAR);\r\n    const iso = dateTime(this).isoDate;\r\n\r\n    let epochNs;\r\n    if (temporalTimeParam === undefined) {\r\n      epochNs = ES.GetStartOfDay(timeZone, iso);\r\n    } else {\r\n      const temporalTime = ES.ToTemporalTime(temporalTimeParam);\r\n      const dt = ES.CombineISODateAndTimeRecord(iso, GetSlot(temporalTime, TIME));\r\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, dt, 'compatible');\r\n    }\r\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, calendar);\r\n  }\r\n  withTimeZone(timeZoneParam: Params['withTimeZone'][0]): Return['withTimeZone'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\r\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\r\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\r\n  }\r\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.AddDurationToZonedDateTime('add', this, temporalDurationLike, options);\r\n  }\r\n  subtract(\r\n    temporalDurationLike: Params['subtract'][0],\r\n    options: Params['subtract'][1] = undefined\r\n  ): Return['subtract'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.AddDurationToZonedDateTime('subtract', this, temporalDurationLike, options);\r\n  }\r\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.DifferenceTemporalZonedDateTime('until', this, other, options);\r\n  }\r\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.DifferenceTemporalZonedDateTime('since', this, other, options);\r\n  }\r\n  round(roundToParam: Params['round'][0]): Return['round'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\r\n    const roundTo =\r\n      typeof roundToParam === 'string'\r\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\r\n        : ES.GetOptionsObject(roundToParam);\r\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\r\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\r\n    const maximumIncrements = {\r\n      day: 1,\r\n      hour: 24,\r\n      minute: 60,\r\n      second: 60,\r\n      millisecond: 1000,\r\n      microsecond: 1000,\r\n      nanosecond: 1000\r\n    };\r\n    const maximum = maximumIncrements[smallestUnit];\r\n    const inclusive = maximum === 1;\r\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\r\n\r\n    if (smallestUnit === 'nanosecond' && roundingIncrement === 1) {\r\n      return ES.CreateTemporalZonedDateTime(\r\n        GetSlot(this, EPOCHNANOSECONDS),\r\n        GetSlot(this, TIME_ZONE),\r\n        GetSlot(this, CALENDAR)\r\n      );\r\n    }\r\n\r\n    // first, round the underlying DateTime fields\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const thisNs = GetSlot(this, EPOCHNANOSECONDS);\r\n    const iso = dateTime(this);\r\n    let epochNanoseconds;\r\n\r\n    if (smallestUnit === 'day') {\r\n      // Compute Instants for start-of-day and end-of-day\r\n      // Determine how far the current instant has progressed through this span.\r\n      const dateStart = iso.isoDate;\r\n      const dateEnd = ES.BalanceISODate(dateStart.year, dateStart.month, dateStart.day + 1);\r\n\r\n      const startNs = ES.GetStartOfDay(timeZone, dateStart);\r\n      assert(\r\n        thisNs >= startNs,\r\n        'cannot produce an instant during a day that occurs before start-of-day instant'\r\n      );\r\n\r\n      const endNs = ES.GetStartOfDay(timeZone, dateEnd);\r\n      assert(\r\n        thisNs < endNs,\r\n        'cannot produce an instant during a day that occurs on or after end-of-day instant'\r\n      );\r\n\r\n      const dayLengthNs = endNs - startNs;\r\n      const dayProgressNs = TimeDuration.fromEpochNsDiff(thisNs, startNs);\r\n      const roundedDayNs = dayProgressNs.round(dayLengthNs, roundingMode);\r\n      epochNanoseconds = roundedDayNs.addToEpochNs(startNs);\r\n    } else {\r\n      // smallestUnit < day\r\n      // Round based on ISO-calendar time units\r\n      const roundedDateTime = ES.RoundISODateTime(iso, roundingIncrement, smallestUnit, roundingMode);\r\n\r\n      // Now reset all DateTime fields but leave the TimeZone. The offset will\r\n      // also be retained if the new date/time values are still OK with the old\r\n      // offset. Otherwise the offset will be changed to be compatible with the\r\n      // new date/time values. If DST disambiguation is required, the `compatible`\r\n      // disambiguation algorithm will be used.\r\n      const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, thisNs);\r\n      epochNanoseconds = ES.InterpretISODateTimeOffset(\r\n        roundedDateTime.isoDate,\r\n        roundedDateTime.time,\r\n        'option',\r\n        offsetNs,\r\n        timeZone,\r\n        'compatible',\r\n        'prefer',\r\n        /* matchMinute = */ false\r\n      );\r\n    }\r\n\r\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const other = ES.ToTemporalZonedDateTime(otherParam);\r\n    const one = GetSlot(this, EPOCHNANOSECONDS);\r\n    const two = GetSlot(other, EPOCHNANOSECONDS);\r\n    if (one !== two) return false;\r\n    if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE))) return false;\r\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\r\n  }\r\n  toString(options: Params['toString'][0] = undefined): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\r\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\r\n    const showOffset = ES.GetTemporalShowOffsetOption(resolvedOptions);\r\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\r\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\r\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\r\n    const showTimeZone = ES.GetTemporalShowTimeZoneNameOption(resolvedOptions);\r\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\r\n    return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\r\n      unit,\r\n      increment,\r\n      roundingMode\r\n    });\r\n  }\r\n  toLocaleString(\r\n    locales: Params['toLocaleString'][0] = undefined,\r\n    options: Params['toLocaleString'][1] = undefined\r\n  ): string {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const resolvedOptions = ES.GetOptionsObject(options);\r\n\r\n    // This is not quite per specification, but this polyfill's DateTimeFormat\r\n    // already doesn't match the InitializeDateTimeFormat operation, and the\r\n    // access order might change anyway;\r\n    // see https://github.com/tc39/ecma402/issues/747\r\n    const optionsCopy = Object.create(null);\r\n    ES.CopyDataProperties(optionsCopy, resolvedOptions, ['timeZone']);\r\n\r\n    if (resolvedOptions.timeZone !== undefined) {\r\n      throw new TypeError('ZonedDateTime toLocaleString does not accept a timeZone option');\r\n    }\r\n\r\n    if (\r\n      optionsCopy.year === undefined &&\r\n      optionsCopy.month === undefined &&\r\n      optionsCopy.day === undefined &&\r\n      optionsCopy.era === undefined &&\r\n      optionsCopy.weekday === undefined &&\r\n      optionsCopy.dateStyle === undefined &&\r\n      optionsCopy.hour === undefined &&\r\n      optionsCopy.minute === undefined &&\r\n      optionsCopy.second === undefined &&\r\n      optionsCopy.fractionalSecondDigits === undefined &&\r\n      optionsCopy.timeStyle === undefined &&\r\n      optionsCopy.dayPeriod === undefined &&\r\n      optionsCopy.timeZoneName === undefined\r\n    ) {\r\n      optionsCopy.timeZoneName = 'short';\r\n      // The rest of the defaults will be filled in by formatting the Instant\r\n    }\r\n\r\n    optionsCopy.timeZone = GetSlot(this, TIME_ZONE);\r\n    if (ES.IsOffsetTimeZoneIdentifier(optionsCopy.timeZone)) {\r\n      // Note: https://github.com/tc39/ecma402/issues/683 will remove this\r\n      throw new RangeError('toLocaleString does not currently support offset time zones');\r\n    }\r\n\r\n    const formatter = new DateTimeFormat(locales, optionsCopy);\r\n\r\n    const localeCalendarIdentifier = customResolvedOptions.call(formatter).calendar as BuiltinCalendarId;\r\n    const calendarIdentifier = GetSlot(this, CALENDAR);\r\n    if (\r\n      calendarIdentifier !== 'iso8601' &&\r\n      localeCalendarIdentifier !== 'iso8601' &&\r\n      !ES.CalendarEquals(localeCalendarIdentifier, calendarIdentifier)\r\n    ) {\r\n      throw new RangeError(\r\n        `cannot format ZonedDateTime with calendar ${calendarIdentifier}` +\r\n          ` in locale with calendar ${localeCalendarIdentifier}`\r\n      );\r\n    }\r\n\r\n    return formatter.format(ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS)));\r\n  }\r\n  toJSON(): Return['toJSON'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.TemporalZonedDateTimeToString(this, 'auto');\r\n  }\r\n  valueOf(): never {\r\n    ES.ValueOfThrows('ZonedDateTime');\r\n  }\r\n  startOfDay(): Return['startOfDay'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n    const isoDate = dateTime(this).isoDate;\r\n    const epochNanoseconds = ES.GetStartOfDay(timeZone, isoDate);\r\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  getTimeZoneTransition(directionParam: Params['getTimeZoneTransition'][0]): Return['getTimeZoneTransition'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    const timeZone = GetSlot(this, TIME_ZONE);\r\n\r\n    if (directionParam === undefined) throw new TypeError('options parameter is required');\r\n    const direction = ES.GetDirectionOption(\r\n      typeof directionParam === 'string'\r\n        ? (ES.CreateOnePropObject('direction', directionParam) as Exclude<typeof directionParam, string>)\r\n        : ES.GetOptionsObject(directionParam)\r\n    );\r\n    if (direction === undefined) throw new TypeError('direction option is required');\r\n\r\n    // Offset time zones or UTC have no transitions\r\n    if (ES.IsOffsetTimeZoneIdentifier(timeZone) || timeZone === 'UTC') {\r\n      return null;\r\n    }\r\n\r\n    const thisEpochNanoseconds = GetSlot(this, EPOCHNANOSECONDS);\r\n    const epochNanoseconds =\r\n      direction === 'next'\r\n        ? ES.GetNamedTimeZoneNextTransition(timeZone, thisEpochNanoseconds)\r\n        : ES.GetNamedTimeZonePreviousTransition(timeZone, thisEpochNanoseconds);\r\n    return epochNanoseconds === null\r\n      ? null\r\n      : ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\r\n  }\r\n  toInstant(): Return['toInstant'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\r\n  }\r\n  toPlainDate(): Return['toPlainDate'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalDate(dateTime(this).isoDate, GetSlot(this, CALENDAR));\r\n  }\r\n  toPlainTime(): Return['toPlainTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalTime(dateTime(this).time);\r\n  }\r\n  toPlainDateTime(): Return['toPlainDateTime'] {\r\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\r\n    return ES.CreateTemporalDateTime(dateTime(this), GetSlot(this, CALENDAR));\r\n  }\r\n\r\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\r\n    return ES.ToTemporalZonedDateTime(item, optionsParam);\r\n  }\r\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\r\n    const one = ES.ToTemporalZonedDateTime(oneParam);\r\n    const two = ES.ToTemporalZonedDateTime(twoParam);\r\n    const ns1 = GetSlot(one, EPOCHNANOSECONDS);\r\n    const ns2 = GetSlot(two, EPOCHNANOSECONDS);\r\n    if (BigInt(ns1) < BigInt(ns2)) return -1;\r\n    if (BigInt(ns1) > BigInt(ns2)) return 1;\r\n    return 0;\r\n  }\r\n  [Symbol.toStringTag]!: 'Temporal.ZonedDateTime';\r\n}\r\n\r\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\r\n\r\nfunction dateTime(zdt: Temporal.ZonedDateTime) {\r\n  return ES.GetISODateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, EPOCHNANOSECONDS));\r\n}\r\n\r\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\r\n  zdt: Temporal.ZonedDateTime,\r\n  prop: P\r\n): CalendarDateRecord[P] {\r\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\r\n  const isoDate = dateTime(zdt).isoDate;\r\n  return ES.calendarImplForObj(zdt).isoToDate(isoDate, { [prop]: true })[prop];\r\n}\r\n\r\nfunction getTimeProperty(zdt: Temporal.ZonedDateTime, prop: Temporal.TimeUnit) {\r\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\r\n  return dateTime(zdt).time[prop];\r\n}\r\n","import * as ES from './ecmascript';\r\n\r\n// By default, a plain function can be called as a constructor. A method such as\r\n// Date.prototype.toTemporalInstant should not be able to. We could check\r\n// new.target in the body of toTemporalInstant, but that is not sufficient for\r\n// preventing construction when passing it as the newTarget parameter of\r\n// Reflect.construct. So we create it as a method of an otherwise unused class,\r\n// and monkeypatch it onto Date.prototype.\r\n\r\nclass LegacyDateImpl {\r\n  toTemporalInstant(this: Date) {\r\n    const epochNanoseconds = ES.epochMsToNs(Date.prototype.valueOf.call(this));\r\n    return ES.CreateTemporalInstant(epochNanoseconds);\r\n  }\r\n}\r\n\r\nexport const toTemporalInstant = LegacyDateImpl.prototype.toTemporalInstant;\r\n","// This entry point treats Temporal as a library, and does not polyfill it onto\r\n// the global object.\r\n// This is in order to avoid breaking the web in the future, if the polyfill\r\n// gains wide adoption before the API is finalized. We do not want checks such\r\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\r\n// shipping the finalized API.\r\n\r\nimport * as Temporal from './temporal';\r\nimport * as Intl from './intl';\r\nimport { toTemporalInstant } from './legacydate';\r\n\r\n// Work around https://github.com/babel/babel/issues/2025.\r\nconst types = [\r\n  Temporal.Instant,\r\n  Temporal.PlainDate,\r\n  Temporal.PlainDateTime,\r\n  Temporal.Duration,\r\n  Temporal.PlainMonthDay,\r\n  // Temporal.Now, // plain object (not a constructor), so no `prototype`\r\n  Temporal.PlainTime,\r\n  Temporal.PlainYearMonth,\r\n  Temporal.ZonedDateTime\r\n];\r\nfor (const type of types) {\r\n  const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype') as PropertyDescriptor;\r\n  if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\r\n    descriptor.configurable = false;\r\n    descriptor.enumerable = false;\r\n    descriptor.writable = false;\r\n    Object.defineProperty(type, 'prototype', descriptor);\r\n  }\r\n}\r\n\r\nexport { Temporal, Intl, toTemporalInstant };\r\n"],"names":["assert","condition","message","Error","concat","assertNotReached","reason","ZERO","ONE","TWO","TEN","TWENTY_FOUR","SIXTY","THOUSAND","MILLION","BILLION","HOUR_SECONDS","HOUR_NANOS","MINUTE_NANOS","DAY_NANOS","isEven","value","abs","x","compare","y","divmod","EPOCHNANOSECONDS","ISO_DATE","ISO_DATE_TIME","TIME","CALENDAR","DATE_BRAND","YEAR_MONTH_BRAND","MONTH_DAY_BRAND","TIME_ZONE","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","SECONDS","MILLISECONDS","MICROSECONDS","NANOSECONDS","YM","MD","TIME_FMT","ORIGINAL","TZ_CANONICAL","TZ_ORIGINAL","CAL_ID","LOCALE","INTRINSICS","IntlDateTimeFormat","depth","options","inspect","GetSlot","_objectSpread","_defineProperty","_customUtilInspectFor","TemporalDuration","descr","stylize","_repr_","entries","i","props","length","prop","push","TruncatingDivModByPowerOf10","xParam","p","mod","sign","Math","xDigits","trunc","log10","div","xStr","toPrecision","Number","parseInt","slice","FMAPowerOf10","zParam","z","repeat","zStr","padStart","resStr","GetUnsignedRoundingMode","mode","isNegative","ApplyUnsignedRoundingMode","TimeDuration","totalNs","_classCallCheck","sec","subsec","isSafeInteger","_createClass","key","validateNew","other","add24HourDays","days","isInteger","BigInt","epochNs","cmp","n","quotient","_divmod2","remainder","q","r","nParam","nBigInt","_divmod3","operation","MAX","fromEpochNsDiff","epochNs1","epochNs2","diff","h","min","s","ms","µs","ns","offsetIdentifierNoCapture","tzComponent","timeZoneID","RegExp","source","yearpart","monthpart","daypart","datesplit","timesplit","offsetWithParts","offset","offsetpart","offsetIdentifier","annotation","zoneddatetime","join","time","DAY_MS","DAY_NANOS_BI","MS_MAX","NS_MAX","epochMsToNs","NS_MIN","DATETIME_NS_MIN","DATETIME_NS_MAX","BUILTIN_CALENDAR_IDS","ICU_LEGACY_TIME_ZONE_IDS","Set","assertExists","arg","castExists","IsObject","_typeof","ToNumber","TypeError","IsIntegralNumber","argument","isNaN","Infinity","absValue","ToString","String","ToIntegerWithTruncation","number","RangeError","integer","ToPositiveIntegerWithTruncation","valueParam","property","undefined","ToIntegerIfIntegral","ToZeroPaddedDecimalString","minLength","RequireString","ToSyntacticallyValidMonthCode","ToPrimitive","indexOf","ToOffsetString","ParseDateTimeUTCOffset","preferredType","result","toString","CALENDAR_FIELD_KEYS","BUILTIN_CASTS","era","eraYear","year","month","monthCode","day","hour","minute","millisecond","microsecond","nanosecond","timeZone","ToTemporalTimeZoneIdentifier","BUILTIN_DEFAULTS","second","SINGULAR_FOR","Object","fromEntries","TEMPORAL_UNITS","map","e","PLURAL_FOR","_ref","_ref2","_slicedToArray","UNITS_DESCENDING","_ref3","_ref4","NS_PER_TIME_UNIT","DURATION_FIELDS","OriginalIntlDateTimeFormat","Intl","DateTimeFormat","IntlDateTimeFormatEnUsCache","Map","getIntlDateTimeFormatEnUsForTimeZone","timeZoneIdentifier","lowercaseIdentifier","ASCIILowercase","instance","get","hour12","set","ToObject","CopyDataProperties","excludedKeys","excludedValues","keys","Reflect","ownKeys","_loop","nextKey","index","some","is","propertyIsEnumerable","call","propValue","target","_ret","IsTemporalInstant","item","HasSlot","IsTemporalDuration","IsTemporalDate","IsTemporalTime","IsTemporalDateTime","IsTemporalYearMonth","IsTemporalMonthDay","IsTemporalZonedDateTime","CheckReceiver","test","RejectTemporalLikeObject","calendar","FormatCalendarAnnotation","id","showCalendar","flag","processAnnotations","annotations","PARSE","lastIndex","match","exec","_match","critical","calendarWasCritical","ParseISODateTime","isoString","_ref5","_match$","_ref6","_match$2","_match$3","_ref7","_match$4","_ref8","_match$5","_ref9","_match$6","yearString","hasTime","fraction","tzAnnotation","RejectDateTime","ParseTemporalInstantString","ParseTemporalZonedDateTimeString","ParseTemporalDateTimeString","ParseTemporalDateString","ParseTemporalTimeString","_match$7","_ref10","_match$8","_ref11","_match$9","_ref12","_match$10","_ParseISODateTime","_time","RejectTime","_ParseTemporalMonthDa","ParseTemporalMonthDayString","RejectISODate","_unused","_ParseTemporalYearMon","ParseTemporalYearMonthString","_unused2","referenceISODay","_ParseISODateTime2","referenceISOYear","_ParseISODateTime3","TIMEZONE_IDENTIFIER","OFFSET_IDENTIFIER","throwBadTimeZoneStringError","timeZoneString","msg","OFFSET","ParseTimeZoneIdentifier","identifier","offsetNanoseconds","offsetMinutes","tzName","ParseTemporalTimeZoneStringRaw","_ParseISODateTime4","_unused3","stringIdent","_ParseTemporalTimeZon","ParseTemporalDurationStringRaw","every","part","years","months","weeks","hours","fHours","minutesStr","fMinutes","secondsStr","fSeconds","excessNanoseconds","_ref13","_ref14","_ref15","_ref16","seconds","nanoseconds","milliseconds","minutes","RejectDuration","microseconds","ParseTemporalDurationString","_ParseTemporalDuratio","GetIntrinsic","RegulateISODate","yearParam","monthParam","dayParam","overflow","_ConstrainISODate","ConstrainISODate","RegulateTime","minuteParam","secondParam","millisecondParam","microsecondParam","nanosecondParam","ConstrainToRange","ToTemporalPartialDurationRecord","temporalDurationLike","any","AdjustDateDurationRecord","_ref17","newDays","newWeeks","newMonths","ZeroDateDuration","CombineISODateAndTimeRecord","isoDate","MidnightTimeRecord","deltaDays","NoonTimeRecord","GetTemporalOverflowOption","GetOption","GetTemporalDisambiguationOption","GetRoundingModeOption","fallback","NegateRoundingMode","roundingMode","GetTemporalOffsetOption","GetTemporalShowCalendarNameOption","GetTemporalShowTimeZoneNameOption","GetTemporalShowOffsetOption","GetDirectionOption","REQUIRED","GetTemporalRoundingIncrementOption","increment","roundingIncrement","integerIncrement","ValidateTemporalRoundingIncrement","dividend","inclusive","maximum","GetTemporalFractionalSecondDigitsOption","normalizedOptions","digitsValue","fractionalSecondDigits","digitCount","floor","ToSecondsStringPrecisionRecord","smallestUnit","precision","unit","pow","Symbol","GetTemporalUnitValuedOption","unitGroup","allowedSingular","unitInfo","singular","category","defaultVal","requiredOrDefault","allowedValues","plural","retval","GetTemporalRelativeToOption","relativeTo","offsetBehaviour","matchMinutes","zonedRelativeTo","plainRelativeTo","CreateTemporalDate","GetTemporalCalendarIdentifierWithISODefault","fields","PrepareCalendarFields","_InterpretTemporalDat","InterpretTemporalDateTimeFields","_ParseISODateTime5","CanonicalizeCalendar","offsetNs","epochNanoseconds","InterpretISODateTimeOffset","CreateTemporalZonedDateTime","DefaultTemporalLargestUnit","duration","LargerOfTwoTemporalUnits","unit1","i1","i2","unit2","IsCalendarUnit","TemporalUnitCategory","calendarImplForID","calendarImplForObj","temporalObj","ISODateToFields","type","arguments","create","calendarImpl","calendarDate","isoToDate","bag","extraFieldNames","extraFields","calendarFieldNames","nonCalendarFieldNames","sort","requiredFields","includes","ToTemporalTimeRecord","field","ToTemporalDate","GetOptionsObject","isoDateTime","GetISODateTimeFor","CalendarDateFromFields","_ParseTemporalDateStr","ToTemporalDateTime","CreateTemporalDateTime","_InterpretTemporalDat2","_ParseTemporalDateTim","ToTemporalDuration","partial","ToTemporalInstant","itemParam","CreateTemporalInstant","_ParseTemporalInstant","_ref18$hour","_ref18$minute","_ref18","_ref18$second","_ref18$millisecond","_ref18$microsecond","_ref18$nanosecond","balanced","CheckISODaysRange","GetUTCEpochNanoseconds","ToTemporalMonthDay","CreateTemporalMonthDay","CalendarMonthDayFromFields","_ParseTemporalMonthDa2","isoCalendarReferenceYear","ToTemporalTime","CreateTemporalTime","_ToTemporalTimeRecord","ToTimeRecordOrMidnight","ToTemporalYearMonth","CreateTemporalYearMonth","CalendarYearMonthFromFields","_ParseTemporalYearMon2","RejectYearMonthRange","disambiguation","offsetOpt","matchMinute","GetStartOfDay","dt","GetEpochNanosecondsFor","BalanceISODateTime","ValidateEpochNanoseconds","utcEpochNs","possibleEpochNs","candidate","candidateOffset","roundedCandidateOffset","RoundNumberToIncrement","offsetStr","FormatUTCOffsetNanoseconds","dtStr","ISODateTimeToString","DisambiguatePossibleEpochNanoseconds","ToTemporalZonedDateTime","resolvedOptions","_InterpretTemporalDat3","_ParseTemporalZonedDa","CreateTemporalDateSlots","CreateSlots","SetSlot","repr","writable","enumerable","configurable","TemporalPlainDate","prototype","CreateTemporalDateTimeSlots","defineProperty","TemporalPlainDateTime","CreateTemporalMonthDaySlots","RejectDateRange","TemporalPlainMonthDay","CreateTemporalTimeSlots","TemporalPlainTime","CreateTemporalYearMonthSlots","TemporalYearMonthToString","TemporalPlainYearMonth","CreateTemporalInstantSlots","GetISOPartsFromEpoch","toStringTag","TemporalInstant","CreateTemporalZonedDateTimeSlots","TemporalZonedDateTimeToString","TemporalZonedDateTime","CalendarFieldKeysPresent","filter","CalendarMergeFields","additionalKeys","additionalFields","overriddenKeys","fieldKeysToIgnore","merged","fieldsKeys","ix","CalendarDateAdd","dateAdd","dateDuration","CalendarDateUntil","dateUntil","isoOtherDate","largestUnit","ToTemporalCalendarIdentifier","calendarLike","_unused4","_ParseISODateTime6","_unused5","_ParseTemporalTimeStr","_unused6","_ParseTemporalYearMon3","_unused7","_ParseTemporalMonthDa3","CalendarEquals","one","two","resolveFields","dateToISO","monthDayToISOReferenceDate","temporalTimeZoneLike","_ParseTemporalTimeZon2","ParseTemporalTimeZoneString","FormatOffsetTimeZoneIdentifier","record","GetAvailableNamedTimeZoneIdentifier","TimeZoneEquals","offsetMinutes1","offsetMinutes2","idRecord2","idRecord1","primaryIdentifier","GetOffsetNanosecondsFor","_ParseTimeZoneIdentif","GetNamedTimeZoneOffsetNanoseconds","absoluteNs","subSecondNs","timeString","FormatTimeString","_GetISOPartsFromEpoch2","_GetISOPartsFromEpoch","_GetISOPartsFromEpoch3","GetPossibleEpochNanoseconds","numInstants","utcns","dayBefore","dayAfter","offsetAfter","offsetBefore","fromComponents","AddTime","timeDuration","earlierDate","BalanceISODate","earlierTime","earlier","laterTime","laterDate","later","possible","GetNamedTimeZoneEpochNanoseconds","IsOffsetTimeZoneIdentifier","GetNamedTimeZoneNextTransition","ISOYearString","yearNumber","ISODateTimePartString","FormatFractionalSeconds","subSecondNanoseconds","fractionFullPrecision","replace","TemporalInstantToString","outputTimeZone","instant","iso","dateTimeString","FormatDateTimeUTCOffsetRounded","TemporalDurationToString","DurationSign","datePart","timePart","secondsDuration","isZero","secondsPart","subSecondsPart","TemporalDateToString","date","_GetSlot","monthString","dayString","TimeRecordToString","_ref19","_isoDateTime$isoDate","_isoDateTime$time","calendarString","TemporalMonthDayToString","monthDay","_GetSlot2","resultString","yearMonth","_GetSlot3","zdt","showTimeZone","showOffset","RoundTemporalInstant","tz","string","OFFSET_WITH_PARTS","canonicalTimeZoneIdsCache","isTZIDSep","assign","_","_canonicalTimeZoneIds","_specialCases$get","_specialCases$get2","_Intl$supportedValues","_Intl","canonicalTimeZoneIds","supportedValuesOf","lower","formatter","_unused8","has","chars","_toConsumableArray","c","toUpperCase","standardCase","segments","split","etcName","specialCases","GetNamedTimeZoneOffsetNanosecondsImpl","epochMilliseconds","_GetFormatterParts","GetFormatterParts","GetUTCEpochMilliseconds","epochNsToMs","absoluteMinutes","offsetNanosecondsParam","_ref20","_ref20$isoDate","_ref20$time","reducedYear","yearCycles","legacyDate","Date","setUTCHours","setUTCFullYear","getTime","subMs","nanos","getUTCFullYear","getUTCDate","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","GetNamedTimeZoneDateTimeParts","_GetISOPartsFromEpoch4","_GetISOPartsFromEpoch5","_GetFormatterParts2","searchWindowForTransitions","BEFORE_FIRST_DST","now","base","max","uppercap","leftMs","rightOffsetNs","leftOffsetNs","rightMs","searchWindow","bisect","epochMs","GetNamedTimeZonePreviousTransition","lookahead","prevBeforeLookahead","UTC","lastPrecomputed","parseFromEnUsFormat","datetime","splits","isFinite","format","nsEarlier","nsLater","earlierOffsetNs","laterOffsetNs","found","candidates","parts","CompareISODateTime","LeapYear","isDiv4","isDiv100","isDiv400","ISODaysInMonth","DoM","standard","leapyear","DateDurationSign","fieldNames","InternalDurationSign","dateSign","BalanceISOYearMonth","_BalanceISOYearMonth","daysIn400YearCycle","nCycles","testYear","daysInYear","_BalanceISOYearMonth2","_BalanceISOYearMonth3","BalanceTime","hourParam","_TruncatingDivModByPo","_TruncatingDivModByPo2","DateDurationDays","yearsMonthsWeeksDuration","epochDaysEarlier","ISODateToEpochDays","epochDaysLater","yearsMonthsWeeksInDays","CreateNegatedTemporalDuration","RejectToRange","RejectDateTimeRange","AssertISODateTimeWithinLimits","_ref21","YEAR_MIN","YEAR_MAX","w","d","mon","propSign","msResult","µsResult","nsResult","remainderSec","totalSec","ToInternalDurationRecord","ToInternalDurationRecordWith24HourDays","ToDateDurationRecordWithoutTime","internalDuration","TemporalDurationFromInternal","CombineDateAndTimeDuration","timeSign","_ref22","DifferenceTime","time1","time2","DifferenceInstant","ns1","ns2","DifferenceISODateTime","isoDateTime1","isoDateTime2","CompareISODate","adjustedDate","dateLargestUnit","dateDifference","DifferenceZonedDateTime","nsDiff","isoDtStart","isoDtEnd","dayCorrection","intermediateDateTime","maxDayCorrection","intermediateDate","intermediateNs","NudgeToCalendarUnit","durationParam","destEpochNs","r1","endDuration","r2","startDuration","weeksStart","yearsMonths","weeksEnd","untilResult","start","end","startEpochNs","endEpochNs","startDateTime","endDateTime","numerator","denominator","unsignedRoundingMode","add","subtract","even","roundedUnit","fakeNumerator","total","fdiv","didExpandCalendarUnit","nudgedEpochNs","NudgeToZonedTime","arrayFromSet","src","calendarDateWeekOfYear","impl","yow","_calendar$isoToDate","dayOfWeek","dayOfYear","fdow","getFirstDayOfWeek","mdow","getMinimalDaysInFirstWeek","relDow","relDowJan1","prevYearCalendar","prevDoy","woy","weekNumber","lastDoy","lastRelDow","week","y1","isoDate2","m1","resolveNonLunisolarMonth","_fields$year","_ES$RegulateISODate","ES","_ref$years","_ref$months","_ref$weeks","_ref$days","_ES$BalanceISOYearMon","_ES$RegulateISODate2","intermediate","candidateYears","ISODateSurpasses","candidateMonths","constrained","requestedFields","daysInWeek","monthsInYear","buildMonthCode","shiftedMonth","shiftedYear","century","yearInCentury","monthTerm","yearTerm","centuryTerm","dow","m","startsWith","leap","leapMarker","digitPart","monthsPerYear","numberPart","nonLeapMonthCodeNumberPart","firstDayOfWeek","minimalDaysInFirstWeek","desiredDay","periodStartDayOfWeek","weekNo","OneObjectCache","cacheToClone","calls","hits","_iterator","_createForOfIteratorHelper","_step","_this$map","entry","MAX_CACHE_ENTRIES","apply","err","f","report","misses","objectMap","obj","getCacheForObject","cache","WeakMap","toUtcIsoDateString","isoYear","isoMonth","isoDay","simpleDateDiff","HelperBase","getFormatter","getCalendarParts","dateTimeFormat","locale","isoToCalendarDate","_this","JSON","stringify","func","cached","matches","hasEra","normalize","replacement","eras","find","genericName","code","reviseIntlEra","_this$reviseIntlEra","checkIcuBugs","adjustCalendarDate","keyReverse","forEach","cacheReverse","monthExtra","_resolveNonLunisolarM","largestMonth","regulateMonthDayNaive","maximumMonthLength","calendarToIsoDate","_this2","originalDate","dateParam","_date","keyOriginal","estimateIsoDate","calculateSameMonthResult","diffDays","testIsoEstimate","addDaysIso","isoEstimate","minimumMonthLength","testCalendarDate","roundtripEstimate","diffTotalDaysEstimate","compareCalendarDates","oldRoundtripEstimate","oldSign","order","date1","date2","added","addedIso","addedCalendar","calendarDateParam","_calendarDate","absMonths","oldCalendarDate","daysInPreviousMonth","daysInMonth","monthsInOldYear","regulateDate","addCalendar","_ref4$years","_ref4$months","_ref4$weeks","_ref4$days","addedYears","addedMonths","addMonthsCalendar","addedDays","addDaysCalendar","initialDays","calendarTwo","calendarDaysUntil","calendarOne","totalDays","diffYears","diffInYearSign","isOneFurtherInYear","yearsAdded","current","next","remainingDays","addedIsoDate","addedCalendarDate","endOfMonthIso","endOfMonthCalendar","previousMonthYear","previousMonthDate","previousMonth","lastDayOfPreviousMonthIso","lastDayOfPreviousMonthCalendar","startOfCalendarMonth","oneIso","twoIso","monthDayFromFields","_this$isoToCalendarDa","closestCalendar","monthDaySearchStartYear","startDateIso","calendarYear","calendarOfStartDateIso","roundTripCalendarDate","maxDayForMonthCode","closestIso","HebrewHelper","_HelperBase","_inherits","_super","_createSuper","_this3","regular","Kislev","Tevet","Nisan","Iyar","Sivan","Tamuz","Elul","minMaxMonthLength","minOrMax","monthInfo","maxLengthOfMonthCodeInAnyYear","inLeapYear","fromLegacyDate","getMonthCode","validateCalendarDate","endsWith","calculatedMonthCode","IslamicBaseHelper","_HelperBase2","_super2","_this4","DAYS_PER_ISLAMIC_YEAR","DAYS_PER_ISO_YEAR","startOfYearCalendar","startOfNextYearCalendar","_this$adjustCalendarD","IslamicHelper","_IslamicBaseHelper","_super3","_this5","IslamicUmalquraHelper","_IslamicBaseHelper2","_super4","_this6","IslamicTblaHelper","_IslamicBaseHelper3","_super5","_this7","IslamicCivilHelper","_IslamicBaseHelper4","_super6","_this8","IslamicRgsaHelper","_IslamicBaseHelper5","_super7","_this9","IslamicCcHelper","_IslamicBaseHelper6","_super8","_this10","_HelperBase3","PersianHelper","_super9","_this11","calendarType","_this$adjustCalendarD2","IndianHelper","_HelperBase4","_super10","_this12","nextYear","vulnerableToBceBug","toLocaleDateString","isGregorianLeapYear","getMonthInfo","_monthInfo$leap","adjustEras","erasParam","reverseOf","anchorEra","isAnchor","anchorEpoch","hasYearZero","reversedEra","isoEpoch","e1","e2","lastEraReversed","GregorianBaseHelperFixedEpoch","_HelperBase5","_super11","_this13","_this$estimateIsoDate","GregorianBaseHelper","originalEras","_this14","_super12","_adjustEras","_this$estimateIsoDate2","_this15","checkField","names","currentValue","preferredName","expected","eraFromYear","adjustedCalendarDate","matchingEra","comparison","eraNames","matchData","_ref5$names","_eraFromYear","_calendarDate3","completeEraYear","_get","_getPrototypeOf","isoYearEstimate","SameMonthDayAsGregorianBaseHelper","_GregorianBaseHelper","_super13","OrthodoxBaseHelperFixedEpoch","_GregorianBaseHelperF","_super14","_this16","OrthodoxOps","_GregorianBaseHelper2","OrthodoxBaseHelper","_super15","_this17","_OrthodoxBaseHelperFi","EthioaaHelper","_super16","CopticHelper","_OrthodoxBaseHelper","_super17","EthiopicHelper","_super18","BuddhistHelper","_GregorianBaseHelperF2","_super20","GregoryHelper","_SameMonthDayAsGregor2","_super21","JapaneseHelper","_SameMonthDayAsGregor3","_super22","_this18","ChineseBaseHelper","_HelperBase7","_super23","_this19","getMonthList","_monthMap$monthCode","monthMap","M02L","M04L","M05L","M06L","M07L","M08L","M09L","M10L","M11L","M12L","_this20","getCalendarDate","daysPastFeb1","isoStringFeb1","setUTCDate","newYearGuess","formatToParts","calendarMonthString","tv","calendarDay","calendarYearPartToVerify","calendarYearToVerify","getSlotLazy","slot","val","OPTIONS","ResetSlot","createDateTimeFormat","dtf","optionsParam","hasOptions","newOptions","hasOwnProperty","original","ro","clonedResolved","hourCycle","DATE","dateAmend","yearMonthAmend","monthDayAmend","timeAmend","DATETIME","datetimeAmend","INST","instantAmend","timeZoneOption","IsPatchedDateTimeFormat","DateTimeFormatImpl","locales","boundFormat","bind","defineProperties","name","formatRange","a","b","_len","rest","Array","_key","formatRangeToParts","supportedLocalesOf","MakeIntrinsicClass","resolved","overrides","extractOverrides","formatArgs","_len2","_formatter","_formatter2","_len3","_key3","aParam","bParam","_formatter3","toDateTimeFormattable","isTemporalObject","sameTemporalType","_extractOverrides","aa","aformatter","_extractOverrides2","bb","bformatter","_formatter4","_extractOverrides3","_extractOverrides4","amend","amended","opt","originalOptions","weekday","timeZoneName","dateStyle","timeStyle","hasTimeOptions","hasAnyDateTimeOptions","dateStyleHacks","short","medium","long","full","dayPeriod","style","hasDateOptions","Instant","until","round","roundToParam","roundTo","maximumIncrements","roundedNs","otherParam","digits","_ES$ToSecondsStringPr","roundedInstant","toJSON","toZonedDateTimeISO","timeZoneParam","epochNanosecondsParam","oneParam","twoParam","oneNs","PlainDate","calendarParam","getCalendarProperty","_getCalendarProperty","_getCalendarProperty2","temporalDateLike","partialDate","withCalendar","toLocaleString","valueOf","temporalTime","toZonedDateTime","timeZoneLike","plainTime","PlainDateTime","getTimeProperty","_with","temporalDateTimeLike","partialDateTime","newDateTime","Duration","yearsParam","monthsParam","weeksParam","hoursParam","minutesParam","secondsParam","millisecondsParam","microsecondsParam","nanosecondsParam","daysParam","durationLike","partialDuration","_partialDuration$year","_partialDuration$mont","_partialDuration$week","_partialDuration$days","_partialDuration$hour","_partialDuration$minu","_partialDuration$seco","_partialDuration$mill","_partialDuration$micr","_partialDuration$nano","_ES$GetTemporalRelati","smallestUnitPresent","defaultLargestUnit","largestUnitPresent","relativeEpochNs","targetEpochNs","targetTime","isoRelativeToDate","targetDateTime","targetDate","existingLargestUnit","_internalDuration$tim","_ES$GetTemporalRelati2","PlainMonthDay","temporalMonthDayLike","partialMonthDay","equals","toPlainDate","SystemDateTime","plainDateTimeISO","zonedDateTimeISO","plainDateISO","plainTimeISO","timeZoneId","Now","PlainTime","isoHour","isoMinute","isoSecond","isoMillisecond","isoNanosecond","isoMicrosecond","temporalTimeLike","partialTime","_Object$assign","_ES$RegulateTime","since","MAX_INCREMENTS","PlainYearMonth","temporalYearMonthLike","partialYearMonth","ZonedDateTime","_ES$ParseTimeZoneIden","today","tomorrow","todayNs","tomorrowNs","temporalZonedDateTimeLike","dateTime","partialZonedDateTime","withPlainTime","temporalTimeParam","thisNs","dateStart","startNs","endNs","dateEnd","dayLengthNs","dayProgressNs","roundedDayNs","addToEpochNs","roundedDateTime","optionsCopy","localeCalendarIdentifier","customResolvedOptions","calendarIdentifier","LegacyDateImpl","toTemporalInstant","types","Temporal","_i","_types","descriptor","getOwnPropertyDescriptor"],"mappings":"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"}