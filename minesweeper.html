<!DOCTYPE html>
<html>

<head>
    <title>Sweeper of Mines</title>
    <style>
        :root {
            --size-mine: 40px;
            --size-icon: calc(var(--size-mine) - 12px);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
        }

        .fieldset {
            border: 1px solid black;
            display: flex;
            flex-flow: row nowrap;
            align-items: baseline;
            justify-content: center;
            position: relative;
            padding: 0.5rem 1rem;
            margin-top: 0.5rem;
        }

        .legend {
            background-color: #fff;
            flex: none;
            font-size: smaller;
            font-weight: 700;
            position: absolute;
            top: -0.5rem;
            left: 1rem;
            padding: 0 4px;
        }

        .radio {
            flex: 0 0 auto;
            padding: 0 1rem;
        }

        .scoreboard {
            display: flex;
            flex-flow: row nowrap;
            justify-content: center;
            margin: 1rem auto;
        }

        .scoreboard-unit {
            margin: 0 0.5rem;
        }

        .custom-unit {
            width: 3rem;
        }

        .board {
            margin: 0 auto;
            display: flex;
            flex-flow: row wrap;
            justify-content: space-around;
            align-items: center;
            align-content: center;
            background-color: gray;
            position: relative;
        }

        .cell {
            background-color: #fff;
            border: 1px solid black;
            border-radius: 5px;
            flex: 0 0 auto;
            font-size: var(--size-mine);
            line-height: var(--size-mine);
            height: var(--size-mine);
            width: var(--size-mine);
            cursor: pointer;
            margin: 1px;
            padding: 0;
            outline: none;
        }

        .cell:active {
            outline: none;
        }

        .cell .overlay {
            opacity: 0;
        }

        .cell.hidden .overlay {
            display: inline-block;
            height: calc(var(--size-mine) - 2px);
            max-height: calc(var(--size-mine) - 2px);
            width: calc(var(--size-mine) - 2px);
            background-color: lightblue;
            opacity: 1;
            overflow: hidden;
        }

        .cell.nearby {
            text-align: center;
            font-size: var(--size-icon);
        }

        .cell.nearby-1 {
            color: lightblue;
            text-shadow: darkblue -2px 2px;
        }

        .cell.nearby-2 {
            color: green;
            text-shadow: darkgreen -2px 2px;
        }

        .cell.nearby-3 {
            color: red;
            text-shadow: darkred -2px 2px;
        }

        .cell.nearby-4 {
            color: darkblue;
            text-shadow: black -2px 2px;
        }

        .cell.nearby-5 {
            color: darkred;
            text-shadow: black -2px 2px;
        }

        .cell.nearby-6 {
            color: darkgreen;
            text-shadow: black -2px 2px;
        }

        .cell.nearby-7 {
            color: darkmagenta;
            text-shadow: black -2px 2px;
        }

        .cell.nearby-8 {
            color: darkorange;
            text-shadow: black -2px 2px;
        }

        .cell.blank {
            background-color: white;
        }

        .cell.mine {
            font-size: var(--size-icon);
        }

        .cell.flag .overlay {
            background-color: goldenrod;
            font-size: calc(var(--size-icon)/2);
        }
        

        dialog::backdrop {
            background-color: rgba(0,0,0,0.7);
        }
    </style>
    <script>
        class Timer {
            constructor(timerElement) {
                this.element = timerElement;
                this.timerId = -1;
                this.lastCheck = Date.now();
                this.lastElapsed = 0;
                this.elapsed = 0;
                this.isRunning = false;
            }
            tick() {
                this.isRunning = true;
                this.elapsed = Date.now() - this.lastCheck;
                if (this.lastElapsed !== this.elapsed) {
                    this.element.innerHTML = this.toString();
                    this.lastElapsed = this.elapsed;
                }
            }
            start() {
                this.stop();
                this.clear();
                this.lastCheck = Date.now();
                this.timerId = setInterval(this.tick.bind(this), 100);
                this.element.setAttribute("data-timer", this.timerId);
            }
            stop() {
                clearInterval(this.timerId);
                this.element.setAttribute("data-timer", null);
                this.isRunning = false;
            }
            clear() {
                this.elapsed = 0;
                this.element.innerHTML = this.toString();
            }
            toString() {
                let t = this.elapsed;
                let m = Math.floor(t / 60000);
                t = t % 60000;
                let s = Math.floor(t / 1000);
                return `${`00${m}`.slice(-2)}:${`00${s}`.slice(-2)}`;
            }
        }

        class MineBoard {
            constructor(boardRoot, width, height) {
                this.element = boardRoot;
                this.width = width;
                this.height = height;
                this.cellCount = width * height;
                this.mineCount = Math.floor(this.cellCount / 6);
                this.cells = new Array(this.cellCount);
                this.lastClick = 0;
                this.timer = new Timer(document.querySelector(".timer"));
                this.timer.clear();
                this.randomValues = new Uint8Array(this.cellCount);
                window.crypto.getRandomValues(this.randomValues);
            }
            init() {
                let isBetween = function (value, min, max) {
                    return (value >= min) && (value <= max);
                };
                let boardCells = [];
                for (let x = 0; x < this.width; x++) {
                    boardCells[x] = [];
                    for (let y = 0; y < this.height; y++) {
                        boardCells[x][y] = 0;
                    }
                }

                let x, y, value = -(this.mineCount * 2);
                for (let i = 0; i < this.mineCount; i++) {
                    while (true) {
                        x = Math.floor(Math.random() * this.width);
                        y = Math.floor(Math.random() * this.height);
                        if (0 <= boardCells[x][y]) {
                            break;
                        }
                    }
                    for (let n = -1; n < 2; n++) {
                        for (let m = -1; m < 2; m++) {
                            if (n === 0 && m === 0) {
                                boardCells[x][y] = value;
                            } else if (isBetween(x + n, 0, this.width - 1) && isBetween(y + m, 0, this.height - 1)) {
                                boardCells[x + n][y + m]++;
                            }
                        }
                    }
                }

                let index = 0;
                for (let x = 0; x < this.width; x++) {
                    for (let y = 0; y < this.height; y++) {
                        let i = index;
                        this.cells[index++] = {
                            value: boardCells[x][y],
                            hasMine: boardCells[x][y] < 0,
                            nearby: boardCells[x][y] >= 0 ? boardCells[x][y] : 0,
                            x: x,
                            y: y,
                            index: i,
                            hidden: true,
                            flag: false,
                            hadOverlay: false
                        };
                    }
                }
            }
            clearNearby(cellIndex, wasClicked) {
                let cell = this.cells[cellIndex];
                console.log(`nearby {hadOverlay: ${cell.hadOverlay},wasClicked: ${wasClicked}}`);
            }
            clearAround(cellIndex) {
                let cell = this.cells[cellIndex];
                cell.hidden = false;
                let minX = cell.x === 0 ? 0 : cell.x - 1;
                let maxX = cell.x === this.width - 1 ? cell.x : cell.x + 1;
                let minY = cell.y === 0 ? 0 : cell.y - 1;
                let maxY = cell.y === this.height - 1 ? cell.y : cell.y + 1;
                console.log({
                    x: {
                        min: minX,
                        max: maxX
                    },
                    y: {
                        min: minY,
                        max: maxY
                    }
                });
                for (let x = minX; x < maxX + 1; x++) {
                    for (let y = minY; y < maxY + 1; y++) {
                        let nextCell = this.cells.filter(c => c.x === x && c.y === y)[0];
                        if (nextCell.index !== cellIndex && nextCell.hidden) {
                            this.revealCell(nextCell.index, true, false);
                        }
                    }
                }
            }
            showCell(options) {
                let { cellIndex, wasClicked, onLose, onBlank, onNearby, onWin } = options;
                let cell = this.cells[cellIndex];
                cell.hidden = false;
                let cel = cell.element;
                if (cell.hasMine) {
                    // lose
                    cel.className = "cell mine";
                    cel.innerHTML = "💣";
                    if (onLose) { onLose(); }
                } else if (cell.nearby === 0) {
                    cel.className = "cell hidden blank";
                    setTimeout(function () {
                        cel.classList.remove("hidden");
                        cel.innerHTML = "&nbsp;";
                        this.lastClick -= 1;
                    }, this.lastClick * 20);
                    this.lastClick += 1;
                    if (onBlank) { onBlank(cellIndex); }
                } else if (this.mineCount === 0) {
                    if (onWin) { onWin(); }
                } else {
                    cel.className = `cell hidden nearby nearby-${cell.nearby}`;
                    setTimeout(function () {
                        cel.classList.remove("hidden");
                        cel.innerHTML = cell.nearby;
                        this.lastClick -= 1;
                    }, this.lastClick * 20);
                    this.lastClick += 1;
                    if (onNearby) { onNearby(cellIndex, wasClicked); }
                }
            }
            revealCell(cellIndex, hadOverlay, wasClicked) {
                if (!this.timer.isRunning) {
                    this.timer.start();
                }
                this.cells[cellIndex].hadOverlay = hadOverlay;
                this.showCell({
                    cellIndex: cellIndex,
                    wasClicked: wasClicked,
                    onLose: this.lose.bind(this),
                    onBlank: this.clearAround.bind(this),
                    onNearby: this.clearNearby.bind(this),
                    onWin: this.win.bind(this)
                });
                console.log(`cell ${cellIndex} revealed`);
            }
            win() {
                this.timer.stop();
                showModalInBoard(this.element, document.getElementById("youWin"));
            }
            lose() {
                this.timer.stop();
                showModalInBoard(this.element, document.getElementById("youLose"));
                this.cells.filter(c => c.hidden).forEach(c => this.showCell({cellIndex: c.index}));
            }
            toggleFlag(cellIndex) {
                let cell = this.cells[cellIndex];
                let cel = cell.element;
                if (cell.flag) {
                    cell.flag = false;
                    cel.classList.remove("flag");
                    cel.querySelector(".overlay").innerHTML = "&nbsp;";
                    this.mineCount++;
                } else if (cell.hidden) {
                    cell.flag = true;
                    cel.classList.add("flag");
                    cel.querySelector(".overlay").innerHTML = "🚩";
                    this.mineCount--;
                }
                document.querySelector(".count").innerHTML = this.mineCount;
            }
            clearBoard() {
                this.element.innerHTML = MineBoard.clearBoardHtml;
            }
            static get clearBoardHtml() {
                return `<dialog id="youWin">
    <h2>You win! 🎉</h2>
</dialog>
<dialog id="youLose">
    <h2>You lose! 😞</h2>
</dialog>`;
            }
        }

        function showModalInBoard(boardRoot, modalEl) {
            let modalElRect = boardRoot.getBoundingClientRect();
            modalEl.style.top = `${modalElRect.top}px`;
            modalEl.style.right = `${modalElRect.left}px`;
            modalEl.style.bottom = `${window.innerHeight - modalElRect.top - modalElRect.height}px`;
            modalEl.style.left = `${modalElRect.left}px`;
            modalEl.showModal();
    }
        function debounce(fn, ms) {
            var timer;
            return function (e) {
                clearTimeout(timer);
                timer = setTimeout((function (v) {
                    return function () {
                        fn(v);
                    };
                })(e), ms);
            }
        }
        function buildBoard(boardRoot, width, height) {
            let cellCount = width * height;
            let boardHtml = [];
            for (let i = 0; i < cellCount; i++) {
                boardHtml.push(`<button class="cell hidden" data-cell="${i}"><span class="overlay">&nbsp;</span></button>`);
            }
            boardRoot.innerHTML = boardHtml.join('') + MineBoard.clearBoardHtml;
            document.querySelectorAll("dialog").forEach(el => el.addEventListener("click", () => el.close()));
            let docEl = document.documentElement;
            let mineSize = (docEl.scrollWidth / 2) / width;
            docEl.style.setProperty("--size-mine", `${mineSize}px`);
            docEl.style.setProperty("--size-icon", `${mineSize - 12}px`);
            boardRoot.style.width = `${(mineSize + 2) * width}px`;
            boardRoot.addEventListener("contextmenu", (e) => e.preventDefault());
            boardRoot.addEventListener("mousedown", debounce(function (e) {
                if (e.target.classList.contains("cell")) {
                    let cellIndex = parseInt(e.target.getAttribute("data-cell"), 10);
                    board.cells[cellIndex].element = e.target;
                    if (e.button === 0) {
                        console.log(`cell ${cellIndex} clicked`);
                        board.revealCell.call(board, cellIndex, Boolean(e.hadOverlay), true);
                    }
                    if (e.button === 2) {
                        console.log(`cell ${cellIndex} flagged`);
                        board.toggleFlag.call(board, cellIndex, Boolean(e.hadOverlay));
                    }
                } else if (e.target.classList.contains("overlay")) {
                    let cel = e.target.parentElement;
                    let evt = new MouseEvent(e.type, e);
                    evt.hadOverlay = true;
                    evt.preventDefault();
                    cel.dispatchEvent(evt);
                }
                e.preventDefault();
                e.stopPropagation();
            }, 20));
            let board = new MineBoard(boardRoot, width, height);
            board.init();
            board.cells.forEach((c, i) => {
                c.element = document.querySelector(`button[data-cell="${i}"]`);
            });
            document.querySelector(".count").innerHTML = board.mineCount;
        }
        function difficultyChanged(e) {
            if (e.target.name !== "difficulty") {
                return true;
            }

            let boardRoot = document.querySelector(".board");
            let timerRoot = document.querySelector(".timer");
            let timerId = parseInt(timerRoot.getAttribute("data-timer"), 10);
            if (!isNaN(timerId)) {
                clearInterval(timerId);
            }
            let customWidthEl = document.querySelector('[name="custom-width"]');
            let customHeightEl = document.querySelector('[name="custom-height"]');
            let customBoard = {
                gotWidth: false,
                gotHeight: false,
                customWidth: -1,
                customHeight: -1
            };
            let validateCustomBoard = function (e) {
                if (e.target.name === "custom-width") {
                    let width = parseInt(e.target.value, 10);
                    if (!isNaN(width)) {
                        customBoard.gotWidth = true;
                        customBoard.width = width;
                    }
                }
                if (e.target.name === "custom-height") {
                    let height = parseInt(e.target.value, 10);
                    if (!isNaN(height)) {
                        customBoard.gotHeight = true;
                        customBoard.height = height;
                    }
                }
                if (customBoard.gotHeight && customBoard.gotWidth) {
                    buildBoard(boardRoot, customBoard.width, customBoard.height);
                }
            };

            let value = e.target.value;
            switch (value) {
                case "9":
                    buildBoard(boardRoot, 9, 9);
                    break;
                case "16":
                    buildBoard(boardRoot, 16, 16);
                    break;
                case "30":
                    buildBoard(boardRoot, 30, 16);
                    break;
                case "?":
                    customWidthEl.disabled = false;
                    customHeightEl.disabled = false;
                    customWidthEl.addEventListener("blur", validateCustomBoard);
                    customHeightEl.addEventListener("blur", validateCustomBoard);
                    break;
            }
        }
        window.onload = function () {
            let difficultyFieldset = document.querySelector(".fieldset");
            difficultyFieldset.addEventListener("click", difficultyChanged);
            let radioClickedEvent = new MouseEvent("click", {
                bubbles: true,
                cancelable: true,
                scoped: false
            });
            document.querySelector('[name="difficulty"][value="9"]').dispatchEvent(radioClickedEvent);
        };
    </script>
</head>

<body>
    <form>
        <div class="fieldset">
            <div class="legend">Select difficulty</div>
            <label class="radio">
                <input type="radio" name="difficulty" value="9" checked/> Easy (9x9)
            </label>
            <label class="radio">
                <input type="radio" name="difficulty" value="16" /> Medium (16x16)
            </label>
            <label class="radio">
                <input type="radio" name="difficulty" value="30" /> Expert (30x16)
            </label>
            <label class="radio">
                <input type="radio" name="difficulty" value="?" /> Custom (
                <input type="number" name="custom-width" class="custom-unit" value="30" disabled/>x
                <input type="number" name="custom-height" class="custom-unit" value="16" disabled/>)
            </label>
        </div>
    </form>
    <div class="scoreboard">
        <span class="scoreboard-unit">
            <span class="icon clock">⏱</span>
            <span class="timer">00:00</span>
        </span>
        <span class="scoreboard-unit">
            <span class="icon mine">💣</span>
            <span class="count">10</span>
        </span>
    </div>
    <div class="board">
    </div>
</body>

</html>